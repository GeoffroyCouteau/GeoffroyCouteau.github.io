{
  "version": "1.0",
  "timestamp": "2025-08-28T13:48:39.779Z",
  "localStorage": {
    "cryptoPapersCache": "[{\"id\":1755286386426.5227,\"title\":\"Correlated Pseudorandom Functions from Variable-Density LPN\",\"authors\":\"Elette Boyle (Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, and Peter Scholl)\",\"abstract\":\"Correlated secret randomness is a useful resource for many cryptographic applications.  We initiate the study of pseudorandom correlation functions (PCFs) that offer the ability to securely generate virtually unbounded sources of correlated randomness using only local computation. Concretely, a PCF is a keyed function ùêπ ùëò such that for a suitable joint key distribution ( ùëò 0 , ùëò 1 ) , the outputs ( ùëì ùëò 0 ( ùë• ) , ùëì ùëò 1 ( ùë• ) ) are indistinguishable from instances of a given target correlation. An essential security requirement is that indistinguishability hold not only for outsiders, who observe the pairs of outputs, but also for insiders who know one of the two keys. We present efficient constructions of PCFs for a broad class of useful correlations, including oblivious transfer and multiplication triple correlations, from a variable-density variant of the Learning Parity with Noise assumption (VDLPN). We also present several cryptographic applications that motivate our efficient PCF constructions. The VDLPN assumption is independently motivated by two additional applications. First, different flavors of this assumption give rise to weak pseudorandom function candidates in depth-2 AC 0 [ ‚äï ] that can be conjectured to have subexponential security, matching the best known learning algorithms for this class. This is contrasted with the quasipolynomial security of previous (higher-depth) AC 0 [ ‚äï ] candidates.  We support our conjectures by proving resilience to several classes of attacks. Second, VDLPN implies simple constructions of pseudorandom generators and weak pseudorandom functions with security against XOR related-key attacks.\",\"date\":\"2020-11-15\",\"url\":\"https://eprint.iacr.org/2020/1417\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:06.426Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"eboyle@alum.mit.edu\",\"couteau@irif.fr\",\"niv.gilboa@gmail.com\",\"yuvali@cs.technion.ac.il\",\"lisa.kohl@cwi.nl\",\"peter.scholl@cs.au.dk\"],\"favorite\":false},{\"id\":1755286389230.5398,\"title\":\"The Resiliency of MPC with Low Interaction: The Benefit of Making Errors\",\"authors\":\"Benny Applebaum (Eliran Kachlon, and Arpita Patra)\",\"abstract\":\"We study information-theoretic secure multiparty protocols that achieve full security, including guaranteed output delivery, at the presence of an active adversary that corrupts a constant fraction of the parties. It is known that 2 rounds are insufficient for such protocols even when the adversary corrupts only two parties (Gennaro, Ishai, Kushilevitz, and Rabin; Crypto 2002), and that perfect protocols can be implemented in 3 rounds as long as the adversary corrupts less than a quarter of the parties (Applebaum , Brakerski, and Tsabary; Eurocrypt, 2019). Furthermore, it was recently shown that the quarter threshold is tight for any 3-round \\\\emph{perfectly-secure} protocol (Applebaum, Kachlon, and Patra; FOCS 2020). Nevertheless, one may still hope to achieve a better-than-quarter threshold at the expense of allowing some negligible correctness errors and/or statistical deviations in the security. Our main results show that this is indeed the case. Every function can be computed by 3-round protocols with \\\\emph{statistical} security as long as the adversary corrupts less than a third of the parties. Moreover, we show that any better resiliency threshold requires 4 rounds. Our protocol is computationally inefficient and has an exponential dependency in the circuit's depth ùëë and in the number of parties ùëõ . We show that this overhead can be avoided by relaxing security to computational, assuming the existence of a non-interactive commitment (NICOM). Previous 3-round computational protocols were based on stronger public-key assumptions. When instantiated with statistically-hiding NICOM, our protocol provides \\\\emph{everlasting statistical} security, i.e., it is secure against adversaries that are computationally unlimited \\\\emph{after} the protocol execution. To prove these results, we introduce a new hybrid model that allows for 2-round protocols with a linear resiliency threshold. Here too we prove that, for perfect protocols, the best achievable resiliency is ùëõ / 4 , whereas statistical protocols can achieve a threshold of ùëõ / 3 . In the plain model, we also construct the first 2-round ùëõ / 3 -statistical verifiable secret sharing that supports second-level sharing and prove a matching lower-bound, extending the results of Patra, Choudhary, Rabin, and Rangan (Crypto 2009). Overall, our results refine the differences between statistical and perfect models of security and show that there are efficiency gaps even for thresholds that are realizable in both models. Note: Fixed rendering issues - text was somewhat blurry in the previous version.\",\"date\":\"2020-11-15\",\"url\":\"https://eprint.iacr.org/2020/1419\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:09.230Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"benny.applebaum@gmail.com\",\"elirn.chalon@gmail.com\",\"arpita@iisc.ac.in\"],\"favorite\":false},{\"id\":1755286392341.1716,\"title\":\"On Statistical Security in Two-Party Computation\",\"authors\":\"Dakshita Khurana and Muhammad Haris Mughees\",\"abstract\":\"There has been a large body of work characterizing the round complexity of general-purpose maliciously secure two-party computation (2PC) against probabilistic polynomial time adversaries. This is particularly true for zero-knowledge, which is a special case of 2PC. In fact, in the special case of zero knowledge, optimal protocols with unconditional security against one of the two players have also been meticulously studied and constructed. On the other hand, general-purpose maliciously secure 2PC with statistical or unconditional security against one of the two participants has remained largely unexplored so far. In this work, we initiate the study of such protocols, which we refer to as 2PC with one-sided statistical security. We settle the round complexity of 2PC with one-sided statistical security with respect to black-box simulation by obtaining the following tight results: In a setting where only one party obtains an output, we design  2PC in 4 rounds with statistical security against receivers and computational security against senders. In a setting where both parties obtain outputs, we design 2PC in 5 rounds with computational security against the party that obtains output first and statistical security against the party that obtains output last. Katz and Ostrovsky (CRYPTO 2004) showed that 2PC with black-box simulation requires at least 4 rounds when one party obtains an output and 5 rounds when both parties obtain outputs, even when only computational security is desired against both parties. Thus in these settings, not only are our results tight, but they also show that statistical security is achievable at no extra cost to round complexity. This still leaves open the question of whether 2PC can be achieved with black-box simulation in 4 rounds with statistical security against senders and computational security against receivers.  Based on a lower bound on computational zero-knowledge proofs due to Katz (TCC 2008), we observe that the answer is negative unless the polynomial hierarchy collapses.\",\"date\":\"2020-11-15\",\"url\":\"https://eprint.iacr.org/2020/1428\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:12.341Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"dakshita@illinois.edu\",\"mughees2@illinois.edu\"],\"favorite\":false},{\"id\":1755286398077.5823,\"title\":\"On Computational Shortcuts for Information-Theoretic PIR\",\"authors\":\"Matthew M. Hong, Yuval Ishai, Victor I. Kolobov, Russell W. F. Lai\",\"abstract\":\"Information-theoretic private information retrieval (PIR) schemes have attractive concrete efficiency features. However, in the standard PIR model, the computational complexity of the servers must scale linearly with the database size. We study the possibility of bypassing this limitation in the case where the database is a truth table of a \\\"simple\\\" function, such as a union of (multi-dimensional) intervals or convex shapes, a decision tree, or a DNF formula. This question is motivated by the goal of obtaining lightweight homomorphic secret sharing (HSS) schemes and secure multiparty computation (MPC) protocols for the corresponding families. We obtain both positive and negative results. For \\\"first-generation\\\" PIR schemes based on Reed-Muller codes, we obtain computational shortcuts for the above function families, with the exception of DNF formulas for which we show a (conditional) hardness result. For \\\"third-generation\\\" PIR schemes based on matching vectors, we obtain stronger hardness results that apply to all of the above families. Our positive results yield new information-theoretic HSS schemes and MPC protocols with attractive efficiency features for simple but useful function families. Our negative results establish new connections between information-theoretic cryptography and fine-grained complexity. Note: Correction made to Figure 12.\",\"date\":\"2020-11-15\",\"url\":\"https://eprint.iacr.org/2020/1429\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:18.077Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"hoou8547@hotmail.com\",\"yuvali@cs.technion.ac.il\",\"kolobov.victor@gmail.com\",\"russellnhellman@gmail.com\"],\"favorite\":false},{\"id\":1755286401113.589,\"title\":\"Revisiting Fairness in MPC: Polynomial Number of Parties and General Adversarial Structures\",\"authors\":\"Dana Dachman-Soled\",\"abstract\":\"We investigate fairness in secure multiparty computation when the number of parties ùëõ = ùëù ùëú ùëô ùë¶ ( ùúÜ ) grows polynomially in the security parameter, ùúÜ . Prior to this work, efficient protocols achieving fairness with no honest majority and polynomial number of parties were known only for the AND and OR functionalities (Gordon and Katz, TCC'09). We show the following: --We first consider symmetric Boolean functions ùêπ : { 0 , 1 } ùëõ ‚Üí { 0 , 1 } , where the underlying function ùëì ùëõ / 2 , ùëõ / 2 : { 0 , ‚Ä¶ , ùëõ / 2 } √ó { 0 , ‚Ä¶ , ùëõ / 2 } ‚Üí { 0 , 1 } can be computed fairly and efficiently in the 2 -party setting. We present an efficient protocol for any such ùêπ tolerating ùëõ / 2 or fewer corruptions, for ùëõ = ùëù ùëú ùëô ùë¶ ( ùúÜ ) number of parties. --We present an efficient protocol for ùëõ -party majority tolerating ùëõ / 2 + 1 or fewer corruptions, for ùëõ = ùëù ùëú ùëô ùë¶ ( ùúÜ ) number of parties. The construction extends to ùëõ / 2 + ùëê or fewer corruptions, for constant ùëê . --We extend both of the above results to more general types of adversarial structures and present instantiations of non-threshold adversarial structures of these types. These instantiations are obtained via constructions of projective planes and combinatorial designs.\",\"date\":\"2020-11-15\",\"url\":\"https://eprint.iacr.org/2020/1430\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:21.113Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"danadach@umd.edu\"],\"favorite\":false},{\"id\":1755286404502.1404,\"title\":\"Information-Theoretic 2-Round MPC without Round Collapsing: Adaptive Security, and More\",\"authors\":\"Huijia Lin (Tianren Liu, and Hoeteck Wee)\",\"abstract\":\"We present simpler and improved constructions of 2-round protocols for secure multi-party computation (MPC) in the semi-honest setting.  Our main results are new information-theoretically secure protocols for arithmetic NC1 in two settings: (i) the plain model tolerating up to ùë° < ùëõ / 2 corruptions; and (ii) in the OLE-correlation model tolerating any number of corruptions. Our protocols achieve adaptive security and require only black-box access to the underlying field, whereas previous results only achieve static security and require non-black-box field access. Moreover, both results extend to polynomial-size circuits with computational and adaptive security, while relying on black-box access to a pseudorandom generator. In the OLE correlation model, the extended protocols for circuits tolerate up to ùëõ ‚àí 1 corruptions. Along the way, we introduce a conceptually novel framework for 2-round MPC that does not rely on the round collapsing framework underlying all of the recent advances in 2-round MPC.\",\"date\":\"2020-11-15\",\"url\":\"https://eprint.iacr.org/2020/1431\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:24.502Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"rachel@cs.washington.edu\",\"wee@di.ens.fr\",\"liutr@mit.edu\"],\"favorite\":false},{\"id\":1755286407234.1616,\"title\":\"Towards Multiparty Computation Withstanding Coercion of All Parties\",\"authors\":\"Ran Canetti and Oxana Poburinnaya\",\"abstract\":\"Incoercible multi-party  computation (Canetti-Gennaro ‚Äô96) allows parties to engage in  secure computation  with the  additional guarantee that the public transcript of the computation cannot be used by a coercive outsider  to verify representations made by the parties regarding their inputs, outputs, and local random choices.  That is, it is guaranteed that the only deductions regarding the truthfulness of such representations, made by an outsider who has witnessed the communication among the parties,  are the ones that can be drawn just from the represented inputs and outputs alone. To date, all incoercible  secure computation protocols  withstand coercion of only a fraction of the parties, or else assume that all parties use an  execution environment that makes some crucial parts of their local states physically inaccessible even to themselves. We consider, for the first time, the  setting where all parties are coerced, and the coercer expects to see the entire history of the computation. We allow both protocol participants and external attackers to access a common reference string which is generated once and for all by an uncorruptable trusted party. In this setting we construct: -  A general  multi-party function evaluation protocol, for any number of parties, that withstands coercion of all parties, as long as all parties use the prescribed ``faking algorithm'' upon coercion.  This holds even if the inputs and outputs represented by coerced parties are globally inconsistent with the evaluated function. - A general two-party function evaluation protocol  that withstands even  the %``mixed'' case where some of the coerced parties do follow the prescribed faking algorithm. (For instance, these parties might collude  with the coercer and disclose their true local states.) This protocol is limited to  functions where the input of at least one of the parties is taken from a small (poly-size) domain. It uses fully deniable encryption with public deniability for one of the parties; when instantiated using the fully deniable encryption of Canetti, Park, and Poburinnaya (Crypto'20), it takes 3 rounds of communication. Both protocols operate in the common reference string model, and use  fully bideniable encryption (Canetti Park and Poburinnaya, Crypto'20) and sub-exponential indistinguishability obfuscation. Finally, we show that protocols with certain communication pattern cannot be incoercible, even in a weaker setting where only some parties are coerced.\",\"date\":\"2020-11-15\",\"url\":\"https://eprint.iacr.org/2020/1434\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:27.234Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"canetti@bu.edu\",\"oxanapob@bu.edu\"],\"favorite\":false},{\"id\":1755286410548.8152,\"title\":\"Round-Optimal and Communication-Efficient Multiparty Computation\",\"authors\":\"Michele Ciampi, Rafail Ostrovsky, Hendrik Waldner, Vassilis Zikas\",\"abstract\":\"Typical approaches for minimizing the round complexity of multiparty computation (MPC) come at the cost of increased communication complexity (CC) or the reliance on setup assumptions. A notable exception is the recent work of Ananth et al. [TCC 2019], which used Functional Encryption (FE) combiners to obtain a round optimal (two-round) semi-honest MPC in the plain model with a CC proportional to the depth and input-output length of the circuit being computed‚Äîwe refer to such protocols as circuit scalable. This leaves open the question of obtaining communication efficient protocols that are secure against malicious adversaries in the plain model, which we present in this work. Concretely, our two main contributions are: 1) We provide a round-preserving black-box compiler that compiles a wide class of MPC protocols into circuit-scalable maliciously secure MPC protocols in the plain model, assuming (succinct) FE combiners. 2) We provide a round-preserving black-box compiler that compiles a wide class of MPC protocols into circuit-independent‚Äî i.e., with a CC that depends only on the input-output length of the circuit‚Äîmaliciously secure MPC protocols in the plain model, assuming Multi-Key Fully-Homomorphic Encryption (MFHE). Our constructions are based on a new compiler that turns a wide class of MPC protocols into k-delayed-input function MPC protocols (a notion we introduce), where the function that is being computed is specified only in the k-th round of the protocol. As immediate corollaries of our two compilers, we derive (1) the first round-optimal and circuit-scalable maliciously secure MPC protocol, and (2) the first round-optimal and circuit-independent maliciously secure MPC protocol in the plain model. The latter achieves the best to-date CC for a round-optimal maliciously secure MPC protocol. In fact, it is even communication-optimal when the output size of the function being evaluated is smaller than its input size (e.g., for boolean functions). All of our results are based on standard polynomial time assumptions.\",\"date\":\"2020-11-15\",\"url\":\"https://eprint.iacr.org/2020/1437\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:30.548Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"michele.ciampi@ed.ac.uk\",\"rafail@cs.ucla.edu\",\"hendrik.waldner@ed.ac.uk\",\"vzikas@cs.purdue.edu\"],\"favorite\":false},{\"id\":1755286413777.8484,\"title\":\"Compressed\",\"authors\":\"-Protocols for Bilinear Group Arithmetic Circuits and Application to Logarithmic Transparent Threshold Signatures, Thomas Attema (Netherlands Organisation for Applied Scientific Research), Ronald Cramer (Centrum Wiskunde & Informatica;), Matthieu Rambaud (T√©l√©com ParisTech)\",\"abstract\":\"Lai et al. (CCS 2019) have shown how Bulletproof‚Äôs arithmetic circuit zero-knowledge protocol (Bootle et al., EUROCRYPT 2016 and B√ºnz et al., S&P 2018) can be generalized to work for bilinear group arithmetic circuits directly, i.e., without requiring these circuits to be translated into arithmetic circuits. In a nutshell, a bilinear group arithmetic circuit is a standard arithmetic circuit augmented with special gates capturing group exponentiations or pairings. Such circuits are highly relevant, e.g., in the context of zero-knowledge statements over pairing-based languages. As expressing these special gates in terms of a standard arithmetic circuit results in a significant overhead in circuit size, an approach to zero-knowledge via standard arithmetic circuits may incur substantial additional costs. The approach due to Lai et al. shows how to avoid this by integrating additional zero-knowledge techniques into the Bulletproof framework so as to handle the special gates very efficiently. We take a different approach by generalizing Compressed Œ£ -Protocol Theory (CRYPTO 2020) from arithmetic circuit relations to bilinear group arithmetic circuit relations. Besides its conceptual simplicity, our approach has the practical advantage of reducing the communication costs of Lai et al.'s protocol by roughly a multiplicative factor 3. Finally, we show an application of our results which may be of independent interest. We construct the first k-out-of-n threshold signature scheme (TSS) that allows for transparent setup and that yields threshold signatures of size logarithmic in n. The threshold signature hides the identities of the k signers and the threshold k can be dynamically chosen at aggregation time. Note: Change log w.r.t. Version 3 - March 10, 2021: (a) editorial changes throughout, (b) corrected a technical oversight in Appendix A without affecting the rest of the paper, and (c) added a short discussion on seemingly contradictory complexity assumptions (Section 5.2).\",\"date\":\"2020-11-19\",\"url\":\"https://eprint.iacr.org/2020/1447\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:33.777Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"thomas.attema@tno.nl\",\"cramer@cwi.nl\",\"rambaud@enst.fr\"],\"favorite\":false},{\"id\":1755286417224.354,\"title\":\"Efficient Fully Secure Computation via Distributed Zero-Knowledge Proofs\",\"authors\":\"Elette Boyle (Niv Gilboa, Yuval Ishai, and Ariel Nof)\",\"abstract\":\"Secure computation protocols enable mutually distrusting parties to compute a function of their private inputs while revealing nothing but the output. Protocols with {\\\\em full security} (also known as {\\\\em guaranteed output delivery}) in particular protect against denial-of-service attacks, guaranteeing that honest parties receive a correct output. This feature can be realized in the presence of an honest majority, and significant research effort has gone toward attaining full security with good asymptotic and concrete efficiency. We present an efficient protocol for {\\\\em any constant} number of parties ùëõ , with {\\\\em full security} against ùë° < ùëõ / 2 corrupted parties, that makes a black-box use of a pseudorandom generator. Our protocol evaluates an arithmetic circuit ùê∂ over a finite ring ùëÖ (either a finite field or ùëÖ = \\\\Z 2 ùëò ) with communication complexity of 3 ùë° 2 ùë° + 1 ùëÜ + ùëú ( ùëÜ ) ùëÖ -elements per party, where ùëÜ is the number of multiplication gates in ùê∂ (namely, < 1.5 elements per party per gate). This matches the best known protocols for the semi-honest model up to the sublinear additive term. For a small number of parties ùëõ , this improves over a recent protocol of Goyal {\\\\em et al.} (Crypto 2020) by a constant factor for circuits over large fields, and by at least an Œ© ( log ‚Å° ùëõ ) factor for Boolean circuits or circuits over rings. Our protocol provides new methods for applying the sublinear-communication distributed zero-knowledge proofs of Boneh {\\\\em et al.}~(Crypto 2019) for compiling semi-honest protocols into fully secure ones, in the more challenging case of ùë° > 1 corrupted parties. Our protocol relies on {\\\\em replicated secret sharing} to minimize communication and simplify the mechanism for achieving full security. This results in computational cost that scales exponentially with ùëõ . Our main fully secure protocol builds on a new intermediate honest-majority protocol for verifying the correctness of multiplication triples by making a {\\\\em general} use of distributed zero-knowledge proofs. While this intermediate protocol only achieves the weaker notion of {\\\\em security with abort}, it applies to any linear secret-sharing scheme and provides a conceptually simpler, more general, and more efficient alternative to previous protocols from the literature. In particular, it can be combined with the Fiat-Shamir heuristic to simultaneously achieve logarithmic communication complexity and constant round complexity.\",\"date\":\"2020-11-19\",\"url\":\"https://eprint.iacr.org/2020/1451\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:37.224Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"nofdinar@gmail.com\"],\"favorite\":false},{\"id\":1755286421518.3918,\"title\":\"Round Efficient Secure Multiparty Quantum Computation with Identifiable Abort\",\"authors\":\"Bar Alon (Hao Chung, Kai-Min Chung, Mi-Ying Huang, Yi Lee, and Yu-Ching Shen)\",\"abstract\":\"A recent result by Dulek et al. (EUROCRYPT 2020) showed a secure protocol for computing any quantum circuit even without the presence of an honest majority. Their protocol, however, is susceptible to a ``denial of service'' attack and allows even a single corrupted party to force an abort. We propose the first quantum protocol that admits security-with-identifiable-abort, which allows the honest parties to agree on the identity of a corrupted party in case of an abort. Additionally, our protocol is the first to have the property that the number of rounds where quantum communication is required is independent of the circuit complexity. Furthermore, if there exists a post-quantum secure classical protocol whose round complexity is independent of the circuit complexity, then our protocol has this property as well. Our protocol is secure under the assumption that classical quantum-resistant fully homomorphic encryption schemes with decryption circuit of logarithmic depth exist. Interestingly, our construction also admits a reduction from quantum fair secure computation to classical fair secure computation.\",\"date\":\"2020-11-24\",\"url\":\"https://eprint.iacr.org/2020/1464\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:41.518Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"kmchung@iis.sinica.edu.tw\"],\"favorite\":false},{\"id\":1755286424080.947,\"title\":\"On The Round Complexity of Secure Quantum Computation\",\"authors\":\"James Bartusek (Andrea Coladangelo, Dakshita Khurana, and Fermi Ma)\",\"abstract\":\"We construct the first constant-round protocols for secure quantum computation in the two-party (2PQC) and multi-party (MPQC) settings with security against malicious adversaries. Our protocols are in the common random string (CRS) model. - Assuming two-message oblivious transfer (OT), we obtain (i) three-message 2PQC, and (ii) five-round MPQC with only three rounds of online (input-dependent) communication; such OT is known from quantum-hard Learning with Errors (QLWE). - Assuming sub-exponential hardness of QLWE, we obtain (i) three-round 2PQC with two online rounds and (ii) four-round MPQC with two online rounds. - When only one (out of two) parties receives output, we achieve minimal interaction (two messages) from two-message OT; classically, such protocols are known as non-interactive secure computation (NISC), and our result constitutes the first maliciously-secure quantum NISC.  Additionally assuming reusable malicious designated-verifier NIZK arguments for NP (MDV-NIZKs), we give the first MDV-NIZK for QMA that only requires one copy of the quantum witness. Finally, we perform a preliminary investigation into two-round secure quantum computation where each party must obtain output. On the negative side, we identify a broad class of simulation strategies that suffice for classical two-round secure computation that are unlikely to work in the quantum setting. Next, as a proof-of-concept, we show that two-round secure quantum computation exists with respect to a quantum oracle. Note: updated acknowledgments\",\"date\":\"2020-11-24\",\"url\":\"https://eprint.iacr.org/2020/1471\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:44.080Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"bartusek.james@gmail.com\",\"andrea.coladangelo@gmail.com\",\"dakshita@illinois.edu\",\"fermima@alum.mit.edu\"],\"favorite\":false},{\"id\":1755286427239.3442,\"title\":\"Design and implementation of HElib: a homomorphic encryption library\",\"authors\":\"Shai Halevi and Victor Shoup\",\"abstract\":\"HElib is a C++ open source library (see https://github.com/homenc/HElib) that implements both the BGV and CKKS  fully homomorphic encryption (FHE) schemes. This document summarizes some of the basic design principles of HElib, and describes some of its fundamental algorithms and data structures in signi&#64257;cant detail. It is a work in progress, and currently focuses exclusively on the BGV scheme.\",\"date\":\"2020-11-29\",\"url\":\"https://eprint.iacr.org/2020/1481\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:47.239Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"shoup@cs.nyu.edu\"],\"favorite\":false},{\"id\":1755286429808.9956,\"title\":\"A Low-Depth Homomorphic Circuit for Logistic Regression Model Training\",\"authors\":\"Eric Crockett\",\"abstract\":\"Machine learning is an important tool for analyzing large data sets, but its use on sensitive data may be limited by regulation. One solution to this problem is to perform machine learning tasks on encrypted data using homomorphic encryption, which enables arbitrary computation on encrypted data. We take a fresh look at one specific task: training a logistic regression model on encrypted data. The most important factor in the efficiency of a solution is the multiplicative depth of the homomorphic circuit. Two prior works have given circuits with multiplicative depth of five per training iteration. We optimize one of these solutions, by Han et al. [Han+18], and give a circuit with half the multiplicative depth per iteration on average, which allows us to perform twice as many training iterations in the same amount of time. In the process of improving the state-of-the-art circuit for this task, we identify general techniques to improve homomorphic circuit design for two broad classes of algorithms: iterative algorithms, and algorithms based on linear algebra over real numbers. First, we formalize the encoding scheme from [Han+18] for encoding linear algebra objects as plaintexts in the CKKS homomorphic encryption scheme. We also show how to use this encoding to homomorphically compute many basic linear algebra operations, including novel operations not discussed in prior work. This ‚Äútoolkit‚Äù is generic, and can be used in any application based on linear algebra. Second, we demonstrate how generic compiler techniques for loop optimization can be used to reduce the multiplicative depth of iterative algorithms. Note: Fixed abstract formatting\",\"date\":\"2020-11-29\",\"url\":\"https://eprint.iacr.org/2020/1483\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:49.808Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"ecrockett0@gmail.com\"],\"favorite\":false},{\"id\":1755286432546.0134,\"title\":\"One-Way Functions Imply Secure Computation in a Quantum World\",\"authors\":\"James Bartusek (Andrea Coladangelo, Dakshita Khurana, and Fermi Ma)\",\"abstract\":\"We prove that quantum-hard one-way functions imply simulation-secure quantum oblivious transfer (QOT), which is known to suffice for secure computation of arbitrary quantum functionalities. Furthermore, our construction only makes black-box use of the quantum-hard one-way function. Our primary technical contribution is a construction of extractable and equivocal quantum bit commitments based on the black-box use of quantum-hard one-way functions in the standard model. Instantiating the Cr√©peau-Kilian (FOCS 1988) framework with these commitments yields simulation-secure QOT.\",\"date\":\"2020-11-29\",\"url\":\"https://eprint.iacr.org/2020/1487\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:52.546Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"bartusek.james@gmail.com\",\"andrea.coladangelo@gmail.com\",\"dakshita@illinois.edu\",\"fermima@alum.mit.edu\"],\"favorite\":false},{\"id\":1755286435783.326,\"title\":\"Efficient Scalable Multi-Party Private Set Intersection Using Oblivious PRF\",\"authors\":\"Alireza Kavousi (Javad Mohajeri, and Mahmoud Salmasizadeh)\",\"abstract\":\"In this paper, we present a concretely efficient protocol for private set intersection (PSI) in the multi-party setting using oblivious pseudorandom function (OPRF). In fact, we generalize the approach used in the work of Chase and Miao [CRYPTO 2020] towards deploying a lightweight multi-point OPRF construction for two-party PSI. Our protocol only includes oblivious transfer (OT) extension and garbled Bloom filter as its main ingredients and avoids computationally expensive operations.  From a communication pattern perspective, the protocol consists of two types of interactions. The first type is performed over a star-like communication graph in which one designated party interacts with all other parties via performing OTs as the sender. Besides, parties communicate through a path-like communication graph that involves sending a garbled Bloom filter from the first party to its neighboring party following the last one. This design makes our protocol to be highly scalable due to the independence of each party's complexity from the number of participating parties and thus causes a communication and computation complexities of ùëÇ ( ùëõ ùúÜ ùëò ) , where ùëõ is the set size, ùëò is the number of hash functions, and ùúÜ is the security parameter. Moreover, the asymptotic complexity of the designated party is ùëÇ ( ùë° ùëõ ùúÜ ) which linearly scales with the number of parties ùë° . We prove security of the proposed protocol against semi-honest adversaries.\",\"date\":\"2021-04-16\",\"url\":\"https://eprint.iacr.org/2021/484\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:55.783Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"a.kavousi95@gmail.com\"],\"favorite\":false},{\"id\":1755286438486.852,\"title\":\"Order-C Secure Multiparty Computation for Highly Repetitive Circuits\",\"authors\":\"Gabrielle Beck (Aarushi Goel, Abhishek Jain, and Gabriel Kaptchuk)\",\"abstract\":\"Running secure multiparty computation (MPC) protocols with hundreds or thousands of players would allow leveraging large volunteer networks (such as blockchains and Tor) and help justify honest majority assumptions. However, most existing protocols have at least a linear (multiplicative)dependence on the number of players, making scaling difficult. Known protocols with asymptotic efficiency  independent  of  the  number  of  parties  (excluding  additive  factors)  require  expensive  circuit transformations that induce large overheads. We observe that the circuits used in many important applications of MPC such as training algorithms  used  to  create  machine  learning  models  have  a highly repetitive structure.  We  formalize  this class of circuits and propose an MPC protocol that achieves O(|C|) total complexity for this class. We implement our protocol and show that it is practical and outperforms O(n|C|) protocols for modest numbers of players.\",\"date\":\"2021-04-19\",\"url\":\"https://eprint.iacr.org/2021/500\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:33:58.486Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"gbeck@cs.jhu.edu\",\"aarushig@cs.jhu.edu\",\"abhishek@cs.jhu.edu\",\"kaptchuk@bu.edu\"],\"favorite\":false},{\"id\":1755287789230.5583,\"title\":\"zkHawk: Practical Private Smart Contracts from MPC-based Hawk\",\"authors\":\"Aritra Banerjee (Michael Clear, and Hitesh Tewari)\",\"abstract\":\"Cryptocurrencies have received a lot of research attention in recent years following the release of the first cryptocurrency Bitcoin. With the rise in cryptocurrency transactions, the need for smart contracts has also increased. Smart contracts, in a nutshell, are digitally executed contracts wherein some parties execute a common goal. The main problem with most of the current smart contracts is that there is no privacy for a party's input to the contract from either the blockchain or the other parties. Our research builds on the Hawk project that provides transaction privacy along with support for smart contracts. However, Hawk relies on a special trusted party known as a manager, which must be trusted not to leak each party's input to the smart contract. In this paper, we present a practical private smart contract protocol that replaces the manager with an MPC protocol such that the function to be executed by the MPC protocol is relatively lightweight, involving little overhead added to the smart contract function, and uses practical sigma protocols and homomorphic commitments to prove to the blockchain that the sum of the incoming balances to the smart contract matches the sum of the outgoing balances. Note: Extended Version of the IEEE BRAINS'21 Conference Paper\",\"date\":\"2021-04-19\",\"url\":\"https://eprint.iacr.org/2021/501\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:29.230Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"abanerje@tcd.ie\"],\"favorite\":false},{\"id\":1755287791627.4697,\"title\":\"Almost-Asynchronous MPC under Honest Majority, Revisited\",\"authors\":\"Matthieu Rambaud and Antoine Urban\",\"abstract\":\"Multiparty computation does not tolerate ùëõ / 3 corruptions under a plain asynchronous communication network, whatever the computational assumptions. However, Beerliov√°-Hirt-Nielsen [BHN, Podc'10] showed that, assuming access to a synchronous broadcast at the beginning of the protocol, enables to tolerate up to ùë° < ùëõ / 2 corruptions. This model is denoted as ``Almost asynchronous'' MPC. Yet, their work [BHN] has limitations: (i) \\\\emph{Setup assumptions:} their protocol is based on an encryption scheme, with homomorphic additivity,  which requires that a trusted entity gives to players secret shares of a global decryption key ahead of the protocol. It was left as an open question in [BHN] whether one can remove this assumption, denoted as ``trusted setup''. (ii) \\\\emph{Common Randomness generation:} the generation of threshold additively homomorphic encrypted randomness uses the broadcast, therefore is allowed only at the beginning of the protocol (iii) \\\\emph{Proactive security:} the previous limitation directly precludes the possibility of tolerating a mobile adversary. Indeed, tolerance to this kind of adversary, which is denoted as ``proactive'' MPC, would require, in the above setup, a mechanism by which players refresh their secret shares of the global key, which requires \\\\emph{on-the-fly} generation of common randomness. (iv) \\\\emph{Triple generation latency: } The protocol to preprocess the material necessary for multiplication has latency ùë° , which is thus linear in the number of players. We remove all the previous limitations. Of independent interest, the novel computation framework that we introduce for proactivity, revolves around players denoted as ``kings'', which, in contrast to Podc'10, are now \\\\emph{replaceable} after every elementary step of the computation. Note: Change log w.r.t. Version 3 - 3 September 2021: Removed NIZK in the TAE and the non-proactive protocol of Thm 1, explicit succinct NIZK. Change log w.r.t. Version 4 - 8 November 2021: Univariate PVSS, UC Proofs, noninteractive proactive refresh, AAMPC from TFHE.\",\"date\":\"2021-04-19\",\"url\":\"https://eprint.iacr.org/2021/503\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:31.627Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"matthieu.rambaud@telecom-paris.fr\",\"antoine.urban@telecom-paris.fr\"],\"favorite\":false},{\"id\":1755287794851.253,\"title\":\"Improved Circuit Compilation for Hybrid MPC via Compiler Intermediate Representation\",\"authors\":\"Daniel Demmler (Stefan Katzenbeisser, Thomas Schneider, Tom Schuster, and Christian Weinert)\",\"abstract\":\"Secure multi-party computation (MPC) allows multiple parties to securely evaluate a public function on their private inputs. The field has steadily moved forward and real-world applications have become practical. However, MPC implementations are often hand-built and require cryptographic knowledge. Thus, special compilers like HyCC (B√ºscher et al., CCS'18) have been developed, which automatically compile high-level programs to combinations of Boolean and arithmetic circuits required for mixed-protocol (hybrid) MPC. In this work, we explore the advantages of extending MPC compilers with an intermediate representation (IR) as commonly used in modern compiler infrastructures. For this, we extend HyCC with a graph-based IR that facilitates the implementation of well-known algorithms from compiler design as well as further MPC-specific optimizations. We demonstrate the benefits by implementing arithmetic decomposition based on our new IR that automatically extracts arithmetic expressions and then compiles them into separate circuits. For a line intersection algorithm, we require 40% less run-time and improve total communication by a factor of 3x compared to regular HyCC when securely evaluating the corresponding circuit with the hybrid MPC framework ABY (Demmler et al., NDSS'15).\",\"date\":\"2021-04-23\",\"url\":\"https://eprint.iacr.org/2021/521\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:34.851Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"demmler@informatik.uni-hamburg.de\",\"stefan.katzenbeisser@uni-passau.de\",\"schneider@encrypto.cs.tu-darmstadt.de\",\"schuster@encrypto.cs.tu-darmstadt.de\",\"weinert@encrypto.cs.tu-darmstadt.de\"],\"favorite\":false},{\"id\":1755287797970.4465,\"title\":\"LogStack: Stacked Garbling with\",\"authors\":\"log, Computation, David Heath and Vladimir Kolesnikov\",\"abstract\":\"Secure two party computation (2PC) of arbitrary programs can be efficiently achieved using garbled circuits (GC). Until recently, it was widely believed that a GC proportional to the entire program, including parts of the program that are entirely discarded due to conditional branching, must be transmitted over a network. Recent work shows that this belief is false, and that communication proportional only to the longest program execution path suffices (Heath and Kolesnikov, CRYPTO 20, [HK20a]). Although this recent work reduces needed communication, it increases computation. For a conditional with ùëè branches, the players use ùëÇ ( ùëè 2 ) computation (traditional GC uses only ùëÇ ( ùëè ) ). Our scheme LogStack reduces stacked garbling computation from ùëÇ ( ùëè 2 ) to ùëÇ ( ùëè log ‚Å° ùëè ) with no increase in communication over [HK20a]. The cause of [HK20a]'s increased computation is the oblivious collection of garbage labels that emerge during the evaluation of inactive branches. Garbage is collected by a multiplexer that is costly to generate. At a high level, we redesign stacking and garbage collection to avoid quadratic scaling. Our construction is also more space efficient: [HK20a] algorithms require ùëÇ ( ùëè ) space, while ours use only ùëÇ ( log ‚Å° ùëè ) space. This space efficiency allows even modest setups to handle large numbers of branches. [HK20a] assumes a random oracle (RO). We track the source of this need, formalize a simple and natural added assumption on the base garbling scheme, and remove reliance on RO: LogStack is secure in the standard model. Nevertheless, LogStack can be instantiated with typical GC tricks based on non-standard assumptions, such as free XOR and half-gates, and hence can be implemented with high efficiency. We implemented LogStack (in the RO model, based on half-gates garbling) and report performance. In terms of wall-clock time and for fewer than 16 branches, our performance is comparable to [HK20a]'s; for larger branching factors, our approach clearly outperforms [HK20a]. For example, given 1024 branches, our approach is 31 √ó faster.\",\"date\":\"2021-04-23\",\"url\":\"https://eprint.iacr.org/2021/531\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:37.970Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"heath.davidanthony@gatech.edu\",\"kolesnikov@gatech.edu\"],\"favorite\":false},{\"id\":1755287801033.1272,\"title\":\"CryptGPU: Fast Privacy-Preserving Machine Learning on the GPU\",\"authors\":\"Sijun Tan (Brian Knott, Yuan Tian, and David J. Wu)\",\"abstract\":\"We introduce CryptGPU, a system for privacy-preserving machine learning that implements all operations on the GPU (graphics processing unit). Just as GPUs played a pivotal role in the success of modern deep learning, they are also essential for realizing scalable privacy-preserving deep learning. In this work, we start by introducing a new interface to losslessly embed cryptographic operations over secret-shared values (in a discrete domain) into floating-point operations that can be processed by highly-optimized CUDA kernels for linear algebra. We then identify a sequence of \\\"GPU-friendly\\\" cryptographic protocols to enable privacy-preserving evaluation of both linear and non-linear operations on the GPU. Our microbenchmarks indicate that our private GPU-based convolution protocol is over 150x faster than the analogous CPU-based protocol; for non-linear operations like the ReLU activation function, our GPU-based protocol is around 10x faster than its CPU analog. With CryptGPU, we support private inference and private training on convolutional neural networks with over 60 million parameters as well as handle large datasets like ImageNet. Compared to the previous state-of-the-art, when considering large models and datasets, our protocols achieve a 2x to 8x improvement in private inference and a 6x to 36x improvement for private training. Our work not only showcases the viability of performing secure multiparty computation (MPC) entirely on the GPU to enable fast privacy-preserving machine learning, but also highlights the importance of designing new MPC primitives that can take full advantage of the GPU's computing capabilities.\",\"date\":\"2021-04-23\",\"url\":\"https://eprint.iacr.org/2021/533\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:41.033Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"st8eu@virginia.edu\",\"brianknott@fb.com\",\"yuant@virginia.edu\",\"dwu4@virginia.edu\"],\"favorite\":false},{\"id\":1755287804692.336,\"title\":\"Secure Computation by Secret Sharing Using Input Encrypted with Random Number (Full Paper)\",\"authors\":\"Keiichi Iwamura and Ahmad Akmal Aminuddin Mohd Kamal\",\"abstract\":\"Typically, unconditionally secure computation using a (k,n) threshold secret sharing scheme is considered impossible when n<2k-1. Therefore, in our previous work, we first took the approach of finding the conditions required for secure computation under the setting of n<2k-1 and showed that secure computation using a secret sharing scheme can be realized with a semi-honest adversary under the following three preconditions: (1) the result of secure computation does not include 0; (2) random numbers reconstructed by each server are fixed; and (3) each server holds random numbers unknown to the adversary and holds shares of random numbers that make up the random numbers unknown to the adversary. In this paper, we show that by leaving condition (3), secure computation with information-theoretic security against a semi-honest adversary is possible with k&#8804;n<2k-1. In addition, we clarify the advantage of using secret information that has been encrypted with a random number as input to secure computation. One of the advantages is the acceleration of the computation time. Namely, we divide the computation process into a preprocessing phase and an online phase and shift the cost of communication to the preprocessing phase. Thus, for computations such as inner product operations, we realize a faster online phase, compared with conventional methods.\",\"date\":\"2021-04-27\",\"url\":\"https://eprint.iacr.org/2021/548\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:44.692Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"ahmad@sec.ee.kagu.tus.ac.jp\",\"iwamura@ee.kagu.tus.ac.jp\"],\"favorite\":false},{\"id\":1755287807710.2861,\"title\":\"Prio+: Privacy Preserving Aggregate Statistics via Boolean Shares\",\"authors\":\"Surya Addanki, Kevin Garbe, Eli Jaffe, Rafail Ostrovsky, Antigoni Polychroniadou\",\"abstract\":\"This paper introduces Prio+, a privacy-preserving system for the collection of aggregate statistics, with the same model and goals in mind as the original and highly influential Prio paper by Henry Corrigan-Gibbs and Dan Boneh (USENIX 2017).  As in the original Prio, each client holds  a  private  data  value  (e.g.   number  of  visits  to  a  particular  website)  and  a  small  set  of servers  privately  compute  statistical  functions  over  the  set  of  client  values  (e.g.   the  average number  of  visits).   To  achieve  security  against  faulty  or  malicious  clients,  Prio+  clients  use Boolean secret-sharing instead of zero-knowledge proofs to convince servers that their data is of the correct form and Prio+ servers execute a share conversion protocols as needed in order to properly compute over client data.  This allows us to ensure that clients‚Äô data is properly formatted essentially for free, and the work shifts to novel share-conversion protocols between servers, where some care is needed to make it efficient.  While our overall approach is a fairly simple observation in retrospect, it turns out that Prio+ strategy reduces the client‚Äôs computational burden by up to two orders of magnitude (or more depending on the statistic) while keeping servers costs comparable to Prio.  Prio+ permits computation of exactly the same wide range of complex statistics as the original Prio protocol, including high-dimensional linear regression over private values held by clients. We report detailed benchmarks of our Prio+ implementation and compare these to both the original Go implementation of Prio and the Mozilla implementation of Prio.  Our Prio+ software is open-source and released with the same license as Prio. Note: Fixed minor typos, mostly references to edaBit-based protocol removed during previous edits. Also updated to reflect the paper's publication at SCN 2022.\",\"date\":\"2021-05-03\",\"url\":\"https://eprint.iacr.org/2021/576\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:47.710Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"jaffe.eli96@gmail.com\"],\"favorite\":false},{\"id\":1755287810939.0117,\"title\":\"PrORAM: Fast\",\"authors\":\"log, Private Coin ZK ORAM, David Heath and Vladimir Kolesnikov\",\"abstract\":\"We construct a concretely efficient Zero Knowledge (ZK) Oblivious RAM (ORAM) that consumes 2 log ‚Å° ùëõ oblivious transfers (OTs) of length- 2 ùúé secrets per access of an arithmetic value, for statistical security parameter ùúé and array size ùëõ . This is an asymptotic and concrete improvement over previous best (concretely efficient) ZK ORAM Bub- bleRAM of Heath and Kolesnikov ([HK20a], CCS 2020), whose access cost is 1 / 2 log 2 ‚Å° ùëõ OTs of length- 2 ùúé secrets. ZK ORAM is essential for proving statements that are best expressed as RAM programs, rather than Boolean or arithmetic circuits. Our construction is private-coin ZK. We integrate it with [HK20a]‚Äôs ZK Proof (ZKP) protocol and prove the resulting ZKP system secure. We implemented PrORAM in C++. Compared to the state-of-the-art BubbleRAM, our PrORAM is 10 √ó faster for arrays of size 2 20 of 40 -bit values.\",\"date\":\"2021-05-10\",\"url\":\"https://eprint.iacr.org/2021/587\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:50.939Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"heath.davidanthony@gatech.edu\",\"kolesnikov@gatech.edu\"],\"favorite\":false},{\"id\":1755287814044.9275,\"title\":\"A Novel Proof of Shuffle: Exponentially Secure Cut-and-Choose\",\"authors\":\"Thomas Haines and Johannes Mueller\",\"abstract\":\"Shuffling is one of the most important techniques for privacy-preserving protocols. Its applications are manifold, including, for example, e-voting, anonymous broadcast, or privacy-preserving machine-learning. For many applications, such as secure e-voting, it is crucial that the correctness of the shuffling operation be (publicly) verifiable. To this end, numerous proofs of shuffle have been proposed in the literature. Several of these proofs are actually employed in the real world. In this work, we propose a generic compiler which can transform any \\\"shuffle-compatible\\\" Sigma-protocol (including, among others, Sigma-protocols for re-randomization, decryption, or key shifting) into a Sigma-protocol for permutations of the underlying relation. The resulting proof of shuffle is black-box, easily implementable, simple to explain, and comes with an acceptable computational overhead over the state-of-the-art. Because we machine-checked our compiler in Coq, the new proof of shuffle is particularly suitable for applications that require a superior level of security assurance (e.g., high-stake elections).\",\"date\":\"2021-05-10\",\"url\":\"https://eprint.iacr.org/2021/588\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:54.044Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"thomas.haines@ntnu.no\"],\"favorite\":false},{\"id\":1755287817140.6355,\"title\":\"Differentially Oblivious Database Joins: Overcoming the Worst-Case Curse of Fully Oblivious Algorithms\",\"authors\":\"Shumo Chu (Danyang Zhuo, Elaine Shi, and T-H. Hubert Chan)\",\"abstract\":\"Numerous high-profile works have shown that access patterns to even encrypted databases can leak secret information and sometimes even lead to reconstruction of the entire database. To thwart access pattern leakage, the literature has focused on {\\\\it oblivious} algorithms, where obliviousness requires that the access patterns leak nothing about the input data. In this paper, we consider the {\\\\tt Join} operator, an important database primitive that has been extensively studied and optimized. Unfortunately, any {\\\\it fully oblivious} {\\\\tt Join} algorithm would require {\\\\it always} padding the result to the {\\\\it worst-case} length which is {\\\\it quadratic} in the data size ùëÅ . In comparison, an insecure baseline incurs only ùëÇ ( ùëÖ + ùëÅ ) cost where ùëÖ is the true result length, and in the common case in practice, ùëÖ is relatively short. As a typical example, when ùëÖ = ùëÇ ( ùëÅ ) , any fully oblivious algorithm must inherently incur a prohibitive, ùëÅ -fold slowdown relative to the insecure baseline. Indeed, the (non-private) database and algorithms literature invariably focuses on studying the {\\\\it instance-specific} rather than {\\\\it worst-case} performance of database algorithms. Unfortunately, the stringent notion of full obliviousness precludes the design of efficient algorithms with non-trivial instance-specific performance. To overcome this worst-case performance barrier of full obliviousness and enable algorithms with good instance-specific performance, we consider a relaxed notion of access pattern privacy called -differential obliviousness (DO), originally proposed in the seminal work of Chan et al. (SODA'19). Rather than insisting that the access patterns leak no information whatsoever, the relaxed DO notion requires that the access patterns satisfy -differential privacy. We show that by adopting the relaxed DO notion, we can obtain efficient database {\\\\tt Join} mechanisms whose instance-specific performance {\\\\it approximately matches} the insecure baseline, while still offering a meaningful notion of privacy to individual users. Complementing our upper bound results, we also prove new lower bounds regarding the performance of any DO {\\\\tt Join} algorithm. Differential obliviousness (DO) is a new notion and is a relatively unexplored territory. Following the pioneering investigations by Chan et al. and others, our work is among the very first to formally explore how DO can help overcome the worst-case performance curse of full obliviousness; moreover, we motivate our work with database applications. Our work shows new evidence why DO might be a promising notion, and opens up several exciting future directions. Note: This is the online full version containing formal algorithm description and detailed proofs.\",\"date\":\"2021-05-10\",\"url\":\"https://eprint.iacr.org/2021/593\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:56:57.140Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"runting@gmail.com\"],\"favorite\":false},{\"id\":1755287820099.7454,\"title\":\"Masked Triples: Amortizing Multiplication Triples across Conditionals\",\"authors\":\"David Heath (Vladimir Kolesnikov, and Stanislav Peceny)\",\"abstract\":\"A classic approach to MPC uses preprocessed multiplication triples to evaluate arbitrary Boolean circuits. If the target circuit features conditional branching, e.g. as the result of a IF program statement, then triples are wasted: one triple is consumed per AND gate, even if the output of the gate is entirely discarded by the circuit's conditional behavior. In this work, we show that multiplication triples can be re-used across conditional branches. For a circuit with ùëè branches, each having ùëõ AND gates, we need only a total of ùëõ triples, rather than the typically required ùëè ‚ãÖ ùëõ . Because preprocessing triples is often the most expensive step in protocols that use them, this significantly improves performance. Prior work similarly amortized oblivious transfers across branches in the classic GMW protocol (Heath et al., Asiacrypt 2020, [HKP20]). In addition to demonstrating conditional improvements are possible for a different class of protocols, we also concretely improve over [HKP20]: their maximum improvement is bounded by the topology of the circuit. Our protocol yields improvement independent of topology: we need triples proportional to the size of the program's longest execution path, regardless of the structure of the program branches. We implemented our approach in C++. Our experiments show that we significantly improve over a naive protocol and over prior work: for a circuit with 16 branches and in terms of total communication, we improved over naive by 12 √ó and over [HKP20] by an average of 2.6 √ó . Our protocol is secure against the semi-honest corruption of ùëù ‚àí 1 parties.\",\"date\":\"2021-05-10\",\"url\":\"https://eprint.iacr.org/2021/604\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:57:00.099Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"heath.davidanthony@gatech.edu\",\"kolesnikov@gatech.edu\",\"stan.peceny@gatech.edu\"],\"favorite\":false},{\"id\":1755287823379.755,\"title\":\"Non-Interactive, Secure Verifiable Aggregation for Decentralized, Privacy-Preserving Learning\",\"authors\":\"Carlo Brunetta (Georgia Tsaloli, Bei Liang, Gustavo Banegas, and Aikaterini Mitrokotsa)\",\"abstract\":\"We propose a novel primitive called NIVA that allows the distributed aggregation of multiple users' secret inputs by multiple untrusted servers. The returned aggregation result can be publicly verified in a non-interactive way, i.e. the users are not required to participate in the aggregation except for providing their secret inputs. NIVA allows the secure computation of the sum of a large amount of users' data and can be employed, for example, in the federated learning setting in order to aggregate the model updates for a deep neural network. We implement NIVA and evaluate its communication and execution performance and compare it with the current state-of-the-art, i.e. Segal et al. protocol (CCS 2017) and Xu et al. VerifyNet protocol (IEEE TIFS 2020), resulting in better user's communicated data and Note: Code publicly released.\",\"date\":\"2021-05-20\",\"url\":\"https://eprint.iacr.org/2021/654\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:57:03.379Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"brunetta@chalmers.se\"],\"favorite\":false},{\"id\":1755287826522.1675,\"title\":\"Tight Setup Bounds for Identifiable Abort\",\"authors\":\"Nicholas Brandt\",\"abstract\":\"We present fundamental (in-)feasibility results for the strongest security notion for Secure Multi-Party Computation (MPC) that is achievable when a majority of parties is malicious, i.e. security with Identifiable Abort. As general Universally Composable (UC) MPC requires a setup, typically in the form of a Common Reference String or Common-Randomness, we investigate whether the setup must provide randomness to all parties. Given broadcast, we give tight bounds for the necessary and sufficient setup cardinality, i.e. number of participating parties, for UC-MPC protocols with Identifiable Abort. Concretely, we improve previous upper bounds by constructing Secure Function Evaluation for ùëõ parties ( ‚Ñé of which are honest) from setups of cardinality ùõΩ := min ( ùëõ , ‚åä ùëõ / ‚Ñé ‚åã + ‚åä ( ùëõ ‚àí 1 ) / ‚Ñé ‚åã ‚àí 1 ) and broadcast. Conversely, we present the first general lower bound on the minimal setup cardinality for Identifiable Abort by proving that setups of cardinality ùõΩ ‚àí 1 plus broadcast are insufficient even for a commitment among ùëõ parties. Somewhat surprisingly, we show that Oblivious Transfer plus broadcast is sufficient for ùëõ = 2 ‚Ñé ‚â• 2 which is consistent with the fact that in two-party MPC Identifiable Abort comes for free. We present the results in the Universal Composibility (UC) framework and assume the setup functionalities to be secure with Identifiable Abort. Our constructions yield an efficient (poly-time) protocol for any ùëõ ‚àà poly ( ùúÜ ) where ùúÜ is the security parameter if at least a constant fraction ‚Ñé ‚àà Œò ( ùëõ ) of parties is honest. However for ‚Ñé ‚àà o ( ùëõ ) our results suggest that for efficient protocols the overall number of parties ùëõ is limited quite severely by ( ùëõ ùõΩ ) ‚àà poly ( ùúÜ ) .\",\"date\":\"2021-05-28\",\"url\":\"https://eprint.iacr.org/2021/684\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:57:06.522Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"nicholas.brandt@inf.ethz.ch\"],\"favorite\":false},{\"id\":1755287828702.091,\"title\":\"On Communication Models and Best-Achievable Security in Two-Round MPC\",\"authors\":\"Aarushi Goel (Abhishek Jain, Manoj Prabhakaran, and Rajeev Raghunath)\",\"abstract\":\"Recently, a sequence of works have made strong advances in two-round (i.e., round-optimal) secure multi-party computation (MPC). In the honest-majority setting -- the focus of this work -- Ananth et al. [CRYPTO'18, EC'19], Applebaum et al. [TCC'18, EC'19] and Garg et al. [TCC'18] have established the feasibility of general two-round MPC in standard communication models involving broadcast (BC) and private point-to-point (P2P) channels. In this work, we set out to understand what features of the communication model are necessary for these results, and more broadly the design of two-round MPC. Focusing our study on the plain model -- the most natural model for honest-majority MPC -- we obtain the following results: 1. Dishonest majority from Honest majority: In the two round setting, honest-majority MPC and dishonest-majority MPC are surprisingly close, and often equivalent. This follows from our results that the former implies 2-message oblivious transfer, in many settings. (i) We show that without private point-to-point (P2P) channels, i.e., when we use only broadcast (BC) channels,  honest-majority MPC implies 2-message oblivious transfer. (ii) Furthermore, this implication holds even when we use both P2P and BC, provided that the MPC protocol is robust against ``fail-stop'' adversaries. 2.  Best-Achievable Security: While security with guaranteed output delivery (and even fairness) against malicious adversaries is impossible in two rounds, nothing is known with regards to the ``next best'' security notion, namely, security with identifiable abort (IA). We show that IA is also impossible to achieve with honest-majority even if we use both P2P and BC channels. However, if we replace P2P channels with a ``bare'' (i.e., untrusted) public-key infrastructure (PKI), then even security with guaranteed output delivery (and hence IA) is possible to achieve. These results ``explain'' that the reliance on P2P channels (together with BC) in the recent two-round protocols in the plain model was in fact necessary, and that these protocols couldn't have achieved a stronger security guarantee, namely, IA. Overall, our results (put together with prior works) fully determine the best-achievable security for honest-majority MPC in different communication models in two rounds. As a consequence, they yield the following hierarchy of communication models: BC < P2P < BC+P2P < BC+PKI This shows that BC channel is the weakest communication model, and that BC+PKI model is strictly stronger than BC+PTP model.\",\"date\":\"2021-05-28\",\"url\":\"https://eprint.iacr.org/2021/690\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:57:08.702Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"aarushig@cs.jhu.edu\",\"abhishek@cs.jhu.edu\",\"mp@cse.iitb.ac.in\",\"mrrajeev@cse.iitb.ac.in\"],\"favorite\":false},{\"id\":1755287831781.0679,\"title\":\"SoK: Privacy-Preserving Computing in the Blockchain Era\",\"authors\":\"Ghada Almashaqbeh and Ravital Solomon\",\"abstract\":\"Privacy is a huge concern for cryptocurrencies and blockchains as most of these systems log everything in the clear. This has resulted in several academic and industrial initiatives to address privacy. Starting with the UTXO model of Bitcoin, initial works brought confidentiality and anonymity to payments. Recent works have expanded to support more generalized forms of private computation. Such solutions tend to be highly involved as they rely on advanced cryptographic primitives and creative techniques to handle issues related to dealing with private records (e.g. concurrency and double spending). This situation makes it hard to comprehend the current state-of-the-art, much less build on top of it. To address these challenges, we develop a systematization of knowledge for privacy-preserving solutions in blockchain. To the best of our knowledge, our work is the first of its kind. After motivating design challenges, we devise two systematization frameworks---the first as a stepping stone to the second---and use them to study the state-of-the-art. For our first framework, we study the zero-knowledge proof systems used in surveyed solutions, based on their key features and limitations. Our second is for blockchain privacy-preserving solutions; we define several dimensions to categorize the surveyed schemes and, in doing so, identify two major paradigms employed to achieve private computation. We go on to provide insights to guide solutions' adoption and development. Finally, we touch upon challenges related to limited functionality, practicality, and accommodating new developments.\",\"date\":\"2021-06-02\",\"url\":\"https://eprint.iacr.org/2021/727\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:57:11.781Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"ghada@uconn.edu\",\"ravital@sunscreen.tech\"],\"favorite\":false},{\"id\":1755287834091.706,\"title\":\"Laconic Private Set Intersection and Applications\",\"authors\":\"Navid Alamati (Pedro Branco, Nico D√∂ttling, Sanjam Garg, Mohammad Hajiabadi, and Sihang Pu)\",\"abstract\":\"Consider a server with a large set ùëÜ of strings { ùë• 1 , ùë• 2 , ‚Ä¶ , ùë• ùëÅ } that would like to publish a small hash ‚Ñé of its set ùëÜ such that any client with a string ùë¶ can send the server a short message allowing it to learn ùë¶ if ùë¶ ‚àà ùëÜ and nothing otherwise. In this work, we study this problem of two-round private set intersection (PSI) with low (asymptotically optimal) communication cost, or what we call laconic private set intersection ( ‚Ñì PSI) and its extensions. This problem is inspired by the recent general frameworks for laconic cryptography [Cho et al. CRYPTO 2017, Quach et al. FOCS'18]. We start by showing the first feasibility result for realizing ‚Ñì PSI based on the CDH assumption, or LWE with polynomial noise-to-modulus ratio. However, these feasibility results use expensive non-black-box cryptographic techniques leading to significant inefficiency. Next, with the goal of avoiding these inefficient techniques, we give a construction of ‚Ñì PSI schemes making only black-box use of cryptographic functions. Our construction is secure against semi-honest receivers, malicious senders and reusable in the sense that the receiver's message can be reused across any number of executions of the protocol. The scheme is secure under the ùúô -hiding, decisional composite residuosity and subgroup decision assumptions. Finally, we show natural applications of ‚Ñì PSI to realizing a semantically-secure encryption scheme that supports detection of encrypted messages belonging to a set of ``illegal'' messages (e.g., an illegal video) circulating online. Over the past few years, significant effort has gone into realizing laconic cryptographic protocols. Nonetheless, our work provides the first black-box constructions of such protocols for a natural application setting.\",\"date\":\"2021-06-02\",\"url\":\"https://eprint.iacr.org/2021/728\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:57:14.091Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"pmbranco@math.tecnico.ulisboa.pt\",\"alamati@gmail.com\",\"nico.doettling@gmail.com\",\"sanjamg@berkeley.edu\",\"mdhajiabadi@uwaterloo.ca\",\"push.beni@gmail.com\"],\"favorite\":false},{\"id\":1755287837239.258,\"title\":\"GenoPPML ‚Äì a framework for genomic privacy-preserving machine learning\",\"authors\":\"Sergiu Carpov (Nicolas Gama, Mariya Georgieva, and Dimitar Jetchev)\",\"abstract\":\"We present a framework GenoPPML for privacy-preserving machine learning in the context of sensitive genomic data processing. The technology combines secure multiparty computation techniques based on the recently proposed Manticore secure multiparty computation framework for model training and fully homomorphic encryption based on TFHE for model inference. The framework was successfully used to solve breast cancer prediction problems on gene expression datasets coming from distinct private sources while preserving their privacy - the solution winning 1st place for both Tracks I and III of the genomic privacy competition iDASH'2020. Extensive benchmarks and comparisons to existing works are performed. Our 2-party logistic regression computation is 11 √ó faster than the one in De Cock et al. on the same dataset and it uses only a single CPU core.\",\"date\":\"2021-06-03\",\"url\":\"https://eprint.iacr.org/2021/733\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:57:17.239Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"sergiu@inpher.io\",\"nicolas@inpher.io\",\"mariya@inpher.io\",\"dimitar@inpher.io\"],\"favorite\":false},{\"id\":1755287906292.4402,\"title\":\"Adam in Private: Secure and Fast Training of Deep Neural Networks with Adaptive Moment Estimation\",\"authors\":\"Nuttapong Attrapadung (Koki Hamada, Dai Ikarashi, Ryo Kikuchi, Takahiro Matsuda, Ibuki Mishina, Hiraku Morita, and Jacob C. N. Schuldt)\",\"abstract\":\"Machine Learning (ML) algorithms, especially deep neural networks (DNN), have proven themselves to be extremely useful tools for data analysis, and are increasingly being deployed in systems operating on sensitive data, such as recommendation systems, banking fraud detection, and healthcare systems. This underscores the need for privacy-preserving ML (PPML) systems, and has inspired a line of research into how such systems can be constructed efficiently. We contribute to this line of research by proposing a framework that allows efficient and secure evaluation of full-fledged state-of-the-art ML algorithms via secure multi-party computation (MPC). This is in contrast to most prior works on PPML, which require advanced ML algorithms to be substituted with approximated variants that are ``MPC-friendly'', before MPC techniques are applied to obtain a PPML algorithm. A drawback of the latter approach is that it requires careful fine-tuning of the combined ML and MPC algorithms, and might lead to less efficient algorithms or inferior quality ML (such as lower prediction accuracy). This is an issue for secure training of DNNs in particular, as this involves several arithmetic algorithms that are thought to be ``MPC-unfriendly'', namely, integer division, exponentiation, inversion, and square root extraction. In this work, we propose secure and efficient protocols for the above seemingly MPC-unfriendly computations (but which are essential to DNN). Our protocols are three-party protocols in the honest-majority setting, and we propose both passively secure and actively secure with abort variants. A notable feature of our protocols is that they simultaneously provide high accuracy and efficiency. This framework enables us to efficiently and securely compute modern ML algorithms such as Adam (Adaptive moment estimation) and the softmax function ``as is'', without resorting to approximations. As a result, we obtain secure DNN training that outperforms state-of-the-art three-party systems; our \\\\textit{full} training is up to times faster than just the \\\\textit{online} phase of the recently proposed FALCON (Wagh et al. at PETS'21) on the standard benchmark network for secure training of DNNs. To further demonstrate the scalability of our protocols, we perform measurements on real-world DNNs, AlexNet and VGG16, which are complex networks containing millions of parameters. The performance of our framework for these networks is up to a factor of about faster for AlexNet and faster for VGG16 to achieve an accuracy of and , respectively, when compared to FALCON.\",\"date\":\"2021-06-03\",\"url\":\"https://eprint.iacr.org/2021/736\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:58:26.292Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"kikuchi_ryo@fw.ipsj.or.jp\"],\"favorite\":false},{\"id\":1755287908799.437,\"title\":\"A New Approach to Garbled Circuits\",\"authors\":\"Anasuya Acharya (Bar-Ilan University), Tomer Ashur (imec-COSIC, KU Leuven), Efrat Cohen (Bar-Ilan University), Carmit Hazay (Bar-Ilan University), Avishay Yanai (VMware Research)\",\"abstract\":\"A garbling scheme is a fundamental cryptographic building block with a long list of applications. The study of different techniques for garbling a function, towards optimizing computation and communication complexity, has been an area of active research. Most common garbling techniques work by representing each gate in the circuit as a set of ciphertexts that encrypt its truth table row-by-row. In this work we present a new garbling scheme in the random oracle (RO) model that garbles circuits in the gate-by-gate paradigm by capturing the gate functionality (AND, XOR) as a whole rather than as a set of ciphertexts. The final gate garbling requires 4 ùúÖ bits of communication in expectation, 4 RO calls for garbling and 1 RO call for evaluation. We prove that the scheme satisfies privacy in the non-programmable random oracle model and against PPT adversaries. We also show how this scheme can be extended to support free-XOR and garble any gate functionality over binary inputs.\",\"date\":\"2021-06-03\",\"url\":\"https://eprint.iacr.org/2021/739\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:58:28.799Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"acharya@biu.ac.il\",\"tomer.ashur@esat.kuleuven.be\",\"efrat.choen@biu.ac.il\",\"carmit.hazay@biu.ac.il\",\"yanaia@vmware.com\"],\"favorite\":false},{\"id\":1755287911743.1384,\"title\":\"A Complete Characterization of Game-Theoretically Fair, Multi-Party Coin Toss\",\"authors\":\"Ke Wu (Gilad Asharov, and Elaine Shi)\",\"abstract\":\"Cleve‚Äôs celebrated lower bound (STOC‚Äô86) showed that a de facto strong fairness notion is impossible in 2-party coin toss, i.e., the corrupt party always has a strategy of biasing the honest party‚Äôs outcome by a noticeable  amount. Nonetheless, Blum‚Äôs famous coin-tossing protocol(CRYPTO‚Äô81) achieves a strictly weaker ‚Äúgame-theoretic‚Äù notion of fairness ‚Äî specifically, it is a 2-party coin toss protocol in which neither party can bias the outcome towards its own preference; and thus the honest protocol forms a Nash equilibrium in which neither party would want to deviate. Surprisingly, an n-party analog of Blum‚Äôs famous coin toss protocol was not studied till recently. The elegant work by Chung et al. was the first to explore the feasibility of game-theoretically fair n-party coin toss in the presence of corrupt majority. We may assume that each party has a publicly stated preference for either the bit 0 or 1, and if the outcome agrees with the party‚Äôs preference, it obtains utility 1; else it obtains nothing.A natural game-theoretic formulation is to require that the honest protocol form a coalition-resistant Nash equilibrium, i.e., no coalition should have incentive to deviate from the honest behavior. Chung et al.  phrased this game-theoretic notion as ‚Äúcooperative-strategy-proofness‚Äùor ‚ÄúCSP-fairness‚Äù for short. Unfortunately, Chung et al. showed that under (n-1)-sized coalitions, it is impossible to design such a CSP-fair coin toss protocol, unless all parties except one prefer the same bit.In this paper, we show that the impossibility of Chung et al. is in fact not as broad as it may seem. When coalitions are majority but not n-1 in size, we can indeed get feasibility results in some meaningful parameter regimes. We give a complete characterization of the regime in whichCSP-fair coin toss is possible, by providing a matching upper- and lower-bound. Our complete characterization theorem also shows that the mathematical structure of game-theoretic fairness is starkly different from the de facto strong fairness notion in the multi-party computation literature.\",\"date\":\"2021-06-07\",\"url\":\"https://eprint.iacr.org/2021/748\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:58:31.743Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"kew2@andrew.cmu.edu\"],\"favorite\":false},{\"id\":1755287915100.812,\"title\":\"Three Halves Make a Whole? Beating the Half-Gates Lower Bound for Garbled Circuits\",\"authors\":\"Mike Rosulek and Lawrence Roy\",\"abstract\":\"We describe a garbling scheme for boolean circuits, in which XOR gates are free and AND gates require communication of 1.5 ùúÖ + 5 bits. This improves over the state-of-the-art \\\"half-gates\\\" scheme of Zahur, Rosulek, and Evans (Eurocrypt 2015), in which XOR gates are free and AND gates cost 2 ùúÖ bits. The half-gates paper proved a lower bound of 2 ùúÖ bits per AND gate, in a model that captured all known garbling techniques at the time. We bypass this lower bound with a novel technique that we call slicing and dicing, which involves slicing wire labels in half and operating separately on those halves. Ours is the first to bypass the lower bound while being fully compatible with free-XOR, making it a drop-in replacement for half-gates. Our construction is proven secure from a similar assumption to prior free-XOR garbling (circular correlation-robust hash), and uses only slightly more computation than half-gates.\",\"date\":\"2021-06-07\",\"url\":\"https://eprint.iacr.org/2021/749\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:58:35.100Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"rosulekm@oregonstate.edu\",\"ldr709@gmail.com\"],\"favorite\":false},{\"id\":1755287918232.986,\"title\":\"Privacy-Preserving Training of Tree Ensembles over Continuous Data\",\"authors\":\"Samuel Adams (Chaitali Choudhary, Martine De Cock, Rafael Dowsley, David Melanson, Anderson C. A. Nascimento, Davis Railsback, and Jianwei Shen)\",\"abstract\":\"Most existing Secure Multi-Party Computation (MPC) protocols for privacy-preserving training of decision trees over distributed data assume that the features are categorical. In real-life applications, features are often numerical. The standard ``in the clear'' algorithm to grow decision trees on data with continuous values requires sorting of training examples for each feature in the quest for an optimal cut-point in the range of feature values in each node. Sorting is an expensive operation in MPC, hence finding secure protocols that avoid such an expensive step is a relevant problem in privacy-preserving machine learning. In this paper we propose three more efficient alternatives for secure training of decision tree based models on data with continuous features, namely: (1) secure discretization of the data, followed by secure training of a decision tree over the discretized data; (2) secure discretization of the data, followed by secure training of a random forest over the discretized data; and (3) secure training of extremely randomized trees (``extra-trees'') on the original data. Approaches (2) and (3) both involve randomizing feature choices. In addition, in approach (3) cut-points are chosen randomly as well, thereby alleviating the need to sort or to discretize the data up front. We implemented all proposed solutions in the semi-honest  setting with additive secret sharing based MPC. In addition to mathematically proving that all proposed approaches are correct and secure, we experimentally evaluated and compared them in terms of classification accuracy and runtime. We privately train tree ensembles over data sets with 1000s of instances or features in a few minutes, with accuracies that are at par with those obtained in the clear. This makes our solution orders of magnitude more efficient than the existing approaches, which are based on oblivious sorting.\",\"date\":\"2021-06-07\",\"url\":\"https://eprint.iacr.org/2021/754\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:58:38.232Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"sdadams@uw.edu\",\"cc201@uw.edu\",\"mdecock@uw.edu\",\"rafael.dowsley@monash.edu\",\"mence40@uw.edu\",\"andclay@uw.edu\",\"drail@uw.edu\",\"sjwjames@email.arizona.edu\"],\"favorite\":false},{\"id\":1755287921330.1123,\"title\":\"Tetrad: Actively Secure 4PC for Secure Training and Inference\",\"authors\":\"Nishat Koti (Arpita Patra, Rahul Rachuri, and Ajith Suresh)\",\"abstract\":\"Mixing arithmetic and boolean circuits to perform privacy-preserving machine learning has become increasingly popular. Towards this, we propose a framework for the case of four parties with at most one active corruption called Tetrad. Tetrad works over rings and supports two levels of security, fairness and robustness. The fair multiplication protocol costs 5 ring elements, improving over the state-of-the-art Trident (Chaudhari et al. NDSS'20). A key feature of Tetrad is that robustness comes for free over fair protocols. Other highlights across the two variants include (a) probabilistic truncation without overhead, (b) multi-input multiplication protocols, and (c) conversion protocols to switch between the computational domains, along with a tailor-made garbled circuit approach. Benchmarking of Tetrad for both training and inference is conducted over deep neural networks such as LeNet and VGG16. We found that Tetrad is up to 4 times faster in ML training and up to 5 times faster in ML inference. Tetrad is also lightweight in terms of deployment cost, costing up to 6 times less than Trident. Note: This article is the full and extended version of an article to appear in the Network and Distributed System Security Symposium (NDSS) 2022.\",\"date\":\"2021-06-07\",\"url\":\"https://eprint.iacr.org/2021/755\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:58:41.331Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"kotis@iisc.ac.in\",\"arpita@iisc.ac.in\",\"rachuri@cs.au.dk\",\"ajith@iisc.ac.in\"],\"favorite\":false},{\"id\":1755287924161.9688,\"title\":\"Cerebro: A Platform for Multi-Party Cryptographic Collaborative Learning\",\"authors\":\"Wenting Zheng (Ryan Deng, Weikeng Chen, Raluca Ada Popa, Aurojit Panda, and Ion Stoica)\",\"abstract\":\"Many organizations need large amounts of high-quality data for their applications, and one way to acquire such data is to combine datasets from multiple parties. Since these organizations often own sensitive data that cannot be shared in the clear with others due to policy regulation and business competition, there is increased interest in utilizing secure multi-party computation (MPC). MPC allows multiple parties to jointly compute a function without revealing their inputs to each other. We present Cerebro, an end-to-end collaborative learning platform that enables parties to compute learning tasks without sharing plaintext data. By taking an end-to-end approach to the system design, Cerebro allows multiple parties with complex economic relationships to safely collaborate on machine learning computation through the use of release policies and auditing, while also enabling users to achieve good performance without manually navigating the complex performance tradeoffs between MPC protocols.\",\"date\":\"2021-06-07\",\"url\":\"https://eprint.iacr.org/2021/759\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:58:44.161Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"wzheng2@andrew.cmu.edu\",\"rdeng2614@berkeley.edu\",\"w.k@berkeley.edu\"],\"favorite\":false},{\"id\":1755287927197.8088,\"title\":\"Privacy-Preserving Decision Trees Training and Prediction\",\"authors\":\"Adi Akavia (Max Leibovich, Yehezkel S. Resheff, Roey Ron, Moni Shahar, and Margarita Vald)\",\"abstract\":\"In the era of cloud computing and machine learning, data has become a highly valuable resource. Recent history has shown that the benefits brought forth by this data driven culture come at a cost of potential data leakage. Such breaches have a devastating impact on individuals and industry, and lead the community to seek privacy preserving solutions. A promising approach is to utilize Fully Homomorphic Encryption (FHE) to enable machine learning over encrypted data, thus providing resiliency against information leakage. However, computing over encrypted data incurs a high computational overhead, thus requiring the redesign of algorithms, in an ``FHE-friendly\\\" manner, to maintain their practicality. In this work we focus on the ever-popular tree based methods (e.g., boosting, random forests), and propose a new privacy-preserving solution to training and prediction for trees. Our solution employs a low-degree approximation for the step-function together with a lightweight interactive protocol, to replace components of the vanilla algorithm that are costly over encrypted data. Our protocols for decision trees achieve practical usability demonstrated on standard UCI datasets encrypted with fully homomorphic encryption. In addition, the communication complexity of our protocols is independent of the tree size and dataset size in prediction and training, respectively, which significantly improves on prior works.\",\"date\":\"2021-06-09\",\"url\":\"https://eprint.iacr.org/2021/768\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T19:58:47.197Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"adi.akavia@gmail.com\",\"margarita.vald@cs.tau.ac.il\"],\"favorite\":false},{\"id\":1755288184656.9636,\"title\":\"Privacy-Preserving Machine Learning with Fully Homomorphic Encryption for Deep Neural Network\",\"authors\":\"Joon-Woo Lee (HyungChul Kang, Yongwoo Lee, Woosuk Choi, Jieun Eom, Maxim Deryabin, Eunsang Lee, Junghyun Lee, Donghoon Yoo, Young-Sik Kim, and Jong-Seon No)\",\"abstract\":\"Fully homomorphic encryption (FHE) is one of the prospective tools for privacy-preserving machine learning (PPML), and several PPML models have been proposed based on various FHE schemes and approaches. Although the FHE schemes are known as suitable tools to implement PPML models, previous PPML models on FHE such as CryptoNet, SEALion, and CryptoDL are limited to only simple and non-standard types of machine learning models. These non-standard machine learning models are not proven efficient and accurate with more practical and advanced datasets. Previous PPML schemes replace non-arithmetic activation functions with simple arithmetic functions instead of adopting approximation methods and do not use bootstrapping, which enables continuous homomorphic evaluations. Thus, they could not use standard activation functions and could not employ a large number of layers. In this work, we firstly implement the standard ResNet-20 model with the RNS-CKKS FHE with bootstrapping and verify the implemented model with the CIFAR-10 dataset and the plaintext model parameters. Instead of replacing the non-arithmetic functions with the simple arithmetic function, we use state-of-the-art approximation methods to evaluate these non-arithmetic functions, such as the ReLU and softmax, with sufficient precision. Further, for the first time, we use the bootstrapping technique of the RNS-CKKS scheme in the proposed model, which enables us to evaluate an arbitrary deep learning model on the encrypted data. We numerically verify that the proposed model with the CIFAR-10 dataset shows 98.43% identical results to the original ResNet-20 model with non-encrypted data. The classification accuracy of the proposed model is 92.43%¬±2.65%, which is pretty close to that of the original ResNet-20 CNN model, 91.89%. It takes about 3 hours for inference on a dual Intel Xeon Platinum 8280 CPU (112 cores) with 172 GB memory. We think that it opens the possibility of applying the FHE to the advanced deep PPML model.\",\"date\":\"2021-06-10\",\"url\":\"https://eprint.iacr.org/2021/783\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T20:03:04.656Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"joonwoo3511@ccl.snu.ac.kr\",\"hc1803.kang@samsung.com\",\"yw0803.lee@samsung.com\",\"woosuk0.choi@samsung.com\",\"jieun.eom@samsung.com\",\"max.deriabin@samsung.com\",\"eslee3209@ccl.snu.ac.kr\",\"jhlee@ccl.snu.ac.kr\",\"say.yoo@samsung.com\",\"iamyskim@chosun.ac.kr\",\"jsno@snu.ac.kr\"],\"favorite\":false},{\"id\":1755288187655.274,\"title\":\"Transforming Secure Comparison Protocol from Passive to Active Adversary Model\",\"authors\":\"Wei Jiang\",\"abstract\":\"Secure comparison (SC) is an essential primitive in Secure Multiparty Computation (SMC) and a fundamental building block in Privacy-Preserving Data Analytics. Although secure comparison has been studied since the introduction of SMC in the early 80s and many protocols have been proposed, there is still room for improvement, especially providing security against malicious adversaries who form the majority among the participating parties. It is not hard to develop an SC protocol secure against malicious majority based on the current state of the art SPDZ framework. SPDZ is design to work for arbitrary polynomially-bounded functionalities, and it may not provide the most efficient SMC implementation for a specific task, such as SC. In this paper, we propose a novel compiler that is specifically designed to convert most existing SC protocols with semi-honest security into the ones secure against the malicious majority. This compiler provides a flexible and efficient way to achieve both covert and active security for passively secure SC protocols.\",\"date\":\"2021-06-14\",\"url\":\"https://eprint.iacr.org/2021/795\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T20:03:07.655Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"wjiang@missouri.edu\"],\"favorite\":false},{\"id\":1755288189855.6333,\"title\":\"LLVM-based Circuit Compilation for Practical Secure Computation\",\"authors\":\"Tim Heldmann (Thomas Schneider, Oleksandr Tkachenko, Christian Weinert, and Hossein Yalame)\",\"abstract\":\"Multi-party computation (MPC) allows two or more parties to jointly and securely compute functions over private inputs. Cryptographic protocols that realize MPC require functions to be expressed as Boolean or arithmetic circuits. Deriving such circuits is either done manually, or with hardware synthesis tools and specialized MPC compilers. Unfortunately, such existing tools compile only from a single front-end language and neglect decades of research for optimizing regular compilers. In this paper, we make MPC practical for developers by automating circuit compilation based on the compiler toolchain LLVM. For this, we develop an LLVM optimizer suite consisting of multiple transform passes that operate on the LLVM intermediate representation (IR) and gradually lower functions to circuit level. Our approach supports various front-end languages (currently C, C++, and Fortran) and takes advantage of powerful source code optimizations built into LLVM. We furthermore make sure to produce circuits that are optimized for MPC, and even offer fully automated post-processing for efficient post-quantum MPC. We empirically measure the quality of our compilation results and compare them to the state-of-the-art specialized MPC compiler HyCC (B√ºscher et al., CCS'2018). For all benchmarked HyCC example applications (e.g., biomatch and linear equation solving), our highly generalizable approach achieves similar quality in terms of gate count and composition.\",\"date\":\"2021-06-14\",\"url\":\"https://eprint.iacr.org/2021/797\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T20:03:09.855Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"schneider@encrypto.cs.tu-darmstadt.de\",\"tkachenko@encrypto.cs.tu-darmstadt.de\",\"weinert@encrypto.cs.tu-darmstadt.de\",\"yalame@encrypto.cs.tu-darmstadt.de\"],\"favorite\":false},{\"id\":1755288193107.0713,\"title\":\"On the Privacy of Protocols based on CPA-Secure Homomorphic Encryption\",\"authors\":\"Adi Akavia and Margarita Vald\",\"abstract\":\"Li and Micciancio (Eurocrypt 2021) shattered a widespread misconception regarding the security of protocols based on cpa-secure homomorphic encryption (HE). They showed an attack breaking security of HE-based protocols provided that the protocol employs an HE scheme for approximate numbers, like CKKS, and the adversary sees decrypted ciphertexts. However, their attack fails when employing exact HE schemes, like BGV, or denying access to decrypted data. We show that the Li-Micciancio attack is only the tip of the iceberg: 1)We exhibit an input-recovery attack completely breaking the privacy of a wide and natural family of HE-based protocols, including protocols using only exact HE-schemes and with an adversary exposed solely to encrypted data. This proves that cpa-security is insufficient to ensure privacy in a much broader context than previously known. 2)To address the threat exhibited by our attack we introduce sufficient conditions, on either the encryption scheme or the protocol, that do guarantee privacy: (a) Every HE scheme with a sanitization algorithm (e.g., BGV and FHEW) can be transformed into a ``sanitized\\\" scheme so that protocols instantiated with it preserve privacy against malicious adversaries. (b) Moreover, we characterize a natural sub-family of these protocols for which cpa-security does suffice to guarantee privacy, albeit against semi-honest adversaries. To prove (2a) we define a notion of circuit-privacy+ that lies between semi-honest and malicious circuit-privacy and realize it from existing schemes; this may be of independent interest. Note: version change: added details to the bibliography list.\",\"date\":\"2021-06-14\",\"url\":\"https://eprint.iacr.org/2021/803\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T20:03:13.107Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"adi.akavia@gmail.com\",\"margarita.vald@cs.tau.ac.il\"],\"favorite\":false},{\"id\":1755288196312.619,\"title\":\"SoK: Efficient Privacy-preserving Clustering\",\"authors\":\"Aditya Hegde (Helen M√∂llering, Thomas Schneider, and Hossein Yalame)\",\"abstract\":\"Clustering is a popular unsupervised machine learning technique that groups similar input elements into clusters. It is used in many areas ranging from business analysis to health care. In many of these applications, sensitive information is clustered that should not be leaked. Moreover, nowadays it is often required to combine data from multiple sources to increase the quality of the analysis as well as to outsource complex computation to powerful cloud servers. This calls for efficient privacy-preserving clustering. In this work, we systematically analyze the state-of-the-art in privacy-preserving clustering. We implement and benchmark today's four most efficient fully private clustering protocols by Cheon et al. (SAC'19), Meng et al. (ArXiv'19), Mohassel et al. (PETS'20), and Bozdemir et al. (ASIACCS'21) with respect to communication, computation, and clustering quality. We compare them, assess their limitations for a practical use in real-world applications, and conclude with open challenges.\",\"date\":\"2021-06-16\",\"url\":\"https://eprint.iacr.org/2021/809\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T20:03:16.312Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"moellering@encrypto.cs.tu-darmstadt.de\"],\"favorite\":false},{\"id\":1755288199239.5952,\"title\":\"GPU-accelerated PIR with Client-Independent Preprocessing for Large-Scale Applications\",\"authors\":\"Daniel G√ºnther (TU Darmstadt), Maurice Heymann (TU Darmstadt), Benny Pinkas (Bar-Ilan University), Thomas Schneider (TU Darmstadt)\",\"abstract\":\"Multi-Server Private Information Retrieval (PIR) is a cryptographic protocol that allows a client to securely query a database entry from ùëõ ‚â• 2 servers of which less than ùë° can collude, s.t. the servers learn no information about the query. Highly efficient PIR could be used for large-scale applications like Compromised Credential Checking (C3) (USENIX Security'19), which allows users to check whether their credentials have been leaked in a data breach. However, state-of-the art PIR schemes are not efficient enough for fast online responses at this scale. In this work, we introduce Client-Independent Preprocessing (CIP) PIR that moves ( ùë° ‚àí 1 ) / ùëõ of the online computation to a local, client independent, preprocessing phase suitable for efficient batch precomputations. The online performance of CIP-PIR improves linearly with the number of servers ùëõ . We show that large-scale applications like C3 with PIR are practical by implementing our CIP-PIR scheme using a parallelized CPU implementation. To the best of our knowledge, this is the first multi-server PIR scheme whose preprocessing phase is completely independent of the client, and where online performance simultaneously improves with the number of servers ùëõ . In addition, we accelerate for the first time the huge amount of XOR operations in multi-server PIR with GPUs. Our GPU-based CIP-PIR achieves an improvement up to factor 2.1 √ó over our CPU-based implementation for ùëõ = 2 servers, and enables a client to query an entry in a 25 GB database within less than 1 second.\",\"date\":\"2021-06-16\",\"url\":\"https://eprint.iacr.org/2021/823\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T20:03:19.239Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"guenther@encrypto.cs.tu-darmstadt.de\",\"sapp@hotmail.de\",\"benny@pinkas.net\",\"schneider@encrypto.cs.tu-darmstadt.de\"],\"favorite\":false},{\"id\":1755288202268.5713,\"title\":\"Balancing Quality and Efficiency in Private Clustering with Affinity Propagation\",\"authors\":\"Hannah Keller (Helen M√∂llering, Thomas Schneider, and Hossein Yalame)\",\"abstract\":\"In many machine learning applications, training data consists of sensitive information from multiple sources. Privacy-preserving machine learning using secure computation enables multiple parties to compute on their joint data without disclosing their inputs to each other. In this work, we focus on clustering, an unsupervised machine learning technique that partitions data into groups. Previous works on privacy-preserving clustering often leak information and focus on the k-means algorithm, which provides only limited clustering quality and flexibility. Additionally, the number of clusters k must be known in advance. We analyze several prominent clustering algorithms' capabilities and their compatibility with secure computation techniques to create an efficient, fully privacy-preserving clustering implementation superior to k-means. We find affinity propagation to be the most promising candidate and securely implement it using various multi-party computation techniques. Privacy-preserving affinity propagation does not require any input parameters and consists of operations hat are relatively efficient with secure computation. As threat models, we consider passive security as well as active security with an honest and dishonest majority. We offer the first comparison of privacy-preserving clustering between these scenarios, enabling an understanding of the exact trade-offs between them. Based on the clustering quality and the computational and communication costs, privacy-preserving affinity propagation offers a good trade-off between quality and efficiency for practical privacy-preserving clustering.\",\"date\":\"2021-06-16\",\"url\":\"https://eprint.iacr.org/2021/825\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T20:03:22.268Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"hannah.keller@stud.tu-darmstadt.de\",\"moellering@encrypto.cs.tu-darmstadt.de\",\"schneider@encrypto.cs.tu-darmstadt.de\",\"yalame@encrypto.cs.tu-darmstadt.de\"],\"favorite\":false},{\"id\":1755288205108.3708,\"title\":\"Privacy-Preserving Approximate k-Nearest-Neighbors Search that Hides Access, Query and Volume Patterns\",\"authors\":\"Alexandra Boldyreva and Tianxin Tang\",\"abstract\":\"We study the problem of privacy-preserving approximate kNN search in an outsourced environment ‚Äî the client sends the encrypted data to an untrusted server and later can perform secure approximate kNN search and updates. We design a security model and propose a generic construction based on locality-sensitive hashing, symmetric encryption, and an oblivious map. The construction provides very strong security guarantees, not only hiding the information about the data, but also the access, query, and volume patterns. We implement, evaluate efficiency, and compare the performance of two concrete schemes based on an oblivious AVL tree and an oblivious BSkiplist.\",\"date\":\"2021-06-16\",\"url\":\"https://eprint.iacr.org/2021/816\",\"labelSets\":[],\"previousWorks\":[],\"addedDate\":\"2025-08-15T20:03:25.108Z\",\"folder\":\"\",\"readingStatus\":\"referenced\",\"isPlaceholder\":false,\"scratchpad\":\"\",\"contactEmails\":[\"sasha@gatech.edu\",\"ttang@gatech.edu\"],\"favorite\":false}]",
    "cryptoFolders": "[{\"id\":1755106045920.1526,\"name\":\"HSS\",\"parent\":\"\",\"created\":\"2025-08-13T17:27:25.920Z\"},{\"id\":1755243856920.8557,\"name\":\"Foundational Papers\",\"parent\":\"\",\"created\":\"2025-08-15T07:44:16.920Z\"},{\"id\":1755243865166.8943,\"name\":\"PCG\",\"parent\":\"\",\"created\":\"2025-08-15T07:44:25.166Z\"}]",
    "obelisc-wiki-data": "{\"projectDescription\":\"<p>Privacy-preserving communication has become the norm over large-scale networks: around 85% of Internet traffic is now encrypted. However, our use of these networks is also evolving rapidly. The modern user searches through pictures stored in the Cloud, gets video recommendations, sees targeted advertising, and uses healthcare and social apps. In each of these situations, a third party is performing computations on our private data (our pictures, navigation history, preferences, etc.). This creates a fundamental tension between utility and privacy.</p>\\n\\n<div class=\\\"central-vision\\\">\\n  <div class=\\\"vision-content\\\">\\n    <h4><i class=\\\"fas fa-bullseye\\\"></i> Central Vision</h4>\\n    <p><p>The ultimate goal of OBELiSC is to enable the construction of networks where privacy is guaranteed by default, even when private data is used in computations involving third parties.</p></p>\\n  </div>\\n</div>\\n\\n<p><strong>Secure computation</strong> addresses this challenge by enabling multiple participants to distributively execute computations on their sensitive data without compromising confidentiality. Our approach draws inspiration from the success of secure communication protocols, which already protect the vast majority of web communications through technologies like TLS.</p>\\n\\n<p>Just as secure communication achieved widespread adoption through key architectural features, OBELiSC focuses on developing secure computation protocols that <strong>mimic the core features of secure communication networks</strong>:</p>\\n\\n<ul class=\\\"feature-list\\\">\\n<li><strong>Two-phase structure:</strong> A heavy preprocessing phase followed by lightweight online computation</li>\\n<li><strong>Non-interactive protocols:</strong> Parties can participate without being simultaneously online</li>\\n<li><strong>Minimal communication overhead:</strong> Efficient bandwidth usage comparable to insecure alternatives</li>\\n<li><strong>Diverse security foundations:</strong> Multiple cryptographic assumptions for robust security</li>\\n</ul>\\n\\n<p>By achieving these landmark features, OBELiSC aims to make secure computation practical for deployment over large-scale networks, ultimately realizing a world where privacy-by-default becomes the standard over the Internet.</p>\",\"members\":[{\"id\":1755963668660,\"firstName\":\"Geoffroy\",\"lastName\":\"Couteau\",\"startDate\":\"2023-09-01\",\"endDate\":\"\",\"website\":\"https://geoffroycouteau.github.io/\",\"role\":\"PI\"},{\"firstName\":\"Sihang\",\"lastName\":\"Pu\",\"startDate\":\"2024-09-01\",\"endDate\":\"2025-07-31\",\"website\":\"https://sihangpu.uk/\",\"id\":1756052731126,\"role\":\"postdoc\"},{\"firstName\":\"Lennart\",\"lastName\":\"Braun\",\"startDate\":\"2025-01-01\",\"endDate\":\"\",\"website\":\"https://github.com/lenerd\",\"id\":1756052778939,\"role\":\"postdoc\"},{\"firstName\":\"Nikolas\",\"lastName\":\"Melissaris\",\"startDate\":\"2025-03-01\",\"endDate\":\"\",\"website\":\"https://nikolasmelissaris.github.io/\",\"id\":1756052808458,\"role\":\"postdoc\"},{\"firstName\":\"Ioanna\",\"lastName\":\"Karantaidou\",\"startDate\":\"2025-01-01\",\"endDate\":\"\",\"website\":\"https://www.ioannakarantaidou.com/\",\"id\":1756052975649,\"role\":\"postdoc\"},{\"firstName\":\"Kaartik\",\"lastName\":\"Bhushan\",\"startDate\":\"2025-06-01\",\"endDate\":\"\",\"website\":\"https://homepages.iitb.ac.in/~kbhushan/\",\"id\":1756053038439,\"role\":\"postdoc\"},{\"firstName\":\"Ulysse\",\"lastName\":\"L√©chine\",\"startDate\":\"2025-01-01\",\"endDate\":\"\",\"website\":\"\",\"id\":1756053056047,\"role\":\"postdoc\"},{\"firstName\":\"Alexander\",\"lastName\":\"Koch\",\"startDate\":\"2024-09-24\",\"endDate\":\"2025-02-28\",\"website\":\"https://alex-koch.gitlab.io/\",\"id\":1756053170623,\"role\":\"postdoc\"},{\"firstName\":\"Christoph\",\"lastName\":\"Egger\",\"startDate\":\"2024-09-24\",\"endDate\":\"2024-10-31\",\"website\":\"https://christoph-egger.org/\",\"id\":1756053221613,\"role\":\"postdoc\"}],\"publications\":[{\"title\":\"Fast Pseudorandom Correlation Functions from Sparse LPN\",\"authors\":\"Lennart Braun, Geoffroy Couteau, Kelsey Melissaris, Mahshid Riahinia, Elahe Sadeghi\",\"venue\":\"ASIACRYPT 2025\",\"workPackages\":[\"rg1-unbounded\"],\"description\":\"\",\"id\":1756341621407},{\"title\":\"SoK: On Shallow Weak PRFs\",\"authors\":\"Christina Boura, Geoffroy Couteau, L√©o Perrin, Yann Rotella\",\"venue\":\"ToSC 2025\",\"workPackages\":[\"rg1-unbounded\"],\"description\":\"The purpose of this SoK is to gather attention from the symetric cryptanalysis community on some weak pseudorandom function candidates that are, in particular, at the heart of recent developments in pseudorandom correlation functions.\",\"id\":1756340876987},{\"id\":1755987627972,\"title\":\"Instantiating the Hash-Then-Evaluate Paradigm: Strengthening PRFs, PCFs, and OPRFs\",\"authors\":\"Chris Brzuska, Geoffroy Couteau, Christoph Egger, and Pierre Meyer\",\"venue\":\"Cryptography and Communications 2025\",\"workPackage\":\"\",\"description\":\"\",\"workPackages\":[\"rg1-unbounded\"]},{\"id\":1755987627973,\"title\":\"Structured-Seed Local Pseudorandom Generators and their Applications\",\"authors\":\"Benny Applebaum, Dung Bui, Geoffroy Couteau and Nikolas Melissaris\",\"venue\":\"RANDOM 2025\",\"workPackage\":\"\",\"description\":\"This work introduces structured-seed local PRGs, a relaxation of local PRGs that enjoys two benefits: it can replace local PRGs in most of their applications, and it can be based on (many flavors of) the sparse LPN assumption, a well-studied assumption not known to imply local PRGs. This work is complexity-theoretic in nature and has applications ranging from indistinguishability obfuscation to learning theory. It has, however, one application directly related to the project: combined with previous works, it shows that 5-party sublinear secure computation exists from DCR + LPN + sparse-LPN (previous works required local PRGs instead of sparse-LPN), extending the set of assumptions known to imply 5-party sublinear MPC.\",\"workPackages\":[\"rg3-multiparty\"]},{\"id\":1755987627974,\"title\":\"Downlink (T)FHE ciphertexts compression\",\"authors\":\"Antonina Bondarchuk, Olive Chakraborty, Geoffroy Couteau, and Renaud Sirdey\",\"venue\":\"SAC 2025\",\"workPackage\":\"\",\"description\":\"\"},{\"id\":1755987627975,\"title\":\"œâ(1/Œª)-Rate Boolean Garbling Scheme from Generic Groups\",\"authors\":\"Geoffroy Couteau, Carmit Hazay, Aditya Hegde, and Naman Kumar\",\"venue\":\"CRYPTO 2025\",\"workPackage\":\"\",\"description\":\"\"},{\"id\":1755987627976,\"title\":\"Multi-key Homomorphic Secret Sharing\",\"authors\":\"Geoffroy Couteau, Lalita Devadas, Aditya Hegde, Abhishek Jain, and Sacha Servan-Schreiber\",\"venue\":\"EUROCRYPT 2025\",\"workPackage\":\"\",\"description\":\"\",\"workPackages\":[\"rg1-unbounded\",\"rg2-nisp\"]},{\"id\":1755987627977,\"title\":\"Breaking the 1/Œª-Rate Barrier for Arithmetic Garbling\",\"authors\":\"Geoffroy Couteau, Carmit Hazay, Aditya Hegde, and Naman Kumar\",\"venue\":\"EUROCRYPT 2025\",\"workPackage\":\"\",\"description\":\"\"},{\"id\":1755987627978,\"title\":\"Enhanced Trapdoor Hashing from DDH and DCR\",\"authors\":\"Geoffroy Couteau, Aditya Hegde, and Sihang Pu\",\"venue\":\"EUROCRYPT 2025\",\"workPackage\":\"\",\"description\":\"\",\"workPackages\":[\"rg1-specific\",\"rg2-nisp\"]},{\"id\":1755987627979,\"title\":\"An Efficient ZK Compiler from SIMD Circuits to General Circuits\",\"authors\":\"Dung Bui, Haotian Chu, Geoffroy Couteau, Xiao Wang, Chenkai Weng, Kang Yang, and Yu Yu\",\"venue\":\"JoC 2025\",\"workPackage\":\"rg2\",\"description\":\"\",\"workPackages\":[\"rg2-nizk\"]},{\"id\":1755987627980,\"title\":\"On Building Fine-Grained One-Way Functions from Strong Average-Case Hardness\",\"authors\":\"Chris Brzuska and Geoffroy Couteau\",\"venue\":\"JoC 2025\",\"workPackage\":\"\",\"description\":\"\"},{\"id\":1755987627981,\"title\":\"On Bounded Storage Key Agreement and One-Way Functions\",\"authors\":\"Chris Brzuska, Christoph Egger, Geoffroy Couteau, and Willy Quach\",\"venue\":\"TCC 2024\",\"workPackage\":\"\",\"description\":\"\"},{\"id\":1755987627982,\"title\":\"A Note on Low-Communication Secure Multiparty Computation via Circuit Depth-Reduction\",\"authors\":\"Pierre Charbit, Geoffroy Couteau, Pierre Meyer, and Reza Naserasr\",\"venue\":\"TCC 2024\",\"workPackage\":\"rg3\",\"description\":\"\",\"workPackages\":[\"rg3-multiparty\",\"rg3-general\",\"rg3-barriers\"]},{\"title\":\"FOLEAGE: F4-OLE-Based Multi-Party Computation for Boolean Circuits\",\"authors\":\"Maxime Bombar, Dung Bui, Geoffroy Couteau, Alain Couvreur, Cl√©ment Ducros, Sacha Servan-Schreiber\",\"venue\":\"ASIACRYPT 2024\",\"workPackages\":[\"rg1-ole\"],\"description\":\"\",\"id\":1756103682197},{\"title\":\"QuietOT: Lightweight Oblivious Transfer with a Public-Key Setup\",\"authors\":\"Geoffroy Couteau, Lalita Devadas, Srinivasan Devadas, Alexander Koch, Sacha Servan-Schreiber\",\"venue\":\"ASIACRYPT 2024\",\"workPackages\":[\"rg1-unbounded\",\"rg2-nisp\"],\"description\":\"\",\"id\":1756103757721},{\"title\":\"Faster Signatures from MPC-in-the-Head\",\"authors\":\"Dung Bui, Eliana Carozza, Geoffroy Couteau, Dahmun Goudarzi, Antoine Joux\",\"venue\":\"ASIACRYPT 2024\",\"workPackages\":[\"rg2-nizk\"],\"description\":\"\",\"id\":1756103792449},{\"title\":\"Instantiating the Hash-Then-Evaluate Paradigm: Strengthening PRFs, PCFs, and OPRFs\",\"authors\":\"Chris Brzuska, Geoffroy Couteau, Christoph Egger, Pierre Meyer\",\"venue\":\"SCN 2024\",\"workPackages\":[\"rg1-unbounded\"],\"description\":\"\",\"id\":1756103899617}],\"progress\":{\"rg1-specific\":20,\"rg1-ole\":50,\"rg1-unbounded\":9,\"rg1-multiparty\":25,\"rg2-nisp\":30,\"rg2-nizk\":80,\"rg2-foundations\":65,\"rg3-multiparty\":45,\"rg3-general\":55,\"rg3-barriers\":20},\"researchGoals\":{\"rg1\":{\"title\":\"RG1: Efficiency and Scalability of Silent Preprocessing\",\"subtitle\":\"Research Goal 1\",\"description\":\"Silent preprocessing allows to generate correlated (pseudo)randomness tailored to specific computations, achieving unprecedented efficiency in secure computation protocols.\",\"workPackages\":[{\"title\":\"Silent preprocessing for specific functions\",\"id\":\"rg1-specific\",\"questions\":[\"Can we construct concretely efficient silent preprocessing protocols for correlations tailored to useful functions, such as set operations, comparisons, or functions occurring in statistical analysis, medical research, and recommendation systems?\"],\"description\":\"One can be more fine-grained by looking at specific functionalities. For concrete functionalities, better efficiency can be achieved by choosing a tailored type of correlated randomness.\"},{\"title\":\"Silent preprocessing for oblivious linear evaluation correlations\",\"id\":\"rg1-ole\",\"questions\":[\"Can we construct silent preprocessing protocols for OLE correlations with linear computational overhead?\",\"Can we construct silent preprocessing protocols for OLE correlations over small fields? Can it be done over the smallest possible field, F‚ÇÇ?\",\"Can we construct silent preprocessing for OLE correlations using better-understood assumptions, such as standard code-based assumptions?\"],\"description\":\"Target general forms of correlated randomness and lift remaining barriers towards making them efficient, usable, and based on strong security foundations.\"},{\"title\":\"Unbounded, on-demand silent preprocessing\",\"id\":\"rg1-unbounded\",\"questions\":[\"Can we construct pseudorandom correlation functions with efficiency competitive with that of pseudorandom correlation generators?\",\"Can we base efficient pseudorandom correlation functions on more standard assumptions?\"],\"description\":\"Pseudorandom correlation functions circumvent the single-use limitation and provide on-demand, unbounded amount of correlated pseudorandomness.\"},{\"title\":\"Multiparty silent preprocessing\",\"id\":\"rg1-multiparty\",\"questions\":[\"Can we construct n-party silent preprocessing protocols with a cost scaling with n, for the most useful n-party correlations, such as Beaver triples?\"],\"description\":\"The most ambitious goal: obtain the first direct constructions of multiparty silent preprocessing protocols that scale linearly with the number of parties.\"}]},\"rg2\":{\"title\":\"RG2: Non-Interactive Secure Computation\",\"subtitle\":\"Research Goal 2\",\"description\":\"Achieve the non-interactive structure of secure communication protocols for secure computation, removing the need for parties to coordinate being online simultaneously.\",\"workPackages\":[{\"title\":\"Non-interactive silent preprocessing\",\"id\":\"rg2-nisp\",\"questions\":[\"Is it possible to construct non-interactive secure protocols for silent preprocessing with better concrete efficiency?\",\"Is it possible to construct non-interactive secure protocols for silent preprocessing for more general types of correlations?\"],\"description\":\"When constructing new silent preprocessing protocols, make them fully non-interactive to enable secure computation networks to scale.\"},{\"title\":\"Efficient non-interactive zero-knowledge proofs\",\"id\":\"rg2-nizk\",\"questions\":[\"Can we construct more efficient non-interactive zero-knowledge proofs for statements of interest in real-world applications, such as range proofs and membership proofs?\",\"Can we construct efficient post-quantum non-interactive zero-knowledge proofs for the above statements?\"],\"description\":\"Target concrete, real-world efficiency for zero-knowledge proofs, which are becoming widely used in mainstream products with ongoing standardization efforts.\"},{\"title\":\"Theoretical security foundations of NIZKs\",\"id\":\"rg2-foundations\",\"questions\":[\"Can we base the security of non-interactive zero-knowledge proofs on traditional hardness assumptions such as the decisional or computation Diffie-Hellman assumptions?\",\"Is public-key cryptography necessary for non-interactive zero-knowledge proofs? Can we construct NIZKs from assumptions not known to imply public-key cryptography?\"],\"description\":\"Relate the security of NIZKs to the most plausible and best-studied assumptions, answering fundamental questions about their necessity.\"}]},\"rg3\":{\"title\":\"RG3: Low Communication Secure Computation\",\"subtitle\":\"Research Goal 3\",\"description\":\"Investigate new approaches to achieve sublinear communication complexity in secure computation without relying on fully homomorphic encryption.\",\"workPackages\":[{\"title\":\"Multiparty low-communication protocols\",\"id\":\"rg3-multiparty\",\"questions\":[\"Can we achieve sublinear secure computation between 3 or more parties without fully homomorphic encryption?\"],\"description\":\"Large-scale secure computation should enjoy low communication for all participants, not just two-party functionalities.\"},{\"title\":\"General circuit support\",\"id\":\"rg3-general\",\"questions\":[\"Can we achieve sublinear secure computation for all polynomial-size circuits (rather than layered circuits) without fully homomorphic encryption?\"],\"description\":\"Move beyond the current limitation to structured/layered circuits to support arbitrary polynomial-size computations.\"},{\"title\":\"Breaking communication barriers\",\"id\":\"rg3-barriers\",\"questions\":[\"Can we break the O(s/log s) communication barrier for secure computation without fully homomorphic encryption?\",\"Can we break the O(s/log log s) communication barrier for secure computation with silent preprocessing?\"],\"description\":\"The most intriguing questions: can FHE-free approaches achieve better communication savings than current barriers?\"}]}},\"previousPublications\":[{\"title\":\"10-Party Sublinear Secure Computation from Standard Assumptions\",\"authors\":\"Geoffroy Couteau, Naman Kumar\",\"venue\":\"CRYPTO 2024\",\"workPackages\":[\"rg3-multiparty\"],\"description\":\"\",\"id\":1756159497276},{\"title\":\"Fast Public-Key Silent OT and More from Constrained Naor-Reingold\",\"authors\":\"Dung Bui, Geoffroy Couteau, Pierre Meyer, Alain Passel√®gue, Mahshid Riahinia\",\"venue\":\"EUROCRYPT 2024\",\"workPackages\":[\"rg1-unbounded\",\"rg2-nisp\"],\"description\":\"\",\"id\":1756159543262},{\"title\":\"Short Signatures from Regular Syndrome Decoding in the Head\",\"authors\":\"liana Carozza, Geoffroy Couteau, Antoine Joux\",\"venue\":\"EUROCRYPT 2023\",\"workPackages\":[\"rg2-nizk\"],\"description\":\"\",\"id\":1756341722368},{\"title\":\"A Note on Non-Interactive Zero-Knowledge from CDH\",\"authors\":\"Geoffroy Couteau, Abhishek Jain, Zhengzhong Jin, Willy Quach\",\"venue\":\"CRYPTO 2023\",\"workPackages\":[\"rg2-foundations\"],\"description\":\"\",\"id\":1756159654550},{\"title\":\"Correlated Pseudorandomness from the Hardness of Quasi-Abelian Decoding\",\"authors\":\"Maxime Bombar, Geoffroy Couteau, Alain Couvreur, Cl√©ment Ducros\",\"venue\":\"CRYPTO 2023\",\"workPackages\":[\"rg1-ole\"],\"description\":\"\",\"id\":1756159699955},{\"title\":\"Sublinear-Communication Secure Multiparty Computation does not require FHE\",\"authors\":\"Elette Boyle, Geoffroy Couteau, Pierre Meyer\",\"venue\":\"EUROCRYPT 2023\",\"workPackages\":[\"rg3-multiparty\"],\"description\":\"\",\"id\":1756159747235},{\"title\":\"Constrained Pseudorandom Functions from Homomorphic Secret Sharing\",\"authors\":\"Geoffroy Couteau, Pierre Meyer, Alain Passel√®gue, Mahshid Riahinia\",\"venue\":\"EUROCRYPT 2023\",\"workPackages\":[\"rg1-unbounded\"],\"description\":\"\",\"id\":1756159828102}],\"workPackageRemarks\":{}}",
    "cryptoPapersMetadata": "{\"count\":799,\"lastSaved\":\"2025-08-21T16:26:38.010Z\",\"folders\":[],\"version\":\"2.0\"}"
  },
  "sessionStorage": {
    "obelisc-current-page": "overview",
    "obelisc-admin-auth": "true"
  },
  "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36",
  "url": "file:///Users/geoffroy/Documents/Programs/wiki/obelisc.html"
}