<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>The Secure Computation Database</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                color: #333;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
                padding: 20px;
            }

            .header {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 16px;
                padding: 24px;
                margin-bottom: 24px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

            .header h1 {
                font-size: 2.5em;
                font-weight: 700;
                background: linear-gradient(135deg, #667eea, #764ba2);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 8px;
            }

            .header p {
                color: #666;
                font-size: 1.1em;
            }

            .main-content {
                display: grid;
                grid-template-columns: 1fr 2fr 300px;
                gap: 24px;
                margin-bottom: 24px;
            }

            .folders-panel {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 16px;
                padding: 24px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                height: fit-content;
            }

            .sidebar {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 16px;
                padding: 24px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                height: fit-content;
            }

            .content-area {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 16px;
                padding: 24px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

            .section-title {
                font-size: 1.4em;
                font-weight: 600;
                margin-bottom: 16px;
                color: #333;
            }

            .input-group {
                margin-bottom: 16px;
            }

            .input-group label {
                display: block;
                margin-bottom: 8px;
                font-weight: 500;
                color: #555;
            }

            .input-group input,
            .input-group select,
            .input-group textarea {
                width: 100%;
                padding: 12px;
                border: 2px solid #e1e5e9;
                border-radius: 8px;
                font-size: 14px;
                transition: border-color 0.3s ease;
                background: rgba(255, 255, 255, 0.9);
            }

            .input-group input:focus,
            .input-group select:focus,
            .input-group textarea:focus {
                outline: none;
                border-color: #667eea;
                box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
                background: rgba(255, 255, 255, 1);
            }

            .btn {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
                display: inline-flex;
                align-items: center;
                gap: 8px;
            }

            .btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            }

            .btn:active {
                transform: translateY(0);
            }

            .btn-secondary {
                background: linear-gradient(135deg, #6c757d, #495057);
            }

            .btn-secondary:hover {
                box-shadow: 0 8px 25px rgba(108, 117, 125, 0.3);
            }

            .search-controls {
                display: flex;
                gap: 12px;
                margin-bottom: 16px;
            }

            .label-selector {
                margin-bottom: 16px;
            }

            .label-category {
                margin-bottom: 16px;
            }

            .label-category h4 {
                font-size: 1.1em;
                font-weight: 600;
                color: #444;
                margin-bottom: 8px;
                padding: 8px;
                border-bottom: 1px solid #e1e5e9;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: space-between;
                background: rgba(248, 249, 250, 0.8);
                border-radius: 6px;
                transition: background-color 0.2s ease;
            }

            .label-category h4:hover {
                background: rgba(102, 126, 234, 0.1);
            }

            .label-category-arrow {
                font-size: 0.8em;
                transition: transform 0.2s ease;
            }

            .label-category-arrow.expanded {
                transform: rotate(90deg);
            }

            .label-options {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                line-height: 1.8;
                margin-top: 8px;
                transition: all 0.3s ease;
            }

            .label-options.collapsed {
                display: none;
            }

            .label-chip {
                background: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 20px;
                padding: 6px 12px;
                font-size: 12px;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .label-chip:hover {
                background: #e9ecef;
                transform: translateY(-1px);
            }

            .label-chip.selected {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                border-color: #667eea;
            }

            .label-chip.excluded {
                background: linear-gradient(135deg, #dc3545, #c82333);
                color: white;
                border-color: #dc3545;
            }

            .papers-list {
                max-height: 600px;
                overflow-y: auto;
                border: 1px solid #e1e5e9;
                border-radius: 8px;
                /* Performance optimizations for large lists */
                contain: layout style paint;
                will-change: scroll-position;
            }

            .virtual-scroll-container {
                position: relative;
                width: 100%;
            }

            .virtual-content {
                position: absolute;
                width: 100%;
                contain: layout style paint;
            }

            .paper-item {
                padding: 16px;
                border-bottom: 1px solid #e1e5e9;
                cursor: pointer;
                transition: background-color 0.3s ease;
                /* Performance optimizations */
                contain: layout style paint;
                transform: translateZ(0); /* Force GPU acceleration */
            }

            .paper-item:hover {
                background: rgba(102, 126, 234, 0.05);
            }

            .paper-item:last-child {
                border-bottom: none;
            }

            .paper-title {
                font-weight: 600;
                font-size: 1.1em;
                margin-bottom: 8px;
                color: #333;
                padding-right: 10px; /* Additional padding to prevent overlap */
                word-wrap: break-word;
            }

            .paper-authors {
                color: #666;
                font-size: 0.9em;
                margin-bottom: 8px;
            }

            .paper-date {
                color: #888;
                font-size: 0.8em;
                margin-bottom: 8px;
            }

            .paper-labels {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
            }

            .paper-label-sets {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 8px;
                line-height: 1.8;
            }

            .paper-label-set {
                margin-bottom: 8px;
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                align-items: center;
            }

            .paper-labels .label-chip {
                font-size: 10px;
                padding: 2px 6px;
                background: rgba(102, 126, 234, 0.1);
                border-color: rgba(102, 126, 234, 0.2);
            }

            .graph-container {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 16px;
                padding: 24px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                margin-bottom: 24px;
            }

            .graph-svg {
                width: 100%;
                height: 400px;
                border: 1px solid #e1e5e9;
                border-radius: 8px;
                background: white;
            }

            .tabs {
                display: flex;
                margin-bottom: 24px;
                border-bottom: 1px solid #e1e5e9;
            }

            .tab {
                background: none;
                border: none;
                padding: 12px 24px;
                cursor: pointer;
                color: #666;
                border-bottom: 2px solid transparent;
                transition: all 0.3s ease;
            }

            .tab.active {
                color: #667eea;
                border-bottom-color: #667eea;
            }

            .tab-content {
                display: none;
            }

            .tab-content.active {
                display: block;
            }

            .loading {
                text-align: center;
                color: #666;
                padding: 40px;
            }

            .error {
                background: linear-gradient(135deg, #dc3545, #c82333);
                color: white;
                padding: 12px;
                border-radius: 8px;
                margin-bottom: 16px;
            }

            .success {
                background: linear-gradient(135deg, #28a745, #20c997);
                color: white;
                padding: 12px;
                border-radius: 8px;
                margin-bottom: 16px;
            }

            .modal {
                display: none;
                position: fixed;
                z-index: 1000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(5px);
            }

            .modal-content {
                background: white;
                margin: 5% auto;
                padding: 24px;
                border-radius: 16px;
                width: 80%;
                max-width: 800px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            }

            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 24px;
                padding-bottom: 16px;
                border-bottom: 1px solid #e1e5e9;
            }

            .close {
                font-size: 28px;
                font-weight: bold;
                cursor: pointer;
                color: #666;
                transition: color 0.3s ease;
            }

            .close:hover {
                color: #333;
            }

            .modal-actions {
                display: flex;
                gap: 12px;
                justify-content: flex-end;
                margin-top: 24px;
                padding-top: 16px;
                border-top: 1px solid #e1e5e9;
            }

            .btn-danger {
                background: linear-gradient(135deg, #dc3545, #c82333);
            }

            .btn-danger:hover {
                box-shadow: 0 8px 25px rgba(220, 53, 69, 0.3);
            }

            .btn-success {
                background: linear-gradient(135deg, #28a745, #20c997);
            }

            .btn-success:hover {
                box-shadow: 0 8px 25px rgba(40, 167, 69, 0.3);
            }

            .message {
                padding: 12px;
                border-radius: 8px;
                margin-bottom: 16px;
                font-weight: 500;
            }

            .message.info {
                background: linear-gradient(135deg, #17a2b8, #138496);
                color: white;
            }

            .related-papers-section {
                border: 1px solid #e1e5e9;
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 16px;
                background: rgba(248, 249, 250, 0.5);
            }

            .related-papers-url-input {
                display: flex;
                gap: 8px;
                align-items: flex-end;
            }

            .related-papers-url-input input {
                flex: 1;
            }

            .related-papers-search {
                margin-bottom: 8px;
            }

            .related-papers-select {
                margin-bottom: 8px;
            }

            .selected-papers-display {
                min-height: 40px;
                border: 1px solid #e1e5e9;
                border-radius: 8px;
                padding: 8px;
                background: white;
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center;
            }

            .selected-paper-item {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .placeholder-paper {
                background: linear-gradient(135deg, #ffc107, #fd7e14);
                color: white;
            }

            .placeholder-indicator {
                font-size: 10px;
                opacity: 0.8;
            }

            .search-filter-display {
                background: rgba(102, 126, 234, 0.1);
                border: 1px solid rgba(102, 126, 234, 0.2);
                border-radius: 8px;
                padding: 8px;
                margin: 8px 0;
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center;
            }

            .search-filter-excluded {
                background: rgba(220, 53, 69, 0.1);
                border-color: rgba(220, 53, 69, 0.2);
            }

            .annotation-popup {
                position: absolute;
                background: white;
                border: 1px solid #ddd;
                border-radius: 8px;
                padding: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                min-width: 200px;
            }

            .label-sets-container {
                border: 1px solid #e1e5e9;
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 16px;
                background: rgba(248, 249, 250, 0.5);
            }

            .label-set {
                background: white;
                border: 1px solid #e1e5e9;
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 16px;
                position: relative;
            }

            .label-set-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 12px;
            }

            .label-set-name {
                font-weight: 600;
                color: #333;
            }

            .label-set-name input {
                border: none;
                background: transparent;
                font-weight: 600;
                color: #333;
                padding: 4px 8px;
                border-radius: 4px;
            }

            .label-set-name input:focus {
                background: #f8f9fa;
                outline: 1px solid #667eea;
            }

            .label-set-remove {
                background: linear-gradient(135deg, #dc3545, #c82333);
                color: white;
                border: none;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .label-set-remove:hover {
                transform: scale(1.05);
            }

            .add-label-set-btn {
                background: linear-gradient(135deg, #28a745, #20c997);
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
                display: inline-flex;
                align-items: center;
                gap: 8px;
                width: 100%;
                justify-content: center;
            }

            .add-label-set-btn:hover {
                transform: translateY(-2px);
            }

            .paper-label-sets {
                display: flex;
                flex-direction: column;
                gap: 12px;
                margin-top: 12px;
            }

            .paper-label-set {
                background: rgba(248, 249, 250, 0.8);
                border: 1px solid #e1e5e9;
                border-radius: 6px;
                padding: 8px;
            }

            .paper-label-set-name {
                font-weight: 600;
                color: #555;
                font-size: 0.9em;
                margin-bottom: 4px;
            }

            .folders-tree {
                margin-bottom: 16px;
            }

            .folder-item {
                display: flex;
                align-items: center;
                padding: 8px;
                margin: 2px 0;
                border-radius: 6px;
                cursor: pointer;
                transition: background-color 0.2s ease;
                position: relative;
            }

            .folder-item:hover {
                background-color: rgba(102, 126, 234, 0.1);
            }

            .folder-item.selected {
                background-color: rgba(102, 126, 234, 0.2);
                font-weight: 600;
            }

            .folder-item.root {
                font-weight: 600;
                color: #667eea;
            }

            .folder-indent {
                margin-left: 20px;
            }

            .folder-icon {
                margin-right: 8px;
                font-size: 14px;
            }

            .folder-name {
                flex: 1;
                font-size: 14px;
            }

            .folder-actions {
                display: none;
                gap: 4px;
            }

            .folder-item:hover .folder-actions {
                display: flex;
            }

            .folder-action-btn {
                background: none;
                border: none;
                padding: 2px 6px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                color: #666;
                transition: all 0.2s ease;
            }

            .folder-action-btn:hover {
                background-color: #f8f9fa;
                color: #333;
            }

            .add-folder-btn {
                background: linear-gradient(135deg, #28a745, #20c997);
                color: white;
                border: none;
                padding: 10px 16px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
                display: inline-flex;
                align-items: center;
                gap: 8px;
                width: 100%;
                justify-content: center;
            }

            .add-folder-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
            }

            .database-actions {
                margin-bottom: 16px;
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                justify-content: center;
            }

            .database-actions .btn {
                padding: 8px 12px;
                font-size: 13px;
            }

            .fetch-buttons {
                display: flex;
                gap: 8px;
                margin-bottom: 12px;
            }

            .fetch-buttons .btn {
                padding: 10px 16px;
                font-size: 13px;
                flex: 1;
            }

            .cors-fix-container {
                display: flex;
                justify-content: center;
                margin-bottom: 16px;
            }

            /* Scratchpad Modal Styles */
            .scratchpad-modal {
                width: 800px;
                max-height: 80vh;
            }

            .scratchpad-tabs {
                display: flex;
                border-bottom: 1px solid #e0e0e0;
                margin-bottom: 20px;
            }

            .scratchpad-tab {
                padding: 10px 20px;
                border: none;
                background: none;
                cursor: pointer;
                border-bottom: 2px solid transparent;
                font-weight: 500;
            }

            .scratchpad-tab.active {
                border-bottom-color: #667eea;
                color: #667eea;
            }

            .scratchpad-content {
                min-height: 400px;
                margin-bottom: 20px;
            }

            .scratchpad-tab-content {
                display: none;
                height: 400px;
            }

            .scratchpad-tab-content.active {
                display: block;
            }

            #scratchpad-textarea {
                width: 100%;
                height: 100%;
                border: 1px solid #ddd;
                border-radius: 8px;
                padding: 15px;
                font-family: "Monaco", "Consolas", monospace;
                font-size: 14px;
                line-height: 1.5;
                resize: none;
                outline: none;
            }

            #scratchpad-textarea:focus {
                border-color: #667eea;
                box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            }

            #scratchpad-preview-content {
                height: 100%;
                padding: 15px;
                border: 1px solid #ddd;
                border-radius: 8px;
                background: #fafafa;
                overflow-y: auto;
                font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                line-height: 1.6;
            }

            #scratchpad-preview-content h1,
            #scratchpad-preview-content h2,
            #scratchpad-preview-content h3 {
                margin-top: 0;
                margin-bottom: 16px;
                color: #333;
            }

            #scratchpad-preview-content p {
                margin-bottom: 12px;
            }

            #scratchpad-preview-content code {
                background: #f1f1f1;
                padding: 2px 6px;
                border-radius: 4px;
                font-family: "Monaco", "Consolas", monospace;
            }

            #scratchpad-preview-content pre {
                background: #f8f8f8;
                padding: 12px;
                border-radius: 6px;
                overflow-x: auto;
                margin-bottom: 12px;
            }

            #scratchpad-preview-content blockquote {
                border-left: 4px solid #667eea;
                padding-left: 16px;
                margin: 16px 0;
                color: #666;
                font-style: italic;
            }

            #scratchpad-preview-content ul,
            #scratchpad-preview-content ol {
                margin-bottom: 12px;
                padding-left: 24px;
            }

            /* Favorite Star Icon */
            .favorite-star-icon {
                position: absolute;
                top: 12px;
                right: 90px;
                width: 24px;
                height: 24px;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                opacity: 0.7;
                transition: all 0.2s;
                font-size: 16px;
                z-index: 2;
                color: #ffd700;
            }

            .favorite-star-icon:hover {
                opacity: 1;
                transform: scale(1.1);
            }

            .favorite-star-icon.favorited {
                opacity: 1;
                color: #ffd700;
            }

            /* Scratchpad Icon */
            .scratchpad-icon {
                position: absolute;
                top: 12px;
                right: 12px;
                width: 24px;
                height: 24px;
                background: #667eea;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                opacity: 0.8;
                transition: all 0.2s;
                font-size: 12px;
                color: white;
                z-index: 2;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            /* Reading Status Icon */
            .reading-status-icon {
                position: absolute;
                top: 12px;
                right: 42px;
                width: 24px;
                height: 24px;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                opacity: 0.8;
                transition: all 0.2s;
                font-size: 12px;
                color: white;
                z-index: 2;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            .reading-status-icon.to-read {
                background: #dc3545;
            }

            .reading-status-icon.skimmed {
                background: #ffc107;
                color: #333;
            }

            .reading-status-icon.reading {
                background: #17a2b8;
            }

            .reading-status-icon.read {
                background: #28a745;
            }

            .reading-status-icon.referenced {
                background: #6c757d;
            }

            /* Email Contact Icon */
            .email-contact-icon {
                position: absolute;
                top: 12px;
                right: 116px;
                width: 24px;
                height: 24px;
                background: #fd7e14;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                opacity: 0.8;
                transition: all 0.2s;
                font-size: 12px;
                color: white;
                z-index: 2;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            .scratchpad-icon.has-content {
                background: #28a745;
                box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
            }

            .scratchpad-icon.has-content::after {
                content: "●";
                position: absolute;
                top: -2px;
                right: -2px;
                width: 8px;
                height: 8px;
                background: #ffc107;
                border-radius: 50%;
                font-size: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .scratchpad-icon:hover,
            .reading-status-icon:hover,
            .email-contact-icon:hover {
                opacity: 1;
                transform: scale(1.1);
                box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
            }

            .paper-item {
                position: relative;
                padding-right: 120px; /* Make space for all icons */
            }

            /* Sorting Controls */
            .sorting-controls {
                display: flex;
                align-items: center;
                gap: 16px;
                margin-bottom: 16px;
            }

            .sorting-controls label {
                font-weight: 500;
                margin-right: 8px;
            }

            .sorting-controls select {
                padding: 6px 12px;
                border: 1px solid #ddd;
                border-radius: 6px;
                background: white;
            }

            .view-mode-controls {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .view-mode-btn {
                padding: 6px 12px;
                border: 1px solid #ddd;
                border-radius: 6px;
                background: white;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s;
            }

            .view-mode-btn:hover {
                background: #f5f5f5;
            }

            .view-mode-btn.active {
                background: #4a90e2;
                color: white;
                border-color: #4a90e2;
            }

            .paper-item.compact {
                padding: 12px 16px;
            }

            .paper-item.compact .paper-authors,
            .paper-item.compact .paper-date,
            .paper-item.compact .paper-label-sets,
            .paper-item.compact .favorite-star-icon,
            .paper-item.compact .scratchpad-icon,
            .paper-item.compact .reading-status-icon,
            .paper-item.compact .email-contact-icon {
                display: none;
            }

            .paper-item.expanded .paper-abstract {
                display: block;
                margin: 8px 0;
                color: #666;
                font-size: 14px;
                line-height: 1.4;
            }

            .paper-item.expanded .paper-url {
                display: block;
                margin-top: 8px;
            }

            .paper-item.expanded .paper-url a {
                color: #4a90e2;
                text-decoration: none;
                font-size: 14px;
            }

            .paper-item.expanded .paper-url a:hover {
                text-decoration: underline;
            }

            .paper-abstract {
                display: none;
            }

            .paper-url {
                display: none;
            }

            /* Advanced Search Styles */
            .advanced-search-help {
                background: rgba(240, 242, 247, 0.8);
                border: 1px solid #e1e5e9;
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 16px;
                font-size: 13px;
                line-height: 1.5;
            }

            .advanced-search-help strong {
                color: #333;
            }

            .help-icon {
                display: inline-block;
                width: 22px;
                height: 22px;
                background: #2563eb;
                color: white;
                border-radius: 50%;
                text-align: center;
                line-height: 22px;
                font-size: 13px;
                cursor: pointer;
                margin-left: 8px;
                font-weight: bold;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                transition: all 0.2s ease;
            }

            .help-icon:hover {
                background: #1d4ed8;
                transform: scale(1.05);
                box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
            }

            .help-popup {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border: 1px solid #ddd;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                z-index: 1001;
                max-width: 500px;
                max-height: 80vh;
                overflow-y: auto;
            }

            .help-popup-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
            }

            .help-popup h3 {
                margin-top: 0;
                color: #333;
            }

            .help-popup code {
                background: #f5f5f5;
                padding: 2px 4px;
                border-radius: 3px;
                font-family: monospace;
            }

            .collapsible-section-header {
                display: flex;
                align-items: center;
                cursor: pointer;
                margin-bottom: 12px;
                padding: 8px 0;
                border-bottom: 1px solid #e1e5e9;
            }

            .collapsible-section-header:hover {
                background: rgba(240, 242, 247, 0.3);
                border-radius: 6px;
                padding: 8px;
                margin: 0 -8px 12px -8px;
            }

            .collapsible-arrow {
                margin-right: 8px;
                transition: transform 0.2s ease;
                font-size: 12px;
                color: #666;
            }

            .collapsible-arrow.expanded {
                transform: rotate(90deg);
            }

            .collapsible-content {
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
            }

            .collapsible-content.expanded {
                max-height: 2000px;
            }

            .search-query-input {
                width: 100%;
                margin-bottom: 10px;
            }

            .graph-controls {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 15px;
                padding: 10px;
                background-color: #f8f9fa;
                border-radius: 6px;
                border: 1px solid #e1e5e9;
            }

            .graph-controls select {
                padding: 6px 12px;
                border: 1px solid #cbd5e0;
                border-radius: 4px;
                background-color: white;
                font-size: 14px;
                min-width: 150px;
            }

            .graph-controls select:focus {
                outline: none;
                border-color: #667eea;
                box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            }

            /* Paper Selection Styles */
            .paper-selection-controls {
                display: none;
                background-color: #f8f9fa;
                border: 1px solid #e1e5e9;
                border-radius: 8px;
                padding: 12px;
                margin: 16px 0;
                align-items: center;
                justify-content: space-between;
                gap: 16px;
            }

            .paper-selection-controls.active {
                display: flex;
            }

            .selection-info {
                font-weight: 500;
                color: #495057;
            }

            .selection-actions {
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .selection-dropdown {
                padding: 6px 12px;
                border: 1px solid #cbd5e0;
                border-radius: 4px;
                background-color: white;
                font-size: 14px;
                min-width: 200px;
            }

            .bulk-action-btn {
                padding: 6px 16px;
                background-color: #667eea;
                color: white;
                border: 1px solid #667eea;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s ease;
            }

            .bulk-action-btn:hover:not(:disabled) {
                background-color: #5a6fd8;
                border-color: #5a6fd8;
            }

            .bulk-action-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .paper-item.selectable {
                cursor: pointer;
                position: relative;
            }

            .paper-item.selectable:hover {
                background-color: #f8f9fa;
            }

            .paper-item.selectable.selected {
                background-color: #e7f0ff;
                border-left: 4px solid #667eea;
                box-shadow: 0 2px 4px rgba(102, 126, 234, 0.2);
            }

            .paper-checkbox {
                margin-right: 8px;
                cursor: pointer;
                transform: scale(1.2);
                accent-color: #667eea;
            }

            /* Email Contact Icon */
            .email-contact-icon {
                position: absolute;
                top: 42px;
                right: 42px;
                width: 24px;
                height: 24px;
                background: #28a745;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                opacity: 0.8;
                transition: all 0.2s;
                font-size: 12px;
                color: white;
                z-index: 2;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            .email-contact-icon:hover {
                opacity: 1;
                transform: scale(1.1);
                background: #218838;
            }

            /* Bulk Label Dialog */
            .modal-content {
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                max-height: 80vh;
                overflow-y: auto;
            }

            .modal-content .label-chip {
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .modal-content .label-chip:hover {
                transform: scale(1.05);
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            }

            .modal-content .label-chip.selected {
                background-color: #007bff;
                color: white;
                border-color: #007bff;
            }

            .progress-bar-container {
                width: 100%;
                height: 20px;
                background-color: #f0f0f0;
                border-radius: 10px;
                overflow: hidden;
                margin: 10px 0;
            }

            .progress-bar {
                height: 100%;
                background-color: #007bff;
                width: 0%;
                transition: width 0.3s ease;
            }

            .progress-info {
                margin-bottom: 10px;
                font-weight: bold;
            }

            #batchResults {
                margin-top: 15px;
                max-height: 200px;
                overflow-y: auto;
                border: 1px solid #ddd;
                padding: 10px;
                border-radius: 4px;
                background-color: #f9f9f9;
            }

            .batch-result-item {
                margin-bottom: 5px;
                padding: 5px;
                border-radius: 3px;
            }

            .batch-result-success {
                background-color: #d4edda;
                color: #155724;
                border: 1px solid #c3e6cb;
            }

            .batch-result-error {
                background-color: #f8d7da;
                color: #721c24;
                border: 1px solid #f5c6cb;
            }

            .batch-result-warning {
                background-color: #fff3cd;
                color: #856404;
                border: 1px solid #ffeeba;
            }

            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.05);
                }
                100% {
                    transform: scale(1);
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>The Secure Computation Database</h1>
                <p>
                    Organize and explore your secure computation research papers
                </p>
            </div>

            <div class="main-content">
                <div class="sidebar">
                    <div class="tabs">
                        <button class="tab active" onclick="switchTab('add')">
                            Add Paper
                        </button>
                        <button class="tab" onclick="switchTab('search')">
                            Search
                        </button>
                    </div>

                    <div class="tab-content active" id="add-tab">
                        <div class="section-title">Add New Paper</div>
                        <div class="input-group">
                            <label for="eprint-url"
                                >Paper URL (ePrint, Springer Nature, or ACM
                                Digital Library)</label
                            >
                            <input
                                type="url"
                                id="eprint-url"
                                placeholder="https://eprint.iacr.org/2025/1442 or https://link.springer.com/chapter/10.1007/... or https://dl.acm.org/doi/10.1145/..."
                            />
                        </div>
                        <div class="fetch-buttons">
                            <button class="btn" onclick="fetchPaperMetadata()">
                                <span>📄</span> Fetch Metadata
                            </button>
                            <button
                                class="btn btn-secondary"
                                onclick="showManualParser()"
                            >
                                <span>📝</span> Manual Parse
                            </button>
                        </div>
                        <div
                            class="cors-fix-container"
                            style="
                                display: flex;
                                gap: 8px;
                                justify-content: center;
                            "
                        >
                            <button
                                class="btn"
                                onclick="showCorsHelp()"
                                style="
                                    background: linear-gradient(
                                        135deg,
                                        #f093fb,
                                        #f5576c
                                    );
                                    font-size: 13px;
                                    padding: 8px 16px;
                                    flex: 1;
                                "
                                title="Fix 'Fetch Metadata' blocking"
                            >
                                <span>🔧</span> CORS Fix
                            </button>
                            <button
                                class="btn"
                                onclick="openBatchAddModal()"
                                style="
                                    font-size: 13px;
                                    padding: 8px 16px;
                                    flex: 1;
                                "
                            >
                                <span>📝</span> Batch Add
                            </button>
                        </div>

                        <div
                            id="manual-parser"
                            style="display: none; margin-top: 16px"
                        >
                            <div class="section-title">
                                Paste Paper Page Content
                            </div>
                            <div class="input-group">
                                <label for="page-content"
                                    >Copy and paste the entire paper page text
                                    here (works with ePrint, Springer Nature, or
                                    ACM Digital Library):</label
                                >
                                <textarea
                                    id="page-content"
                                    rows="8"
                                    placeholder="Paste the complete text content from the paper page here..."
                                ></textarea>
                            </div>
                            <button class="btn" onclick="parseManualContent()">
                                <span>🔍</span> Parse Content
                            </button>
                        </div>

                        <div id="metadata-form" style="display: none">
                            <div class="input-group">
                                <label for="paper-title">Title</label>
                                <input type="text" id="paper-title" />
                            </div>
                            <div class="input-group">
                                <label for="paper-authors">Authors</label>
                                <input type="text" id="paper-authors" />
                            </div>
                            <div class="input-group">
                                <label for="paper-abstract">Abstract</label>
                                <textarea
                                    id="paper-abstract"
                                    rows="4"
                                ></textarea>
                            </div>
                            <div class="input-group">
                                <label for="paper-date">Date</label>
                                <input type="date" id="paper-date" />
                            </div>
                            <div class="input-group">
                                <label for="paper-folder">Folder</label>
                                <select id="paper-folder">
                                    <option value="">Root</option>
                                </select>
                            </div>

                            <div class="section-title">Label Sets</div>
                            <p
                                style="
                                    color: #666;
                                    font-size: 0.9em;
                                    margin-bottom: 12px;
                                "
                            >
                                Each paper can have multiple label sets
                                representing different protocols or
                                contributions. All labels in a set should
                                describe the same protocol/contribution
                                together.
                            </p>
                            <div class="label-sets-container">
                                <div id="add-label-sets">
                                    <!-- Label sets will be populated dynamically -->
                                </div>
                                <button
                                    type="button"
                                    class="add-label-set-btn"
                                    onclick="addNewLabelSet('add')"
                                >
                                    <span>➕</span> Add New Label Set
                                </button>
                            </div>

                            <div class="section-title">Previous Works</div>
                            <div class="related-papers-section">
                                <div class="input-group">
                                    <label for="related-paper-url"
                                        >Add by ePrint URL (creates placeholder
                                        if not in database)</label
                                    >
                                    <div class="related-papers-url-input">
                                        <input
                                            type="url"
                                            id="previous-work-url"
                                            placeholder="https://eprint.iacr.org/YYYY/NNN"
                                        />
                                        <button
                                            type="button"
                                            class="btn"
                                            onclick="addPreviousWorkByUrl()"
                                        >
                                            <span>➕</span> Add
                                        </button>
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label
                                        >Search and select from existing
                                        papers</label
                                    >
                                    <input
                                        type="text"
                                        id="previous-work-search"
                                        placeholder="Search existing papers..."
                                        oninput="searchPreviousWorks()"
                                        class="related-papers-search"
                                    />
                                    <select
                                        id="previous-works"
                                        multiple
                                        size="4"
                                        class="related-papers-select"
                                    >
                                        <!-- Will be populated with existing papers -->
                                    </select>
                                    <small style="color: #666"
                                        >Hold Ctrl/Cmd to select multiple
                                        papers</small
                                    >
                                </div>
                                <div class="input-group">
                                    <label>Selected previous works:</label>
                                    <div
                                        id="selected-previous-works"
                                        class="selected-papers-display"
                                    >
                                        <em style="color: #999"
                                            >No papers selected</em
                                        >
                                    </div>
                                </div>
                            </div>

                            <button class="btn" onclick="savePaper()">
                                <span>💾</span> Save Paper
                            </button>
                        </div>
                    </div>

                    <div class="tab-content" id="search-tab">
                        <div class="section-title">Search Papers</div>
                        <div
                            style="
                                display: flex;
                                align-items: center;
                                margin-bottom: 16px;
                            "
                        >
                            <span style="font-weight: 500; color: #333"
                                >Advanced Search</span
                            >
                            <span
                                class="help-icon"
                                onclick="showSearchHelp()"
                                title="Show advanced search help"
                                >?</span
                            >
                        </div>
                        <div
                            id="search-validation-feedback"
                            style="
                                display: none;
                                color: #dc3545;
                                font-size: 12px;
                                margin-bottom: 8px;
                            "
                        ></div>
                        <div class="search-controls">
                            <input
                                type="text"
                                id="search-query"
                                class="search-query-input"
                                placeholder="e.g., title:protocol AND author:Smith, year:2024, date:\"unknown date\" OR cryptography..."
                                oninput="validateAndDebounceSearch()"
                            />
                            <button class="btn" onclick="performSearch()">
                                <span>🔍</span> Search
                            </button>
                        </div>

                        <div class="section-title">Quick Status Filters</div>
                        <div
                            style="
                                display: flex;
                                flex-wrap: wrap;
                                gap: 8px;
                                margin-bottom: 16px;
                            "
                        >
                            <button
                                class="btn btn-secondary"
                                style="font-size: 12px; padding: 6px 12px"
                                onclick="filterByReadingStatus('all')"
                            >
                                All Papers
                            </button>
                            <button
                                class="btn btn-secondary"
                                style="font-size: 12px; padding: 6px 12px"
                                onclick="filterByReadingStatus('to-read')"
                            >
                                📖 To Read
                            </button>
                            <button
                                class="btn btn-secondary"
                                style="font-size: 12px; padding: 6px 12px"
                                onclick="filterByReadingStatus('reading')"
                            >
                                📘 Reading
                            </button>
                            <button
                                class="btn btn-secondary"
                                style="font-size: 12px; padding: 6px 12px"
                                onclick="filterByReadingStatus('read')"
                            >
                                ✅ Read
                            </button>
                            <button
                                class="btn btn-secondary"
                                style="font-size: 12px; padding: 6px 12px"
                                onclick="filterByReadingStatus('skimmed')"
                            >
                                👀 Skimmed
                            </button>
                            <button
                                class="btn btn-secondary"
                                style="font-size: 12px; padding: 6px 12px"
                                onclick="filterByReadingStatus('referenced')"
                            >
                                📚 Referenced
                            </button>
                            <button
                                class="btn btn-secondary"
                                style="font-size: 12px; padding: 6px 12px"
                                onclick="toggleFavoriteFilter()"
                                id="favorite-filter-btn"
                            >
                                ⭐ Favorites
                            </button>
                        </div>

                        <div
                            class="collapsible-section-header"
                            onclick="toggleLabelFilter()"
                        >
                            <span class="collapsible-arrow">▶</span>
                            <span class="section-title" style="margin-bottom: 0"
                                >Filter by Labels</span
                            >
                        </div>
                        <div
                            class="collapsible-content"
                            id="label-filter-content"
                        >
                            <div class="label-selector" id="search-labels">
                                <!-- Labels will be populated dynamically -->
                            </div>
                        </div>

                        <div
                            id="active-search-filters"
                            style="margin: 12px 0; min-height: 20px"
                        >
                            <!-- Active search filters will be displayed here -->
                        </div>

                        <button
                            class="btn btn-secondary"
                            onclick="clearFilters()"
                        >
                            <span>🗑️</span> Clear Filters
                        </button>
                    </div>
                </div>

                <div class="content-area">
                    <div class="section-title">Papers Database</div>
                    <div
                        id="paper-count-display"
                        style="
                            background: #e3f2fd;
                            border-radius: 8px;
                            padding: 8px 12px;
                            margin-bottom: 12px;
                            font-size: 16px;
                            font-weight: bold;
                            color: #1565c0;
                            text-align: center;
                        "
                    >
                        <!-- Total paper count will be populated here -->
                    </div>
                    <div
                        id="reading-status-stats"
                        style="
                            background: rgba(248, 249, 250, 0.8);
                            border-radius: 8px;
                            padding: 12px;
                            margin-bottom: 16px;
                            font-size: 14px;
                            color: #666;
                        "
                    >
                        <!-- Reading status statistics will be populated here -->
                    </div>
                    <div class="sorting-controls">
                        <label for="main-sort-order">Sort&nbsp;by:</label>
                        <select
                            id="main-sort-order"
                            onchange="changeSortOrder()"
                        >
                            <option value="date-desc">
                                Date (Newest First)
                            </option>
                            <option value="date-asc">
                                Date (Oldest First)
                            </option>
                            <option value="title-asc">Title (A-Z)</option>
                            <option value="title-desc">Title (Z-A)</option>
                            <option value="author-asc">Author (A-Z)</option>
                            <option value="author-desc">Author (Z-A)</option>
                            <option value="status-asc">
                                Status (Referenced → Read)
                            </option>
                            <option value="status-desc">
                                Status (Read → Referenced)
                            </option>
                        </select>
                        <div class="view-mode-controls">
                            <label>View:</label>
                            <button
                                type="button"
                                class="view-mode-btn active"
                                id="main-view-normal"
                                onclick="setViewMode('normal')"
                            >
                                Normal
                            </button>
                            <button
                                type="button"
                                class="view-mode-btn"
                                id="main-view-compact"
                                onclick="setViewMode('compact')"
                            >
                                Compact
                            </button>
                            <button
                                type="button"
                                class="view-mode-btn"
                                id="main-view-expanded"
                                onclick="setViewMode('expanded')"
                            >
                                Expanded
                            </button>
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 16px">
                        <div class="database-actions">
                            <button class="btn" onclick="toggleSelectionMode()">
                                <span>☑️</span> Select Papers
                            </button>
                            <button class="btn" onclick="exportDatabase()">
                                <span>📁</span> Export
                            </button>
                            <button class="btn" onclick="exportFullDatabase()" title="Export with scratchpad, reading status, and folders">
                                <span>📁</span> Export Full
                            </button>
                            <input
                                type="file"
                                id="importFile"
                                accept=".json"
                                style="display: none"
                                onchange="importDatabase(event)"
                            />
                            <button
                                class="btn"
                                onclick="document.getElementById('importFile').click()"
                            >
                                <span>📂</span> Import
                            </button>
                            <button class="btn" onclick="openUserManual()" title="Open user manual">
                                <span>📖</span> User Manual
                            </button>
                            <button class="btn" onclick="integrateChanges()" title="Send your changes for review">
                                <span>📧</span> Integrate Changes
                            </button>
                            <button class="btn" onclick="adminLogin()" id="admin-login-btn">
                                <span>🔐</span> Admin Login
                            </button>
                            <button
                                class="btn admin-only"
                                onclick="refreshAllMetadata()"
                                title="Refresh metadata for all visible papers"
                                style="display: none"
                            >
                                <span>🔄</span> Refresh All
                            </button>

                            <button
                                class="btn admin-only"
                                id="sync-db-btn"
                                onclick="syncExtensionPapers()"
                                title="Sync papers added via browser extension to database"
                                style="position: relative; display: none"
                            >
                                <span>🔄</span> Sync DB
                                <span
                                    id="extension-count-badge"
                                    style="
                                        position: absolute;
                                        top: -8px;
                                        right: -8px;
                                        background: #e74c3c;
                                        color: white;
                                        border-radius: 50%;
                                        width: 20px;
                                        height: 20px;
                                        font-size: 11px;
                                        display: none;
                                        align-items: center;
                                        justify-content: center;
                                        font-weight: bold;
                                    "
                                    >0</span
                                >
                            </button>
                            <span
                                class="help-icon admin-only"
                                onclick="showSyncHelp()"
                                title="When do I need to sync?"
                                style="margin-left: 4px; display: none"
                                >ℹ️</span
                            >
                            <input
                                type="file"
                                id="adminImportFile"
                                accept=".json"
                                style="display: none"
                                onchange="importDiffFile(event)"
                            />
                            <button
                                class="btn admin-only"
                                onclick="document.getElementById('adminImportFile').click()"
                                title="Import diff file with changes"
                                style="display: none"
                            >
                                <span>📥</span> Update DB
                            </button>
                        </div>
                    </div>

                    <!-- Paper Selection Controls -->
                    <div
                        id="paper-selection-controls"
                        class="paper-selection-controls"
                    >
                        <div class="selection-info">
                            <span id="selected-count">0</span> papers selected
                            <button
                                class="btn btn-secondary"
                                onclick="selectAllVisiblePapers()"
                                style="
                                    margin-left: 12px;
                                    padding: 4px 8px;
                                    font-size: 12px;
                                "
                            >
                                Select All
                            </button>
                            <button
                                class="btn btn-secondary"
                                onclick="deselectAllPapers()"
                                style="
                                    margin-left: 8px;
                                    padding: 4px 8px;
                                    font-size: 12px;
                                "
                            >
                                Deselect All
                            </button>
                        </div>
                        <div class="selection-actions">
                            <select
                                id="bulk-action-select"
                                class="selection-dropdown"
                            >
                                <option value="">Choose action...</option>
                                <option value="favorite">
                                    Mark as favorite
                                </option>
                                <option value="unfavorite">
                                    Remove from favorites
                                </option>
                                <option value="set-status-referenced">
                                    Set status: Referenced
                                </option>
                                <option value="set-status-to-read">
                                    Set status: To Read
                                </option>
                                <option value="set-status-skimmed">
                                    Set status: Skimmed
                                </option>
                                <option value="set-status-reading">
                                    Set status: Reading
                                </option>
                                <option value="set-status-read">
                                    Set status: Read
                                </option>
                                <option value="add-labels">Add labels</option>
                                <option value="remove-labels">Remove labels</option>
                                <option value="move-to-folder">
                                    Move to folder
                                </option>
                            </select>
                            <button
                                id="execute-bulk-action"
                                class="bulk-action-btn"
                                onclick="executeBulkAction()"
                                disabled
                            >
                                Execute
                            </button>
                            <button
                                class="btn btn-secondary"
                                onclick="toggleSelectionMode()"
                            >
                                Done
                            </button>
                        </div>
                    </div>

                    <div id="papers-list" class="papers-list">
                        <div class="loading">
                            No papers added yet. Add your first paper to get
                            started!
                        </div>
                    </div>
                </div>

                <div class="folders-panel">
                    <div class="section-title">Folders</div>
                    <div class="folders-tree" id="folders-tree">
                        <!-- Folders will be populated dynamically -->
                    </div>
                    <button class="add-folder-btn" onclick="addNewFolder()">
                        <span>📁➕</span> Add Folder
                    </button>
                </div>
            </div>

            <div class="graph-container">
                <div class="section-title">
                    Paper Relationships
                    <span
                        class="help-icon"
                        onclick="showGraphHelp()"
                        title="Show graph help"
                        >?</span>
                </div>
                <div class="graph-controls">
                    <select id="graph-type-select">
                        <option value="followup">Follow-up Graph</option>
                        <option value="author">Author Graph</option>
                    </select>
                    <button
                        class="btn"
                        id="show-graph-btn"
                        onclick="toggleGraph()"
                    >
                        Show Graph
                    </button>
                    <button
                        class="btn btn-secondary"
                        id="hide-graph-btn"
                        onclick="toggleGraph()"
                        style="display: none"
                    >
                        Hide Graph
                    </button>
                    <button
                        class="btn"
                        id="refresh-graph-btn"
                        onclick="refreshGraph()"
                        style="display: none"
                    >
                        Refresh Graph
                    </button>
                </div>
                <div id="graph-display" style="display: none">
                    <svg class="graph-svg" id="relationship-graph"></svg>
                </div>
            </div>

            <!-- Paper Detail Modal -->
            <div id="paper-modal" class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Paper Details</h2>
                        <span class="close" onclick="closePaperModal()"
                            >&times;</span
                        >
                    </div>

                    <div class="modal-actions">
                        <button class="btn" onclick="openPaperLink()">
                            <span>🔗</span> Open Paper
                        </button>
                        <button
                            class="btn btn-success"
                            onclick="enableEditing()"
                        >
                            <span>✏️</span> Edit
                        </button>
                        <button
                            class="btn btn-secondary"
                            id="refresh-metadata-btn"
                            onclick=""
                        >
                            <span>🔄</span> Refresh Metadata
                        </button>
                        <button class="btn btn-danger" onclick="deletePaper()">
                            <span>🗑️</span> Delete
                        </button>
                    </div>

                    <div id="paper-details">
                        <!-- Paper details will be populated here -->
                    </div>

                    <div id="paper-edit-form" style="display: none">
                        <!-- Edit form will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Scratchpad Modal -->
        <div id="scratchpad-modal" class="modal">
            <div class="modal-content scratchpad-modal">
                <div class="modal-header">
                    <h2 id="scratchpad-title">Scratchpad</h2>
                    <span class="close" onclick="closeScratchpadModal()"
                        >&times;</span
                    >
                </div>
                <div class="scratchpad-tabs">
                    <button
                        class="scratchpad-tab active"
                        onclick="switchScratchpadTab('edit')"
                    >
                        Edit
                    </button>
                    <button
                        class="scratchpad-tab"
                        onclick="switchScratchpadTab('preview')"
                    >
                        Preview
                    </button>
                </div>
                <div class="scratchpad-content">
                    <div
                        id="scratchpad-edit"
                        class="scratchpad-tab-content active"
                    >
                        <textarea
                            id="scratchpad-textarea"
                            placeholder="Write your notes about this paper in Markdown..."
                        ></textarea>
                    </div>
                    <div id="scratchpad-preview" class="scratchpad-tab-content">
                        <div id="scratchpad-preview-content"></div>
                    </div>
                </div>
                <div class="modal-actions">
                    <div
                        style="
                            flex: 1;
                            font-size: 12px;
                            color: #666;
                            display: flex;
                            align-items: center;
                        "
                    >
                        <strong>Shortcuts:</strong> Ctrl+S (Save), Ctrl+E
                        (Edit), Ctrl+P (Preview), Esc (Close)
                    </div>
                    <button
                        class="btn btn-secondary"
                        onclick="closeScratchpadModal()"
                    >
                        Close
                    </button>
                    <button class="btn btn-success" onclick="saveScratchpad()">
                        Save
                    </button>
                </div>
            </div>
        </div>

        <!-- Batch Add Modal -->
        <div id="batchAddModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Batch Add Papers</h2>
                    <span class="close" onclick="closeBatchAddModal()"
                        >&times;</span
                    >
                </div>
                <div class="modal-body">
                    <div class="message info">
                        <strong>Note:</strong> This feature requires automatic
                        metadata fetching. Make sure you have CORS Unblock
                        extension enabled for best results.
                    </div>
                    <div class="input-group">
                        <label for="batchUrlsTextarea"
                            >Paste URLs (one per line):</label
                        >
                        <textarea
                            id="batchUrlsTextarea"
                            rows="10"
                            placeholder="https://eprint.iacr.org/2025/449
    https://eprint.iacr.org/2025/453
    https://eprint.iacr.org/2025/460
    ..."
                        ></textarea>
                    </div>
                    <div class="input-group">
                        <label for="batchFolder">Add to folder:</label>
                        <select id="batchFolder">
                            <option value="">Root</option>
                        </select>
                    </div>
                    <div id="batchProgress" style="display: none">
                        <div class="progress-info">
                            <span id="batchProgressText">Processing...</span>
                        </div>
                        <div class="progress-bar-container">
                            <div
                                id="batchProgressBar"
                                class="progress-bar"
                            ></div>
                        </div>
                        <div id="batchResults"></div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button
                        id="batchProcessBtn"
                        onclick="processBatchAdd()"
                        class="btn btn-success"
                    >
                        Process URLs
                    </button>
                    <button
                        onclick="closeBatchAddModal()"
                        class="btn btn-secondary"
                    >
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <script type="module">
            // Global state
            let papers = [];
            let currentEditingPaper = null;
            let searchFilters = {
                included: new Set(),
                excluded: new Set(),
                query: "",
            };
            let currentScratchpadPaper = null;
            let currentSortOrder = "date-desc";
            let currentViewMode = "normal";
            let focusedNode = null;
            let clickTimeout = null;
            let clickCount = 0;
            let folders = [];
            let currentFolder = ""; // Empty string means "Root"
            let favoriteFilterActive = false;

            // Paper selection state
            let paperSelectionMode = false;
            let selectedPapers = new Set();
            let currentlyFilteredPapers = [];

            // Cache variables
            let searchCache = new Map();
            let lastSearchQuery = "";
            let lastSearchFilters = null;
            let lastSearchResults = null;
            const paperElementCache = new Map();

            // Change tracking and admin system
            let originalDatabase = null; // Original state from mpc_db.json for change tracking
            let isAdminMode = false;
            let changeTracker = {
                addedPapers: new Set(),
                modifiedPapers: new Map(),
                deletedPapers: new Set(),
                modifiedLabels: new Map() // paperId -> {added: Set(), removed: Set()}
            };

            function updatePaperCount() {
                const paperCountElement = document.getElementById(
                    "paper-count-display",
                );
                if (paperCountElement) {
                    paperCountElement.innerHTML = `${papers.length} total papers`;
                }
            }

            // Memory management
            function cleanupMemory() {
                // Clear caches when they get too large
                if (paperElementCache.size > 1000) {
                    paperElementCache.clear();
                }
                if (searchCache.size > 50) {
                    searchCache.clear();
                }
                // Run garbage collection hint if available
                if (window.gc) {
                    window.gc();
                }
            }

            // Reading status options
            const readingStatuses = [
                { key: "referenced", label: "Referenced", icon: "📚" },
                { key: "to-read", label: "To Read", icon: "📖" },
                { key: "skimmed", label: "Skimmed", icon: "👀" },
                { key: "reading", label: "Reading", icon: "📘" },
                { key: "read", label: "Read", icon: "✅" },
            ];

            // Label categories and options
            const labelCategories = {
                "Protocol type": [
                    "GMW-style",
                    "BGW-style",
                    "Garbling",
                    "Mixed-mode",
                    "Custom type:",
                ],
                "Security Model": ["passive", "covert", "active"],
                "Corruption Threshold": [
                    "1 corruption",
                    "n/4 corruptions",
                    "n/3 corruptions",
                    "n/2-epsilon corruptions",
                    "n/2 corruptions",
                    "n-epsilon corruptions",
                    "n-1 corruptions",
                ],
                "Number of Parties": [
                    "2 parties",
                    "3 parties",
                    "4 parties",
                    "Constant parties",
                    "Any parties",
                    "Many parties (e.g. YOSO)",
                    "Custom number:",
                ],
                Adaptivity: [
                    "Selective",
                    "Adaptive",
                    "Adaptive without erasure",
                    "Adaptive with erasure",
                ],
                Concurrency: ["stand-alone", "concurrent", "UC"],
                "Computational Model": [
                    "Boolean circuits",
                    "Arithmetic circuits",
                    "RAM",
                    "Restricted circuits",
                ],
                Interactivity: [
                    "2-round",
                    "3-round",
                    "4-round",
                    "Constant-round",
                    "Non-constant-round",
                ],
                "What does it improve?": [
                    "Better assumptions",
                    "Less rounds",
                    "Less communication",
                    "Less computation",
                    "Real-world efficiency",
                    "Stronger security model",
                    "Randomness complexity",
                    "More versatile",
                    "Black-box",
                    "Custom improvement:",
                ],
                Assumptions: [
                    "Information theoretic",
                    "OWF",
                    "OT",
                    "LPN/codes",
                    "Lattice/FHE",
                    "Group-based",
                    "Pairings",
                    "Factoring-based",
                    "iO",
                ],
                "Idealized models": [
                    "CRS",
                    "ROM",
                    "Ideal cipher",
                    "RPM",
                    "Ideal obfuscation",
                    "Noisy channels",
                    "Hardware token",
                    "Correlated randomness model",
                ],
                Misc: [
                    "TTP/helper",
                    "Has implementations",
                    "Quantum",
                    "SoK/survey",
                ],
                "Specific Functionality": [
                    "Zero-knowledge",
                    "SNARGs/SNARKs/IOP",
                    "Oblivious transfer",
                    "OLE/VOLE",
                    "OPRF",
                    "Multiplication triples",
                    "PIR",
                    "Coin tossing",
                    "Secret sharing",
                    "PSI",
                    "PAKE",
                    "Threshold cryptography",
                    "eVoting",
                    "Auctions",
                    "Byzantine agreement",
                    "PPML",
                    "AND",
                    "Custom functionality:",
                ],
                "Tools for MPC": [
                    "HSS",
                    "PCG",
                    "DPF/FSS",
                    "FHE",
                    "FE/ABE",
                    "Commitment",
                    "Secret sharing",
                ],
                "Communication graph": ["Incomplete graph", "Topology-hiding"],
                "Aborts and fairness": [
                    "Secure with aborts",
                    "Identifiable aborts",
                    "Partial fairness",
                    "Fairness",
                    "GOD",
                ],
                Synchronicity: [
                    "Synchronous networks",
                    "Asynchronous networks",
                ],
            };

            // Labels that can be annotated
            const annotatableLabels = new Set([
                "restricted circuits",
                "other",
                "Other",
                "Custom type:",
                "Custom number:",
                "Custom improvement:",
                "Custom functionality:",
            ]);

            // Simplified filtering function
            function invalidateSearchCache() {
                // Simple cache invalidation
                if (typeof searchCache !== "undefined") {
                    searchCache.clear();
                }
            }

            function getCurrentlyFilteredPapers() {
                if (!papers || papers.length === 0) {
                    return [];
                }

                const query =
                    document.getElementById("search-query")?.value.trim() || "";

                console.log(
                    `[GET FILTERED DEBUG] getCurrentlyFilteredPapers called with query="${query}" - currentlyFilteredPapers.length=${currentlyFilteredPapers.length}`,
                );

                const results = papers.filter((paper) => {
                    // Folder filter
                    if (!isPaperInCurrentFolderHierarchy(paper)) {
                        return false;
                    }

                    // Text search
                    if (query && !evaluateAdvancedQuery(query, paper)) {
                        if (query.includes("date:") && query.includes("unknown")) {
                            console.log(
                                `DEBUG: Paper "${paper.title}" (date="${paper.date}") filtered out by query`,
                            );
                        }
                        return false;
                    }

                    // Label filters
                    if (
                        searchFilters.included.size > 0 ||
                        searchFilters.excluded.size > 0
                    ) {
                        const labelSets = paper.labelSets || [];

                        // Check included labels
                        if (searchFilters.included.size > 0) {
                            const hasAllIncluded = labelSets.some(
                                (labelSet) => {
                                    return Array.from(
                                        searchFilters.included,
                                    ).every((searchLabel) => {
                                        return labelSet.labels.includes(
                                            searchLabel,
                                        );
                                    });
                                },
                            );
                            if (!hasAllIncluded) {
                                return false;
                            }
                        }

                        // Check excluded labels
                        if (searchFilters.excluded.size > 0) {
                            const hasExcluded = labelSets.some((labelSet) => {
                                return Array.from(searchFilters.excluded).some(
                                    (searchLabel) => {
                                        return labelSet.labels.includes(
                                            searchLabel,
                                        );
                                    },
                                );
                            });
                            if (hasExcluded) {
                                return false;
                            }
                        }
                    }

                    // Favorite filter
                    if (favoriteFilterActive && !paper.favorite) {
                        return false;
                    }

                    return true;
                });

                return results;
            }

            // Initialize the app
            async function init() {
                console.log("=== INITIALIZING CRYPTO PAPER MANAGER ===");

                try {
                    // Initialize IndexedDB first
                    await initDB();
                    console.log("IndexedDB initialized successfully");

                    // Try to auto-load mpc_db.json first
                    await autoLoadDatabase();

                    // Load data from IndexedDB
                    await loadPapers();
                    await loadFolders();

                    // Add beforeunload listener to ensure data is saved before closing
                    window.addEventListener("beforeunload", function (e) {
                        console.log(
                            "[BEFOREUNLOAD] Saving data before window close...",
                        );

                        // Force immediate save to localStorage if there are unsaved changes
                        try {
                            saveToLocalStorage();
                            console.log(
                                "[BEFOREUNLOAD] ✅ Data saved to localStorage",
                            );
                        } catch (saveError) {
                            console.error(
                                "[BEFOREUNLOAD] ❌ Failed to save to localStorage:",
                                saveError,
                            );
                        }

                        // Try to flush any pending IndexedDB operations
                        if (navigator.sendBeacon) {
                            // This is a hint to the browser that we want to complete background operations
                            navigator.sendBeacon("/dev/null", "");
                        }
                    });

                    // Add periodic background sync to ensure data consistency (deferred)
                    setTimeout(() => {
                        setInterval(() => {
                            // Only sync if we have papers and the page is visible (to avoid unnecessary work)
                            if (papers.length > 0 && !document.hidden) {
                                console.log(
                                    "[PERIODIC] Running background sync...",
                                );
                                syncToIndexedDB().catch((error) => {
                                    console.log(
                                        "[PERIODIC] IndexedDB sync failed (data is safe in localStorage):",
                                        error,
                                    );
                                });
                            }
                        }, 60000); // Sync every 60 seconds (reduced frequency)
                    }, 5000);

                    // Add visibility change listener to sync when page becomes visible
                    document.addEventListener("visibilitychange", function () {
                        if (!document.hidden && papers.length > 0) {
                            console.log(
                                "[VISIBILITY] Page became visible, syncing data...",
                            );
                            // Page became visible, sync any pending changes
                            syncToIndexedDB().catch((error) => {
                                console.log(
                                    "[VISIBILITY] Sync failed (data is safe in localStorage):",
                                    error,
                                );
                            });
                        }
                    });

                    // Add data consistency validation and periodic checks (deferred)
                    setTimeout(() => {
                        setInterval(() => {
                            validateDataConsistency();
                        }, 300000); // Check every 5 minutes (reduced frequency)
                    }, 10000);

                    // Add listener for storage events (in case of multiple tabs)
                    window.addEventListener("storage", function (e) {
                        if (e.key === "cryptoPapers" && e.newValue) {
                            console.log(
                                "[STORAGE EVENT] localStorage updated by another tab",
                            );
                            // Reload and merge data
                            loadPapers().then(() => {
                                performSearch();
                                renderPapers();
                            });
                        }
                    });

                    await loadFolders();

                    // Render UI
                    renderFolders();
                    setupPreviousWorksListeners();
                    populateFolderSelects();
                    setTimeout(() => initializeLabelSets("add"), 100);

                    // Add event listener for graph type selection
                    document
                        .getElementById("graph-type-select")
                        .addEventListener("change", function () {
                            if (
                                document.getElementById("graph-display").style
                                    .display !== "none"
                            ) {
                                renderGraph();
                            }
                        });

                    // Check for auto-add parameters from browser extension (delayed to ensure DOM is ready)
                    setTimeout(async () => {
                        await checkAutoAddParameters();
                        // Update paper count after auto-add processing is complete
                        updatePaperCount();
                    }, 100);

                    // Check for pending papers from browser extension
                    await checkExtensionPendingPapers();

                    // Set up periodic memory cleanup (deferred)
                    setTimeout(() => {
                        setInterval(cleanupMemory, 600000); // Every 10 minutes (reduced frequency)
                    }, 15000);

                    // Always render the UI after papers are loaded
                    console.log(`Rendering UI with ${papers.length} papers...`);

                    // Reset search state
                    currentlyFilteredPapers = [];

                    // Render critical UI immediately
                    renderLabels("search-labels", "search");
                    renderFolders();
                    performSearch();

                    // Paper count will be updated after extension papers are loaded

                    // Defer non-critical updates
                    setTimeout(() => {

                        // Initialize reading status statistics
                        updateReadingStatusStats(papers);

                        // Update extension sync badge
                        updateExtensionSyncBadge();

                        // Check if there are extension papers waiting for sync
                        const extensionStored = localStorage.getItem(
                            "cryptoExtensionPapers",
                        );
                        if (extensionStored) {
                            const extensionPapers = JSON.parse(extensionStored);
                            if (extensionPapers.length > 0) {
                                console.log(
                                    `[INIT] Found ${extensionPapers.length} extension papers waiting for sync`,
                                );
                                showMessage(
                                    `📋 ${extensionPapers.length} extension papers ready to sync. Click 'Sync DB' to add them permanently.`,
                                    "info",
                                );
                            }
                        }
                    }, 500);

                        // Check for date integrity issues (deferred to avoid blocking startup)
                        setTimeout(() => {
                            const dateCheck = checkDateIntegrity();
                            if (dateCheck.suspicious > 0) {
                                console.warn(
                                    `[INIT] ⚠️ Found ${dateCheck.suspicious} papers with corrupted dates after 2025-08-15`,
                                );

                                if (dateCheck.suspicious <= 20) {
                                    showMessage(
                                        `⚠️ ${dateCheck.suspicious} papers have corrupted dates. Search with date:"unknown date" to find them.`,
                                        "warning",
                                    );
                                }
                            }
                        }, 2000);


                    console.log(
                        `=== INITIALIZATION COMPLETE: ${papers.length} papers, ${folders.length} folders ===`,
                    );

                    // Ensure folder selector is populated after loading
                    populateFolderSelects();

                    // Debug: Check if papers are actually loaded
                    if (papers.length === 0) {
                        console.error(
                            "WARNING: No papers loaded! This suggests a database loading issue.",
                        );
                        console.log("Checking localStorage for backup data...");
                        const localStored =
                            localStorage.getItem("cryptoPapers");
                        if (localStored) {
                            try {
                                const backupPapers = JSON.parse(localStored);
                                console.log(
                                    `Found ${backupPapers.length} papers in localStorage backup`,
                                );
                                if (
                                    backupPapers.length > 0 &&
                                    confirm(
                                        "No papers found in database, but found backup in localStorage. Restore from backup?",
                                    )
                                ) {
                                    papers = backupPapers;
                                    savePapers();
                                    performSearch();
                                    renderLabels("search-labels", "search");
                                    showMessage(
                                        `Restored ${papers.length} papers from backup!`,
                                        "success",
                                    );
                                }
                            } catch (e) {
                                console.error(
                                    "Error parsing localStorage backup:",
                                    e,
                                );
                            }
                        }
                    }
                } catch (error) {
                    console.error("Initialization error:", error);
                    showMessage(
                        "Error initializing database. Check console for details.",
                        "error",
                    );
                }
            }

            // Auto-load mpc_db.json if it exists
            async function autoLoadDatabase() {
                try {
                    console.log("Attempting to auto-load mpc_db.json...");

                    // Check if we're running from file:// protocol
                    if (window.location.protocol === 'file:') {
                        console.log("⚠️ Running from file:// protocol - auto-load will not work");
                        console.log("📝 For auto-load to work:");
                        console.log("  • Deploy to a web server (e.g., GitHub Pages)");
                        console.log("  • Or run a local server: python -m http.server");
                        console.log("  • Auto-load will work normally in production");
                        showMessage('Auto-load disabled: use Import button to load mpc_db.json when running locally', 'info');
                        return;
                    }

                    const response = await fetch('mpc_db.json');
                    if (response.ok) {
                        const data = await response.json();
                        console.log("✅ Auto-loading mpc_db.json...");

                        // Store original database for change tracking
                        originalDatabase = JSON.parse(JSON.stringify(data));

                        // Reset change tracker
                        changeTracker = {
                            addedPapers: new Set(),
                            modifiedPapers: new Map(),
                            deletedPapers: new Set(),
                            modifiedLabels: new Map()
                        };

                        // Import the data (overwrite everything)
                        papers = data.papers || [];

                        // Save to IndexedDB
                        await savePapers();

                        console.log(`✅ Auto-loaded ${papers.length} papers from mpc_db.json`);
                        showMessage(`Database loaded successfully: ${papers.length} papers from mpc_db.json`, 'success');
                    } else {
                        console.log(`❌ mpc_db.json not found (HTTP ${response.status}), continuing with existing data`);
                        console.log("💡 If this is unexpected, check that mpc_db.json exists in the same directory");
                    }
                } catch (error) {
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        console.log("❌ Network error loading mpc_db.json - likely CORS or file access issue");
                        console.log("💡 This is normal when running locally via file:// protocol");
                    } else {
                        console.log("❌ Error auto-loading mpc_db.json:", error);
                    }
                    console.log("📂 Continuing with existing browser data...");
                }
            }

            // Password hashing utility using Web Crypto API
            async function hashPassword(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password + "mpc_salt_2024"); // Add salt
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            // Admin login function
            async function adminLogin() {
                console.log("adminLogin called");
                const password = prompt("Enter admin password:");
                if (!password) return;

                const hashedPassword = await hashPassword(password);
                const correctHash = await hashPassword("0B3Li5C_2024");

                if (hashedPassword === correctHash) {
                    isAdminMode = true;
                    document.getElementById('admin-login-btn').innerHTML = '<span>🔓</span> Admin Logout';
                    document.getElementById('admin-login-btn').onclick = adminLogout;

                    // Show admin-only buttons
                    const adminElements = document.querySelectorAll('.admin-only');
                    adminElements.forEach(el => el.style.display = '');

                    showMessage('Admin mode enabled', 'success');
                } else {
                    showMessage('Incorrect password', 'error');
                }
            }

            // Admin logout function
            function adminLogout() {
                isAdminMode = false;
                document.getElementById('admin-login-btn').innerHTML = '<span>🔐</span> Admin Login';
                document.getElementById('admin-login-btn').onclick = adminLogin;

                // Hide admin-only buttons
                const adminElements = document.querySelectorAll('.admin-only');
                adminElements.forEach(el => el.style.display = 'none');

                showMessage('Admin mode disabled', 'info');
            }

            // Make functions globally available
            window.adminLogin = adminLogin;
            window.adminLogout = adminLogout;

            // Track changes when papers are added/modified/deleted
            function trackChange(type, paper, originalPaper = null) {
                if (!originalDatabase) return; // No original database to compare against

                switch (type) {
                    case 'add':
                        changeTracker.addedPapers.add(paper.id);
                        break;
                    case 'modify':
                        if (!changeTracker.addedPapers.has(paper.id)) {
                            changeTracker.modifiedPapers.set(paper.id, {
                                original: originalPaper,
                                modified: paper
                            });
                        }
                        break;
                    case 'delete':
                        if (changeTracker.addedPapers.has(paper.id)) {
                            changeTracker.addedPapers.delete(paper.id);
                        } else {
                            changeTracker.deletedPapers.add(paper.id);
                        }
                        break;
                    case 'label':
                        if (!changeTracker.modifiedLabels.has(paper.id)) {
                            changeTracker.modifiedLabels.set(paper.id, {
                                added: new Set(),
                                removed: new Set()
                            });
                        }
                        break;
                }
            }

            // Generate changes summary
            function generateChangesSummary() {
                let summary = "Changes made to the MPC Database:\n\n";

                // Added papers
                if (changeTracker.addedPapers.size > 0) {
                    summary += "ADDED PAPERS:\n";
                    changeTracker.addedPapers.forEach(paperId => {
                        const paper = papers.find(p => p.id === paperId);
                        if (paper) {
                            summary += `- ${paper.title} (${paper.authors || 'Unknown authors'})\n`;
                        }
                    });
                    summary += "\n";
                }

                // Modified papers
                if (changeTracker.modifiedPapers.size > 0) {
                    summary += "MODIFIED PAPERS:\n";
                    changeTracker.modifiedPapers.forEach((change, paperId) => {
                        summary += `- Paper: ${change.modified.title}\n`;

                        // Check for field changes
                        const fields = ['title', 'authors', 'abstract', 'url', 'date', 'venue'];
                        fields.forEach(field => {
                            if (change.original[field] !== change.modified[field]) {
                                summary += `  ${field}: "${change.original[field] || ''}" → "${change.modified[field] || ''}"\n`;
                            }
                        });

                        // Check for label changes
                        const origLabels = new Set(change.original.labels || []);
                        const modLabels = new Set(change.modified.labels || []);

                        const addedLabels = [...modLabels].filter(l => !origLabels.has(l));
                        const removedLabels = [...origLabels].filter(l => !modLabels.has(l));

                        if (addedLabels.length > 0) {
                            summary += `  Added labels: ${addedLabels.join(', ')}\n`;
                        }
                        if (removedLabels.length > 0) {
                            summary += `  Removed labels: ${removedLabels.join(', ')}\n`;
                        }
                    });
                    summary += "\n";
                }

                // Deleted papers
                if (changeTracker.deletedPapers.size > 0) {
                    summary += "DELETED PAPERS:\n";
                    changeTracker.deletedPapers.forEach(paperId => {
                        const originalPaper = originalDatabase.papers.find(p => p.id === paperId);
                        if (originalPaper) {
                            summary += `- ${originalPaper.title} (${originalPaper.authors || 'Unknown authors'})\n`;
                        }
                    });
                }

                return summary || "No changes detected.";
            }

            // Generate diff file
            function generateDiffFile() {
                const diff = {
                    version: "1.0",
                    timestamp: new Date().toISOString(),
                    changes: {
                        added: [],
                        modified: [],
                        deleted: Array.from(changeTracker.deletedPapers)
                    }
                };

                // Added papers (excluding local-only data)
                changeTracker.addedPapers.forEach(paperId => {
                    const paper = papers.find(p => p.id === paperId);
                    if (paper) {
                        const cleanPaper = { ...paper };
                        delete cleanPaper.scratchpad;
                        delete cleanPaper.readingStatus;
                        delete cleanPaper.favorite;
                        delete cleanPaper.folderId;
                        diff.changes.added.push(cleanPaper);
                    }
                });

                // Modified papers
                changeTracker.modifiedPapers.forEach((change, paperId) => {
                    const cleanPaper = { ...change.modified };
                    delete cleanPaper.scratchpad;
                    delete cleanPaper.readingStatus;
                    delete cleanPaper.favorite;
                    delete cleanPaper.folderId;
                    diff.changes.modified.push(cleanPaper);
                });

                return diff;
            }

            // Integrate changes function
            function integrateChanges() {
                console.log("integrateChanges called");
                if (!originalDatabase) {
                    showMessage('No original database loaded. Changes cannot be tracked.', 'error');
                    return;
                }

                const hasChanges = changeTracker.addedPapers.size > 0 ||
                                 changeTracker.modifiedPapers.size > 0 ||
                                 changeTracker.deletedPapers.size > 0;

                if (!hasChanges) {
                    showMessage('No changes detected to integrate.', 'info');
                    return;
                }

                // Show contact form modal
                showContactForm();
            }

            // Show contact form for change integration
            function showContactForm() {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <div class="modal-header">
                            <h2>Integrate Changes</h2>
                            <span class="close" onclick="closeContactForm()">&times;</span>
                        </div>
                        <div style="padding: 20px;">
                            <p style="margin-bottom: 20px;">Your changes will be sent for review. Please provide your contact information:</p>

                            <div class="input-group">
                                <label for="contact-firstname">First Name *</label>
                                <input type="text" id="contact-firstname" required>
                            </div>

                            <div class="input-group">
                                <label for="contact-lastname">Last Name *</label>
                                <input type="text" id="contact-lastname" required>
                            </div>

                            <div class="input-group">
                                <label for="contact-website">Website (optional)</label>
                                <input type="url" id="contact-website" placeholder="https://...">
                            </div>

                            <div style="margin-top: 20px;">
                                <h4>Changes Summary:</h4>
                                <pre style="background: #f5f5f5; padding: 10px; border-radius: 4px; max-height: 200px; overflow-y: auto; font-size: 12px;">${generateChangesSummary()}</pre>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="btn btn-secondary" onclick="closeContactForm()">Cancel</button>
                            <button class="btn btn-success" onclick="submitChanges()">Send Changes</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                modal.style.display = 'flex';
                window.currentContactModal = modal;
            }

            // Close contact form
            function closeContactForm() {
                if (window.currentContactModal) {
                    document.body.removeChild(window.currentContactModal);
                    window.currentContactModal = null;
                }
            }

            // Submit changes via email
            function submitChanges() {
                const firstname = document.getElementById('contact-firstname').value.trim();
                const lastname = document.getElementById('contact-lastname').value.trim();
                const website = document.getElementById('contact-website').value.trim();

                if (!firstname || !lastname) {
                    showMessage('Please fill in all required fields.', 'error');
                    return;
                }

                const contactInfo = `${firstname} ${lastname}` + (website ? ` (${website})` : '');
                const summary = generateChangesSummary();
                const diffFile = generateDiffFile();

                // Create mailto link
                const subject = encodeURIComponent('MPC Database Changes Submission');
                const body = encodeURIComponent(`Contact: ${contactInfo}\n\n${summary}`);

                // Create downloadable diff file
                const diffBlob = new Blob([JSON.stringify(diffFile, null, 2)], { type: 'application/json' });
                const diffUrl = URL.createObjectURL(diffBlob);
                const diffLink = document.createElement('a');
                diffLink.href = diffUrl;
                diffLink.download = `mpc_db_changes_${new Date().toISOString().split('T')[0]}.json`;

                // Show instructions
                showMessage(`Please download the changes file and attach it to your email to mpc@irif.fr`, 'info');

                // Trigger downloads/email
                diffLink.click();
                setTimeout(() => {
                    window.location.href = `mailto:mpc@irif.fr?subject=${subject}&body=${body}`;
                }, 1000);

                closeContactForm();
                URL.revokeObjectURL(diffUrl);
            }

            // Make functions globally available
            window.integrateChanges = integrateChanges;
            window.showContactForm = showContactForm;
            window.closeContactForm = closeContactForm;
            window.submitChanges = submitChanges;

            // Import diff file (admin only)
            async function importDiffFile(event) {
                if (!isAdminMode) {
                    showMessage('Admin access required', 'error');
                    return;
                }

                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const diff = JSON.parse(text);

                    if (!diff.changes) {
                        throw new Error('Invalid diff file format');
                    }

                    let appliedCount = 0;

                    // Apply added papers
                    if (diff.changes.added) {
                        diff.changes.added.forEach(paper => {
                            const existingIndex = papers.findIndex(p => p.id === paper.id);
                            if (existingIndex === -1) {
                                papers.push(paper);
                                appliedCount++;
                            }
                        });
                    }

                    // Apply modified papers
                    if (diff.changes.modified) {
                        diff.changes.modified.forEach(paper => {
                            const existingIndex = papers.findIndex(p => p.id === paper.id);
                            if (existingIndex !== -1) {
                                // Preserve local-only data
                                const localData = {
                                    scratchpad: papers[existingIndex].scratchpad,
                                    readingStatus: papers[existingIndex].readingStatus,
                                    favorite: papers[existingIndex].favorite,
                                    folderId: papers[existingIndex].folderId
                                };
                                papers[existingIndex] = { ...paper, ...localData };
                                appliedCount++;
                            }
                        });
                    }

                    // Apply deleted papers
                    if (diff.changes.deleted) {
                        diff.changes.deleted.forEach(paperId => {
                            const existingIndex = papers.findIndex(p => p.id === paperId);
                            if (existingIndex !== -1) {
                                papers.splice(existingIndex, 1);
                                appliedCount++;
                            }
                        });
                    }

                    await savePapers();
                    renderPapers();
                    updatePaperCount();

                    showMessage(`Applied ${appliedCount} changes from diff file`, 'success');

                } catch (error) {
                    console.error('Error importing diff file:', error);
                    showMessage('Error importing diff file: ' + error.message, 'error');
                }

                event.target.value = '';
            }

            // Export full database (with local data)
            function exportFullDatabase() {
                console.log("exportFullDatabase called");
                const data = {
                    papers: papers,
                    folders: folders,
                    exportDate: new Date().toISOString(),
                    version: "1.0",
                    isFullExport: true
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mpc_db_full_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                showMessage('Full database exported successfully', 'success');
            }

            // Make function globally available
            window.exportFullDatabase = exportFullDatabase;

            // Open user manual
            function openUserManual() {
                console.log("openUserManual called");
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h2>MPC Database User Manual</h2>
                            <span class="close" onclick="closeUserManual()">&times;</span>
                        </div>
                        <div style="padding: 20px; line-height: 1.6;">
                            <h3>1. What the Database Offers</h3>
                            <p>This database contains research papers on Multi-Party Computation (MPC) and related cryptographic topics. Features include:</p>
                            <ul>
                                <li><strong>Comprehensive paper collection</strong> with metadata (title, authors, abstract, venue, date)</li>
                                <li><strong>Smart labeling system</strong> for categorizing papers by topics, techniques, and applications</li>
                                <li><strong>Reading status tracking</strong> (to-read, reading, read, skimmed, referenced)</li>
                                <li><strong>Follow-up graph</strong> showing connections between papers</li>
                                <li><strong>Advanced search</strong> with Boolean logic and field-specific queries</li>
                                <li><strong>Personal annotations</strong> via scratchpad for each paper</li>
                            </ul>

                            <h3>2. Local Modifications and Change Integration</h3>
                            <p>When you modify the database (add papers, edit metadata, change labels), these changes are stored locally in your browser. Your modifications do not automatically update the main database.</p>

                            <p><strong>To submit your changes:</strong></p>
                            <ul>
                                <li>Click "Integrate Changes" to send your modifications for review</li>
                                <li>Provide your contact information when prompted</li>
                                <li>An email will be sent to mpc@irif.fr with a summary of your changes</li>
                                <li>Changes are reviewed and may be integrated into the main database</li>
                            </ul>

                            <p><strong>Important:</strong> If changes are not integrated, they will be overwritten when the database is updated. Use "Export" to save your personal copy of the database.</p>

                            <h3>3. Personal Data and Privacy</h3>
                            <p>The following information stays local to your browser and is never shared:</p>
                            <ul>
                                <li><strong>Scratchpad notes</strong> - Your personal annotations for each paper</li>
                                <li><strong>Reading status</strong> - Whether you've read, skimmed, or plan to read papers</li>
                                <li><strong>Folder organization</strong> - Your personal folder structure</li>
                                <li><strong>Favorites</strong> - Papers you've marked as favorites</li>
                            </ul>

                            <p><strong>Export vs Export Full:</strong></p>
                            <ul>
                                <li><strong>Export:</strong> Saves papers and labels only (for sharing or backup)</li>
                                <li><strong>Export Full:</strong> Includes all personal data (scratchpad, reading status, folders)</li>
                            </ul>

                            <h3>4. Adding Papers</h3>
                            <p><strong>Supported Sources:</strong></p>
                            <ul>
                                <li>ePrint Archive (eprint.iacr.org)</li>
                                <li>ACM Digital Library</li>
                                <li>IEEE Xplore</li>
                                <li>Springer (limited due to CORS restrictions)</li>
                            </ul>

                            <p><strong>Automatic Metadata Fetching:</strong></p>
                            <ul>
                                <li>Install CORS Unblock extension (Chrome/Firefox) for best results</li>
                                <li>Paste URL in "Add Paper" section and click "Fetch"</li>
                                <li>Metadata is automatically extracted when possible</li>
                            </ul>

                            <p><strong>Manual Entry:</strong></p>
                            <ul>
                                <li>For Springer or when automatic fetching fails</li>
                                <li>Copy full page text (Ctrl+A / Cmd+A) and paste into "Manual Parser"</li>
                                <li>System extracts metadata from the plain text</li>
                                <li>Edit any fields manually if needed</li>
                            </ul>

                            <h3>5. Advanced Search System</h3>
                            <p>The search system supports powerful Boolean logic:</p>

                            <p><strong>Boolean Operators:</strong></p>
                            <ul>
                                <li><code>AND</code> - Both terms must be present</li>
                                <li><code>OR</code> - Either term can be present</li>
                                <li><code>NOT</code> - Exclude papers with this term</li>
                                <li><code>( )</code> - Group operations for complex queries</li>
                            </ul>

                            <p><strong>Field-Specific Search:</strong></p>
                            <ul>
                                <li><code>title:homomorphic</code> - Search only in titles</li>
                                <li><code>author:"alice smith"</code> - Search for exact author name</li>
                                <li><code>abstract:MPC</code> - Search only in abstracts</li>
                                <li><code>venue:CRYPTO</code> - Search by publication venue</li>
                                <li><code>date:2023</code> - Papers from specific year</li>
                                <li><code>label:protocol</code> - Papers with specific label</li>
                            </ul>

                            <p><strong>Case-Sensitive Search:</strong></p>
                            <ul>
                                <li><code>title:#OT</code> - Use # prefix for exact case matching</li>
                            </ul>

                            <p><strong>Example Queries:</strong></p>
                            <ul>
                                <li><code>author:"alice" AND label:protocol</code></li>
                                <li><code>(title:homomorphic OR title:FHE) AND date:2023</code></li>
                                <li><code>label:MPC NOT label:theory</code></li>
                            </ul>

                            <h3>6. Contributing and Feedback</h3>
                            <p>This is version 0.1 of the MPC Database. Your contributions are welcome!</p>

                            <p><strong>Ways to help:</strong></p>
                            <ul>
                                <li>Suggest new labels or label categories</li>
                                <li>Report bugs or usability issues</li>
                                <li>Propose new features or improvements</li>
                                <li>Contribute papers or corrections</li>
                            </ul>

                            <p><strong>Contact:</strong> Send suggestions, bug reports, or offers to contribute to <strong>mpc@irif.fr</strong></p>

                            <p>Thank you for using and improving the MPC Database!</p>
                        </div>
                        <div class="modal-actions">
                            <button class="btn" onclick="closeUserManual()">Close</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                modal.style.display = 'flex';
                window.currentUserManual = modal;
            }

            // Close user manual
            function closeUserManual() {
                if (window.currentUserManual) {
                    document.body.removeChild(window.currentUserManual);
                    window.currentUserManual = null;
                }
            }

            // Make functions globally available
            window.openUserManual = openUserManual;
            window.closeUserManual = closeUserManual;

            async function checkAutoAddParameters() {
                const urlParams = new URLSearchParams(window.location.search);

                // First check sessionStorage (for hybrid approach)
                const sessionData = sessionStorage.getItem("extensionPaperData");
                if (sessionData) {
                    console.log("Processing paper from sessionStorage (hybrid approach)");
                    try {
                        const metadata = JSON.parse(sessionData);
                        sessionStorage.removeItem("extensionPaperData");
                        await processExtensionPaper(metadata);
                        return;
                    } catch (error) {
                        console.error("Error processing sessionStorage data:", error);
                    }
                }

                // Check if we should wait for sessionStorage data
                if (urlParams.get("extensionData") === "sessionStorage") {
                    console.log("Extension indicated sessionStorage data incoming, waiting...");

                    // Wait up to 5 seconds for sessionStorage data to arrive
                    let attempts = 0;
                    const maxAttempts = 50; // 5 seconds / 100ms

                    const waitForSessionStorage = async () => {
                        const sessionData = sessionStorage.getItem("extensionPaperData");
                        if (sessionData) {
                            console.log("SessionStorage data received, processing...");
                            try {
                                const metadata = JSON.parse(sessionData);
                                sessionStorage.removeItem("extensionPaperData");
                                await processExtensionPaper(metadata);
                                return;
                            } catch (error) {
                                console.error("Error processing delayed sessionStorage data:", error);
                            }
                        }

                        attempts++;
                        if (attempts < maxAttempts) {
                            setTimeout(waitForSessionStorage, 100);
                        } else {
                            console.log("Timeout waiting for sessionStorage data");
                        }
                    };

                    setTimeout(waitForSessionStorage, 100);
                    return;
                }

                // Legacy sessionStorage check
                const legacySessionData = sessionStorage.getItem("pendingPaperFromExtension");
                if (legacySessionData) {
                    console.log("Processing paper from legacy sessionStorage");
                    await checkExtensionPendingPapers();
                    return;
                }

                // Fallback to URL parameters (works for both short and long parameter names)
                if (urlParams.get("autoAdd") === "true") {
                    const metadata = {
                        title: urlParams.get("title") || urlParams.get("t") || "",
                        authors: urlParams.get("authors") || urlParams.get("a") || "",
                        abstract: urlParams.get("abstract") || urlParams.get("abs") || "",
                        date: urlParams.get("date") || urlParams.get("d") || "",
                        url: urlParams.get("url") || urlParams.get("u") || "",
                        paperId: urlParams.get("paperId") || "",
                        contactEmails: urlParams.get("contactEmails")
                            ? JSON.parse(urlParams.get("contactEmails"))
                            : [],
                        labelSets: "[]",
                        previousWorks: "[]",
                        addedDate: new Date().toISOString(),
                        folder: "",
                        readingStatus: "to-read",
                        isPlaceholder: false,
                        scratchpad: "",
                    };

                    // Debug logging for auto-add
                    console.log("Auto-add metadata received:", {
                        title: metadata.title,
                        authors: metadata.authors,
                        abstractLength: metadata.abstract.length,
                        url: metadata.url,
                        paperId: metadata.paperId,
                    });

                    // Check for duplicates
                    const isDuplicate = papers.some(
                        (paper) =>
                            paper.url === metadata.url ||
                            (paper.title &&
                                paper.title.toLowerCase() ===
                                    metadata.title.toLowerCase()),
                    );

                    if (isDuplicate) {
                        showMessage(
                            "Paper already exists in database",
                            "error",
                            true  // Allow stacking with sync messages
                        );
                        return;
                    }

                    // Create new paper
                    const newPaper = {
                        id: Date.now() + Math.random(),
                        title: metadata.title || `Paper ${metadata.paperId}`,
                        authors: metadata.authors || "Unknown Authors",
                        abstract: metadata.abstract || "No abstract available",
                        date: metadata.date || "Unknown date",
                        url: metadata.url,
                        labelSets: [],
                        previousWorks: [],
                        addedDate: new Date().toISOString(),
                        folder: "",
                        readingStatus: "referenced",
                        isPlaceholder: false,
                        scratchpad: "",
                        contactEmails: metadata.contactEmails || [],
                    };

                    await processExtensionPaper(metadata);
                }
            }

            // Helper function to process extension paper data (reduces code duplication)
            async function processExtensionPaper(metadata) {
                // Check for duplicates
                const isDuplicate = papers.some(
                    (paper) =>
                        paper.url === metadata.url ||
                        (paper.title &&
                            paper.title.toLowerCase() ===
                                metadata.title.toLowerCase()),
                );

                if (isDuplicate) {
                    showMessage(
                        "Paper already exists in database",
                        "error",
                        true  // Allow stacking with sync messages
                    );
                    cleanupUrlParameters();
                    return;
                }

                // Create new paper
                const newPaper = {
                    id: Date.now() + Math.random(),
                    title: metadata.title || `Paper ${metadata.paperId || 'Unknown'}`,
                    authors: metadata.authors || "Unknown Authors",
                    abstract: metadata.abstract || "No abstract available",
                    date: metadata.date || "Unknown date",
                    url: metadata.url,
                    labelSets: metadata.labelSets ? JSON.parse(metadata.labelSets) : [],
                    previousWorks: metadata.previousWorks ? JSON.parse(metadata.previousWorks) : [],
                    addedDate: metadata.addedDate || new Date().toISOString(),
                    folder: metadata.folder || "",
                    readingStatus: metadata.readingStatus || "to-read",
                    isPlaceholder: metadata.isPlaceholder || false,
                    scratchpad: metadata.scratchpad || "",
                    contactEmails: metadata.contactEmails ?
                        (typeof metadata.contactEmails === 'string' ?
                            JSON.parse(metadata.contactEmails) : metadata.contactEmails) : [],
                };

                // Add paper to database with immediate caching for extension reliability
                papers.push(newPaper);
                console.log(
                    `[AUTO-ADD DEBUG] ✅ Added paper: "${newPaper.title}" | Total papers: ${papers.length}`,
                );
                updatePaperCount();

                // For auto-add papers (from extension), save immediately to extension storage
                saveExtensionPaper(newPaper);
                console.log(
                    `[AUTO-ADD DEBUG] ✅ Instantly saved to extension storage`,
                );
                performSearch(); // Maintain current search state
                if (
                    document.getElementById("graph-display").style
                        .display !== "none"
                ) {
                    renderGraph();
                }

                // Try to refresh metadata if authors are unknown or abstract is short
                if (
                    newPaper.authors === "Unknown Authors" ||
                    newPaper.abstract.length < 200
                ) {
                    console.log(
                        "Attempting metadata refresh for incomplete data:",
                        {
                            authorsUnknown:
                                newPaper.authors === "Unknown Authors",
                            abstractShort: newPaper.abstract.length < 200,
                            abstractLength: newPaper.abstract.length,
                        },
                    );

                    // Attempt to refresh metadata using the URL
                    refreshMetadata(newPaper.id, newPaper.url, true).then(
                        (success) => {
                            if (success) {
                                showMessage(
                                    "Paper added and metadata refreshed successfully from browser extension!",
                                    "success",
                                );
                            } else {
                                showMessage(
                                    "Paper added from browser extension! Note: Some metadata may be incomplete due to CORS restrictions.",
                                    "info",
                                );
                            }
                        },
                    );
                } else {
                    // Show success message
                    showMessage(
                        "Paper added successfully from browser extension!",
                        "success",
                    );
                }

                // Switch to search tab to show the added paper
                switchTab("search");

                // Clean up URL parameters
                cleanupUrlParameters();
            }

            // Helper function to clean up URL parameters
            function cleanupUrlParameters() {
                if (window.history && window.history.replaceState) {
                    const url = new URL(window.location);
                    url.search = "";
                    window.history.replaceState(
                        {},
                        document.title,
                        url.toString(),
                    );
                }
            }

            // Load papers from storage with robust data merging
            async function loadPapers() {
                try {
                    console.log(
                        "Paper Manager loading papers with data merging...",
                    );

                    let indexedDBPapers = [];
                    let localStoragePapers = [];

                    // Step 0: Check for backup data immediately
                    const backupKeys = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith("cryptoPapers_backup")) {
                            backupKeys.push(key);
                        }
                    }

                    console.log(
                        `[LOAD DEBUG] Found ${backupKeys.length} backup keys: ${backupKeys.join(", ")}`,
                    );

                    // Initialize IndexedDB if not already done
                    if (!db) {
                        try {
                            await initDB();
                            console.log(
                                "[LOAD DEBUG] IndexedDB initialized successfully",
                            );
                        } catch (dbError) {
                            console.error(
                                "[LOAD ERROR] Failed to initialize IndexedDB:",
                                dbError,
                            );
                            showMessage(
                                "Warning: Database initialization failed, using localStorage only",
                                "warning",
                            );
                        }
                    }

                    // Step 1: Load extension papers first (highest priority - most recent)
                    let extensionPapers = [];
                    try {
                        const extensionStored = localStorage.getItem(
                            "cryptoExtensionPapers",
                        );
                        if (extensionStored) {
                            extensionPapers = JSON.parse(extensionStored);
                            console.log(
                                `[LOAD DEBUG] ✅ Found ${extensionPapers.length} extension papers waiting for sync`,
                            );
                        }
                    } catch (extensionError) {
                        console.error(
                            "[LOAD ERROR] Failed to load extension papers:",
                            extensionError,
                        );
                        extensionPapers = [];
                    }

                    // Step 2: Load from IndexedDB
                    if (db) {
                        try {
                            const transaction = db.transaction(
                                [PAPERS_STORE],
                                "readonly",
                            );
                            const store = transaction.objectStore(PAPERS_STORE);

                            indexedDBPapers = await new Promise(
                                (resolve, reject) => {
                                    const getAllRequest = store.getAll();
                                    getAllRequest.onsuccess = () => {
                                        const loadedPapers =
                                            getAllRequest.result || [];
                                        console.log(
                                            `[LOAD DEBUG] ✅ Loaded ${loadedPapers.length} papers from IndexedDB`,
                                        );
                                        resolve(loadedPapers);
                                    };
                                    getAllRequest.onerror = () => {
                                        console.error(
                                            "[LOAD ERROR] IndexedDB getAll failed:",
                                            getAllRequest.error,
                                        );
                                        reject(getAllRequest.error);
                                    };
                                },
                            );
                        } catch (indexedDBError) {
                            console.error(
                                "❌ IndexedDB load failed:",
                                indexedDBError,
                            );
                            indexedDBPapers = [];
                            showMessage(
                                "Warning: Failed to load from IndexedDB, using localStorage",
                                "warning",
                            );
                        }
                    } else {
                        console.log(
                            "[LOAD DEBUG] IndexedDB not available, skipping",
                        );
                    }

                    // Step 2: Load from localStorage (metadata + recent papers cache)
                    try {
                        // Try new metadata format first
                        const metadataStored = localStorage.getItem(
                            "cryptoPapersMetadata",
                        );
                        if (metadataStored) {
                            const metadata = JSON.parse(metadataStored);
                            console.log(
                                `[LOAD DEBUG] ✅ Found metadata for ${metadata.count} papers in localStorage`,
                            );

                            // Try to load recent papers cache for browser extension compatibility
                            const cacheStored =
                                localStorage.getItem("cryptoPapersCache");
                            if (cacheStored) {
                                localStoragePapers = JSON.parse(cacheStored);
                                console.log(
                                    `[LOAD DEBUG] ✅ Loaded ${localStoragePapers.length} papers from localStorage cache`,
                                );
                            } else {
                                localStoragePapers = [];
                            }
                        } else {
                            // Fallback: check for old full-data format
                            const oldStored =
                                localStorage.getItem("cryptoPapers");
                            if (oldStored) {
                                localStoragePapers = JSON.parse(oldStored);
                                console.log(
                                    `[LOAD DEBUG] ✅ Loaded ${localStoragePapers.length} papers from old localStorage format`,
                                );
                                // Migrate old data to new format
                                if (localStoragePapers.length > 0) {
                                    console.log(
                                        "[MIGRATION] Converting old localStorage format...",
                                    );
                                    saveToLocalStorage(); // This will save in new metadata format
                                    localStorage.removeItem("cryptoPapers"); // Clean up old format
                                }
                            } else {
                                console.log(
                                    "[LOAD DEBUG] No localStorage data found",
                                );
                                localStoragePapers = [];
                            }
                        }
                    } catch (localError) {
                        console.error(
                            "❌ localStorage load failed:",
                            localError,
                        );
                        localStoragePapers = [];
                        console.log("Will rely on IndexedDB for data");
                    }

                    // Step 3: Emergency backup recovery if no data in main sources
                    if (
                        indexedDBPapers.length === 0 &&
                        localStoragePapers.length === 0 &&
                        backupKeys.length > 0
                    ) {
                        console.log(
                            "[RECOVERY] No data in main sources, attempting backup recovery...",
                        );

                        // Try the most recent backup
                        const latestBackup = backupKeys.sort().pop();
                        try {
                            const backupData =
                                localStorage.getItem(latestBackup);
                            if (backupData) {
                                const backupPapers = JSON.parse(backupData);
                                localStoragePapers = backupPapers;
                                console.log(
                                    `[RECOVERY] ✅ Recovered ${backupPapers.length} papers from ${latestBackup}`,
                                );
                                showMessage(
                                    `Data recovered from backup: ${backupPapers.length} papers restored`,
                                    "success",
                                );

                                // Save recovered data as main data
                                localStorage.setItem(
                                    "cryptoPapers",
                                    backupData,
                                );
                            }
                        } catch (backupError) {
                            console.error(
                                "[RECOVERY] ❌ Failed to recover from backup:",
                                backupError,
                            );
                        }
                    }

                    // Step 4: Merge data sources - use the one with more papers, or merge if there are differences
                    if (
                        indexedDBPapers.length === 0 &&
                        localStoragePapers.length === 0
                    ) {
                        // No data anywhere
                        papers = [];
                        console.log(
                            "[LOAD DEBUG] ❌ No papers found in any storage",
                        );
                        showMessage(
                            "No papers found. Add your first paper to get started!",
                            "info",
                        );
                    } else if (
                        indexedDBPapers.length === 0 &&
                        localStoragePapers.length > 0
                    ) {
                        // Only localStorage has data
                        papers = localStoragePapers;
                        console.log(
                            `[LOAD DEBUG] Using localStorage data (${papers.length} papers) - IndexedDB empty`,
                        );
                        // Sync to IndexedDB in background
                        syncToIndexedDB().catch(console.error);
                    } else if (
                        indexedDBPapers.length > 0 &&
                        localStoragePapers.length === 0
                    ) {
                        // Only IndexedDB has data
                        papers = indexedDBPapers;
                        console.log(
                            `[LOAD DEBUG] Using IndexedDB data (${papers.length} papers) - localStorage empty`,
                        );
                        // Update localStorage
                        saveToLocalStorage();
                    } else {
                        // Both have data - ALWAYS merge to ensure no cache papers are lost (browser extension safety)
                        console.log(
                            `[MERGE DEBUG] IndexedDB: ${indexedDBPapers.length}, localStorage cache: ${localStoragePapers.length}`,
                        );

                        // Start with IndexedDB papers as base (most complete dataset)
                        const mergedPapers = [...indexedDBPapers];
                        const existingUrls = new Set(
                            indexedDBPapers.map((p) => p.url),
                        );
                        const existingIds = new Set(
                            indexedDBPapers.map((p) => p.id),
                        );

                        // Add extension papers first (highest priority)
                        let addedFromExtension = 0;
                        for (const extensionPaper of extensionPapers) {
                            if (
                                !existingUrls.has(extensionPaper.url) &&
                                !existingIds.has(extensionPaper.id)
                            ) {
                                mergedPapers.push(extensionPaper);
                                existingUrls.add(extensionPaper.url);
                                existingIds.add(extensionPaper.id);
                                addedFromExtension++;
                                console.log(
                                    `[MERGE DEBUG] Added extension paper: "${extensionPaper.title}"`,
                                );
                            }
                        }

                        // Add any papers from cache that aren't already included
                        let addedFromCache = 0;
                        for (const cachePaper of localStoragePapers) {
                            if (
                                !existingUrls.has(cachePaper.url) &&
                                !existingIds.has(cachePaper.id)
                            ) {
                                mergedPapers.push(cachePaper);
                                addedFromCache++;
                                console.log(
                                    `[MERGE DEBUG] Added cache paper: "${cachePaper.title}"`,
                                );
                            }
                        }

                        papers = mergedPapers;
                        console.log(
                            `[LOAD DEBUG] Merged data: ${indexedDBPapers.length} from IndexedDB + ${addedFromExtension} from extension + ${addedFromCache} from cache = ${papers.length} total papers`,
                        );

                        // Always update cache to reflect current state
                        saveToLocalStorage();
                    }

                    // Final validation after loading complete - ensure all papers have readingStatus
                    let fixedCount = 0;
                    papers.forEach((paper) => {
                        if (!paper.readingStatus) {
                            paper.readingStatus = "referenced";
                            fixedCount++;
                        }
                    });

                    if (fixedCount > 0) {
                        console.log(
                            `[LOAD VALIDATION] Fixed ${fixedCount} papers missing readingStatus`,
                        );
                        // Save the fix to storage
                        saveToLocalStorage();
                        syncToIndexedDB().catch(console.error);
                    }

                    console.log(
                        `[LOAD VALIDATION] Successfully loaded ${papers.length} papers from combined sources`,
                    );

                    console.log(
                        `[LOAD DEBUG] Final result: ${papers.length} papers loaded`,
                    );
                    if (papers.length > 0) {
                        console.log(
                            "Sample paper:",
                            papers[papers.length - 1].title,
                        );
                    }

                    // Ensure each paper has required fields
                    papers = papers.map((paper) => ({
                        ...paper,
                        id:
                            paper.id ||
                            Date.now() +
                                "_" +
                                Math.random().toString(36).substr(2, 9),
                        title: paper.title || "Untitled",
                        authors: paper.authors || "Unknown Authors",
                        abstract: paper.abstract || "",
                        date: paper.date || "Unknown date",
                        url: paper.url || "",
                        labelSets:
                            paper.labelSets ||
                            (paper.labels
                                ? [{ name: "", labels: paper.labels }]
                                : []),
                        previousWorks:
                            paper.previousWorks || paper.relatedPapers || [],
                        addedDate: paper.addedDate || new Date().toISOString(),
                        folder: paper.folder || "",
                        favorite: paper.favorite || false,
                        contactEmails: paper.contactEmails || [],
                        scratchpad: paper.scratchpad || "",
                        readingStatus: paper.readingStatus || "referenced",
                        isPlaceholder: paper.isPlaceholder || false,
                    }));

                    console.log(
                        `[LOAD DEBUG] After migration: ${papers.length} papers`,
                    );
                } catch (error) {
                    console.error("Error loading papers:", error);
                    papers = [];
                    showMessage("Error loading papers from database", "error");
                }
            }

            // Check for pending papers from browser extension
            async function checkExtensionPendingPapers() {
                try {
                    const pendingData = sessionStorage.getItem(
                        "pendingPaperFromExtension",
                    );
                    if (pendingData) {
                        console.log(
                            "Found pending paper from extension:",
                            pendingData,
                        );
                        const paperData = JSON.parse(pendingData);

                        // Clear the pending data
                        sessionStorage.removeItem("pendingPaperFromExtension");

                        // Check for duplicates
                        const isDuplicate = papers.some(
                            (paper) =>
                                paper.url === paperData.url ||
                                (paper.title &&
                                    paper.title.toLowerCase().trim() ===
                                        paperData.title.toLowerCase().trim()),
                        );

                        if (isDuplicate) {
                            showMessage(
                                "Paper already exists in database",
                                "error",
                            );
                            return;
                        }

                        // Create new paper
                        const newPaper = {
                            id: Date.now() + Math.random(),
                            title: paperData.title,
                            authors: paperData.authors,
                            abstract: paperData.abstract,
                            date: paperData.date || "Unknown date",
                            url: paperData.url,
                            labelSets: [],
                            previousWorks: [],
                            addedDate: new Date().toISOString(),
                            folder: "",
                            readingStatus: "referenced",
                            isPlaceholder: false,
                            scratchpad: "",
                            contactEmails: paperData.contactEmails || [],
                        };

                        // Add paper to database with immediate caching for extension reliability
                        papers.push(newPaper);
                        console.log(
                            `[EXTENSION DEBUG] ✅ Added paper: "${newPaper.title}" | Total papers: ${papers.length}`,
                        );
                        updatePaperCount();

                        // For extension papers, save immediately to extension storage
                        saveExtensionPaper(newPaper);
                        console.log(
                            `[EXTENSION DEBUG] ✅ Instantly saved to extension storage`,
                        );
                        performSearch(); // Maintain current search state
                        if (
                            document.getElementById("graph-display").style
                                .display !== "none"
                        ) {
                            renderGraph();
                        }

                        // Show success message
                        showMessage(
                            "Paper added successfully from browser extension!",
                            "success",
                        );
                    }
                } catch (error) {
                    console.warn(
                        "Error checking extension pending papers:",
                        error,
                    );
                }
            }

            // IndexedDB database management
            let db = null;
            const DB_NAME = "CryptoPapersDB";
            const DB_VERSION = 1;
            const PAPERS_STORE = "papers";
            const FOLDERS_STORE = "folders";

            // Initialize IndexedDB
            async function initDB() {
                // Request persistent storage to prevent data loss
                if ("storage" in navigator && "persist" in navigator.storage) {
                    try {
                        const persistent = await navigator.storage.persist();
                        console.log(
                            `Storage persistence: ${persistent ? "granted" : "denied"}`,
                        );
                        if (!persistent) {
                            console.warn(
                                "Storage persistence not granted - data may be lost on browser restart",
                            );
                            // Storage persistence warning removed for better startup performance
                        }
                    } catch (error) {
                        console.warn(
                            "Could not request storage persistence:",
                            error,
                        );
                    }
                }

                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);

                    request.onerror = () => {
                        console.error("IndexedDB error:", request.error);
                        reject(request.error);
                    };

                    request.onsuccess = () => {
                        db = request.result;
                        console.log("IndexedDB initialized successfully");
                        resolve(db);
                    };

                    request.onupgradeneeded = (event) => {
                        db = event.target.result;
                        console.log("Creating/upgrading IndexedDB schema");

                        // Create papers object store
                        if (!db.objectStoreNames.contains(PAPERS_STORE)) {
                            const papersStore = db.createObjectStore(
                                PAPERS_STORE,
                                { keyPath: "id" },
                            );
                            papersStore.createIndex("url", "url", {
                                unique: false,
                            });
                            papersStore.createIndex("title", "title", {
                                unique: false,
                            });
                            papersStore.createIndex("authors", "authors", {
                                unique: false,
                            });
                            papersStore.createIndex("date", "date", {
                                unique: false,
                            });
                            papersStore.createIndex("folder", "folder", {
                                unique: false,
                            });
                            papersStore.createIndex(
                                "readingStatus",
                                "readingStatus",
                                { unique: false },
                            );
                        }

                        // Create folders object store
                        if (!db.objectStoreNames.contains(FOLDERS_STORE)) {
                            db.createObjectStore(FOLDERS_STORE, {
                                keyPath: "name",
                            });
                        }
                    };
                });
            }

            // Hybrid localStorage approach: metadata + recent papers cache for browser extension
            function saveToLocalStorage() {
                try {
                    const timestamp = new Date().toISOString();

                    // Save essential metadata (always works - small size)
                    const essentialData = {
                        count: papers.length,
                        lastSaved: timestamp,
                        folders: folders,
                        version: "2.0",
                    };

                    localStorage.setItem(
                        "cryptoPapersMetadata",
                        JSON.stringify(essentialData),
                    );

                    // Try to save recent papers cache for browser extension fast access
                    try {
                        // Keep only recent papers (last 50 or papers from last 7 days) for extension cache
                        const sevenDaysAgo = new Date();
                        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

                        const recentPapers = papers
                            .filter((paper) => {
                                const addedDate = new Date(
                                    paper.addedDate || paper.date,
                                );
                                return addedDate > sevenDaysAgo;
                            })
                            .slice(-50); // Keep max 50 most recent papers

                        localStorage.setItem(
                            "cryptoPapersCache",
                            JSON.stringify(recentPapers),
                        );

                        console.log(
                            `[SAVE DEBUG] ✅ Saved metadata + ${recentPapers.length} recent papers cache at ${timestamp}`,
                        );
                    } catch (cacheError) {
                        console.log(
                            "[SAVE DEBUG] Could not save papers cache (non-critical):",
                            cacheError.message,
                        );
                        // Remove cache if it's too big, keep only metadata
                        localStorage.removeItem("cryptoPapersCache");
                    }

                    // Force UI update to reflect new count
                    const currentlyDisplayed = getCurrentlyFilteredPapers();
                    updateReadingStatusStats(currentlyDisplayed);

                    return true;
                } catch (error) {
                    console.error(
                        "LocalStorage metadata save failed (non-critical):",
                        error,
                    );
                    // This is no longer critical since IndexedDB is primary storage
                    console.log("Data is safe in IndexedDB");
                    return true; // Don't fail the save operation
                }
            }

            // Background IndexedDB sync (asynchronous, for persistence)
            async function syncToIndexedDB() {
                try {
                    const timestamp = new Date().toISOString();
                    console.log(
                        `[SYNC DEBUG] 🔄 Starting sync of ${papers.length} papers to IndexedDB at ${timestamp}`,
                    );

                    if (!db) {
                        await initDB();
                    }

                    const transaction = db.transaction(
                        [PAPERS_STORE],
                        "readwrite",
                    );
                    const store = transaction.objectStore(PAPERS_STORE);

                    // Clear existing data
                    await new Promise((resolve, reject) => {
                        const clearRequest = store.clear();
                        clearRequest.onsuccess = () => resolve();
                        clearRequest.onerror = () => reject(clearRequest.error);
                    });

                    // Add all papers
                    for (const paper of papers) {
                        await new Promise((resolve, reject) => {
                            const addRequest = store.add(paper);
                            addRequest.onsuccess = () => resolve();
                            addRequest.onerror = () => reject(addRequest.error);
                        });
                    }

                    await new Promise((resolve, reject) => {
                        transaction.oncomplete = () => {
                            console.log(
                                `[SYNC DEBUG] ✅ Successfully synced ${papers.length} papers to IndexedDB at ${new Date().toISOString()}`,
                            );
                            resolve();
                        };
                        transaction.onerror = () => reject(transaction.error);
                    });
                } catch (error) {
                    console.error(
                        "❌ Error syncing to IndexedDB (non-critical):",
                        error,
                    );
                    // Don't show error message for background sync failures
                    // Data is already safe in localStorage
                }
            }

            // Main save function - saves to cache + metadata, then syncs to IndexedDB
            async function savePapers() {
                // Step 1: Immediate save to localStorage cache/metadata (synchronous, reliable)
                const localSaveSuccess = saveToLocalStorage();

                if (!localSaveSuccess) {
                    console.error(
                        "Critical: Failed to save to localStorage cache",
                    );
                    // Try emergency save without cache
                    try {
                        localStorage.setItem(
                            "cryptoPapersEmergency",
                            JSON.stringify(papers.slice(-10)),
                        );
                        console.log("Emergency backup saved (last 10 papers)");
                    } catch (e) {
                        console.error("Even emergency save failed!", e);
                        return false;
                    }
                }

                // Step 2: Background sync to IndexedDB (asynchronous, for persistence)
                // Don't await this for regular saves - let it happen in the background
                syncToIndexedDB().catch((error) => {
                    console.log(
                        "Background IndexedDB sync failed (data is safe in cache):",
                        error,
                    );
                });

                // Step 3: Save a timestamped backup for critical operations (extension adds)
                // Only for recent papers to avoid localStorage bloat
                try {
                    const recentPapers = papers.filter((paper) => {
                        const addedDate = new Date(
                            paper.addedDate || paper.date,
                        );
                        const oneDayAgo = new Date();
                        oneDayAgo.setDate(oneDayAgo.getDate() - 1);
                        return addedDate > oneDayAgo;
                    });

                    if (recentPapers.length > 0) {
                        const timestamp = new Date().toISOString();
                        const backupKey = `cryptoPapers_backup_${timestamp}`;
                        localStorage.setItem(
                            backupKey,
                            JSON.stringify(recentPapers),
                        );

                        // Keep only the 3 most recent backups to avoid localStorage bloat
                        const allKeys = Object.keys(localStorage);
                        const backupKeys = allKeys
                            .filter((key) =>
                                key.startsWith("cryptoPapers_backup_"),
                            )
                            .sort();
                        while (backupKeys.length > 3) {
                            const oldestBackup = backupKeys.shift();
                            localStorage.removeItem(oldestBackup);
                        }
                    }
                } catch (backupError) {
                    console.log(
                        "Could not create recent papers backup:",
                        backupError,
                    );
                }

                return true;
            }

            // Validate data consistency between localStorage and in-memory array
            function validateDataConsistency() {
                try {
                    // Check for old format localStorage data (fallback only)
                    const oldData = localStorage.getItem("cryptoPapers");
                    if (oldData) {
                        console.log(
                            "[CONSISTENCY CHECK] Found old format localStorage data - migrating...",
                        );
                        const oldPapers = JSON.parse(oldData);

                        if (oldPapers.length > papers.length) {
                            console.warn(
                                `[CONSISTENCY WARNING] Old localStorage has more papers: ${oldPapers.length} vs ${papers.length}`,
                            );
                            papers = oldPapers;
                            performSearch();
                            renderPapers();
                            showMessage(
                                `Recovered ${oldPapers.length - papers.length} papers from old localStorage`,
                                "success",
                            );
                        }

                        // Migrate to new format and clean up
                        saveToLocalStorage();
                        localStorage.removeItem("cryptoPapers");
                        console.log(
                            "[CONSISTENCY FIX] Migrated old localStorage format to new metadata format",
                        );
                    } else {
                        console.log(
                            "[CONSISTENCY CHECK] Using new metadata-only localStorage format",
                        );
                    }
                } catch (error) {
                    console.error("[CONSISTENCY ERROR]", error);
                }

                // Check metadata consistency (new localStorage format)
                try {
                    const metadataStored = localStorage.getItem(
                        "cryptoPapersMetadata",
                    );
                    if (metadataStored) {
                        const metadata = JSON.parse(metadataStored);
                        const memoryCount = papers.length;
                        const metadataCount = metadata.count || 0;

                        if (memoryCount !== metadataCount) {
                            console.warn(
                                `[METADATA CONSISTENCY WARNING] Data mismatch: Memory has ${memoryCount} papers, metadata shows ${metadataCount} papers`,
                            );

                            // Update metadata to match current state
                            saveToLocalStorage();
                            console.log(
                                "[METADATA CONSISTENCY FIX] Updated metadata to match memory",
                            );
                        } else {
                            console.log(
                                `[METADATA CONSISTENCY CHECK] ✅ Metadata consistent: ${memoryCount} papers`,
                            );
                        }

                        // Check folders consistency from metadata
                        if (
                            metadata.folders &&
                            Array.isArray(metadata.folders)
                        ) {
                            const metadataFoldersCount =
                                metadata.folders.length;
                            const memoryFoldersCount = folders.length;

                            if (memoryFoldersCount !== metadataFoldersCount) {
                                console.warn(
                                    `[FOLDERS CONSISTENCY WARNING] Data mismatch: Memory has ${memoryFoldersCount} folders, metadata shows ${metadataFoldersCount} folders`,
                                );

                                // Update metadata to match current state
                                saveToLocalStorage();
                                console.log(
                                    "[FOLDERS CONSISTENCY FIX] Updated folder metadata to match memory",
                                );
                            } else {
                                console.log(
                                    `[FOLDERS CONSISTENCY CHECK] ✅ Folders consistent: ${memoryFoldersCount} folders`,
                                );
                            }
                        }
                    }
                } catch (metadataError) {
                    console.error(
                        "[METADATA CONSISTENCY ERROR]",
                        metadataError,
                    );
                }
            }

            async function loadFolders() {
                try {
                    if (!db) {
                        await initDB();
                    }

                    const transaction = db.transaction(
                        [FOLDERS_STORE],
                        "readonly",
                    );
                    const store = transaction.objectStore(FOLDERS_STORE);

                    folders = await new Promise((resolve, reject) => {
                        const getAllRequest = store.getAll();
                        getAllRequest.onsuccess = () => {
                            const loadedFolders = getAllRequest.result || [];
                            console.log(
                                `Loaded ${loadedFolders.length} folders from IndexedDB`,
                            );
                            resolve(loadedFolders);
                        };
                        getAllRequest.onerror = () =>
                            reject(getAllRequest.error);
                    });
                } catch (error) {
                    console.error(
                        "Error loading folders from IndexedDB:",
                        error,
                    );

                    // Fallback to localStorage
                    try {
                        const stored = localStorage.getItem("cryptoFolders");
                        folders = stored ? JSON.parse(stored) : [];
                        console.log(
                            `Loaded ${folders.length} folders from localStorage fallback`,
                        );

                        // Migrate to IndexedDB
                        if (folders.length > 0) {
                            await saveFolders();
                        }
                    } catch (fallbackError) {
                        console.error(
                            "Fallback load also failed:",
                            fallbackError,
                        );
                        folders = [];
                        showMessage("Error loading folders", "error");
                    }
                }
            }

            async function saveFolders() {
                try {
                    if (!db) {
                        await initDB();
                    }

                    const transaction = db.transaction(
                        [FOLDERS_STORE],
                        "readwrite",
                    );
                    const store = transaction.objectStore(FOLDERS_STORE);

                    // Clear existing folders
                    await new Promise((resolve, reject) => {
                        const clearRequest = store.clear();
                        clearRequest.onsuccess = () => resolve();
                        clearRequest.onerror = () => reject(clearRequest.error);
                    });

                    // Add all folders
                    for (const folder of folders) {
                        await new Promise((resolve, reject) => {
                            const addRequest = store.add(folder);
                            addRequest.onsuccess = () => resolve();
                            addRequest.onerror = () => reject(addRequest.error);
                        });
                    }

                    console.log(`Saved ${folders.length} folders to IndexedDB`);
                } catch (error) {
                    console.error("Error saving folders:", error);
                    showMessage("Error saving folders", "error");

                    // Fallback to localStorage
                    try {
                        localStorage.setItem(
                            "cryptoFolders",
                            JSON.stringify(folders),
                        );
                    } catch (fallbackError) {
                        console.error(
                            "Fallback save also failed:",
                            fallbackError,
                        );
                    }
                }
            }

            // Add new folder
            function addNewFolder() {
                const name = prompt("Enter folder name:");
                if (!name || !name.trim()) return;

                const folderName = name.trim();

                // Check if folder already exists
                if (
                    folders.some(
                        (f) =>
                            f.name === folderName && f.parent === currentFolder,
                    )
                ) {
                    showMessage(
                        "Folder with this name already exists",
                        "error",
                    );
                    return;
                }

                const folder = {
                    id: Date.now() + Math.random(),
                    name: folderName,
                    parent: currentFolder, // Current folder becomes parent
                    created: new Date().toISOString(),
                };

                folders.push(folder);
                saveFolders();
                renderFolders();
                populateFolderSelects();
                showMessage("Folder created successfully!", "success");
            }

            // Rename folder
            function renameFolder(folderId) {
                const folder = folders.find((f) => f.id === folderId);
                if (!folder) return;

                const newName = prompt("Enter new name:", folder.name);
                if (!newName || !newName.trim()) return;

                const folderName = newName.trim();

                // Check if folder with new name already exists in same parent
                if (
                    folders.some(
                        (f) =>
                            f.name === folderName &&
                            f.parent === folder.parent &&
                            f.id !== folderId,
                    )
                ) {
                    showMessage(
                        "Folder with this name already exists",
                        "error",
                    );
                    return;
                }

                folder.name = folderName;
                saveFolders();
                renderFolders();
                populateFolderSelects();
                showMessage("Folder renamed successfully!", "success");
            }

            // Delete folder
            function deleteFolder(folderId) {
                const folder = folders.find((f) => f.id === folderId);
                if (!folder) return;

                // Check if folder has papers
                const papersInFolder = papers.filter(
                    (p) => p.folder === folder.name,
                );
                const hasSubfolders = folders.some(
                    (f) => f.parent === folder.name,
                );

                let confirmMessage = `Delete folder "${folder.name}"?`;
                if (papersInFolder.length > 0) {
                    confirmMessage += `\n\nThis folder contains ${papersInFolder.length} paper(s). They will be moved to Root.`;
                }
                if (hasSubfolders) {
                    confirmMessage += `\n\nThis folder contains subfolders. They will be moved to the parent folder.`;
                }

                if (!confirm(confirmMessage)) return;

                // Move papers to Root
                papers.forEach((paper) => {
                    if (paper.folder === folder.name) {
                        paper.folder = "";
                    }
                });

                // Move subfolders to parent
                folders.forEach((f) => {
                    if (f.parent === folder.name) {
                        f.parent = folder.parent;
                    }
                });

                // Remove folder
                folders = folders.filter((f) => f.id !== folderId);

                // If we're currently viewing this folder, switch to root
                if (currentFolder === folder.name) {
                    currentFolder = "";
                }

                saveFolders();
                savePapers();
                renderFolders();
                performSearch(); // Re-run search to maintain current filters
                populateFolderSelects();
                showMessage("Folder deleted successfully!", "success");
            }

            // Select folder
            function selectFolder(folderName) {
                currentFolder = folderName;
                renderFolders();

                // Re-run the current search with the new folder context
                performSearch();

                // Update graph to show only filtered papers
                if (
                    document.getElementById("graph-display").style.display !==
                    "none"
                ) {
                    renderGraph();
                }
            }

            // Render folders tree
            function renderFolders() {
                const container = document.getElementById("folders-tree");
                if (!container) return;

                container.innerHTML = "";

                // Add Root folder
                const rootDiv = document.createElement("div");
                rootDiv.className = `folder-item root ${currentFolder === "" ? "selected" : ""}`;
                rootDiv.onclick = () => selectFolder("");

                rootDiv.innerHTML = `
                                <span class="folder-icon">📁</span>
                                <span class="folder-name">Root</span>
                            `;

                container.appendChild(rootDiv);

                // Render folder tree recursively
                function renderFolderTree(parentName, level = 0) {
                    const childFolders = folders.filter(
                        (f) => f.parent === parentName,
                    );

                    childFolders.forEach((folder) => {
                        const folderDiv = document.createElement("div");
                        folderDiv.className = `folder-item ${currentFolder === folder.name ? "selected" : ""}`;
                        folderDiv.style.marginLeft = `${(level + 1) * 20}px`;

                        folderDiv.innerHTML = `
                                        <span class="folder-icon">📁</span>
                                        <span class="folder-name">${escapeHtml(folder.name)}</span>
                                        <div class="folder-actions">
                                            <button class="folder-action-btn" title="Rename">
                                                ✏️
                                            </button>
                                            <button class="folder-action-btn" title="Delete">
                                                🗑️
                                            </button>
                                        </div>
                                    `;

                        // Add event listeners
                        const renameBtn = folderDiv.querySelector(
                            '.folder-action-btn[title="Rename"]',
                        );
                        const deleteBtn = folderDiv.querySelector(
                            '.folder-action-btn[title="Delete"]',
                        );

                        renameBtn.onclick = (event) => {
                            event.stopPropagation();
                            renameFolder(folder.id);
                        };

                        deleteBtn.onclick = (event) => {
                            event.stopPropagation();
                            deleteFolder(folder.id);
                        };

                        folderDiv.onclick = () => selectFolder(folder.name);
                        container.appendChild(folderDiv);

                        // Recursively render subfolders
                        renderFolderTree(folder.name, level + 1);
                    });
                }

                renderFolderTree("");
            }

            // Populate folder select dropdowns
            function populateFolderSelects() {
                const selects = document.querySelectorAll(
                    "#paper-folder, #edit-folder, #batchFolder",
                );

                selects.forEach((select) => {
                    if (!select) return;

                    const currentValue = select.value;
                    select.innerHTML = '<option value="">Root</option>';

                    // Add folders in alphabetical order
                    const sortedFolders = [...folders].sort((a, b) =>
                        a.name.localeCompare(b.name),
                    );
                    sortedFolders.forEach((folder) => {
                        const option = document.createElement("option");
                        option.value = folder.name;
                        option.textContent = folder.name;
                        select.appendChild(option);
                    });

                    // Restore previous value if it still exists
                    if (
                        currentValue &&
                        [...select.options].some(
                            (opt) => opt.value === currentValue,
                        )
                    ) {
                        select.value = currentValue;
                    }
                });
            }

            // Switch between tabs
            function switchTab(tabName) {
                try {
                    document
                        .querySelectorAll(".tab")
                        .forEach((tab) => tab.classList.remove("active"));
                    document
                        .querySelectorAll(".tab-content")
                        .forEach((content) =>
                            content.classList.remove("active"),
                        );

                    const tabButton = document.querySelector(
                        `[onclick="switchTab('${tabName}')"]`,
                    );
                    const tabContent = document.getElementById(
                        `${tabName}-tab`,
                    );

                    if (tabButton) {
                        tabButton.classList.add("active");
                    } else {
                        console.warn(`Tab button for '${tabName}' not found`);
                    }

                    if (tabContent) {
                        tabContent.classList.add("active");
                    } else {
                        console.warn(`Tab content for '${tabName}' not found`);
                    }
                } catch (error) {
                    console.error(
                        `Error switching to tab '${tabName}':`,
                        error,
                    );
                }
            }

            // Render label selectors
            function renderLabels(containerId, mode, labelSetIndex = null) {
                const container = document.getElementById(containerId);
                if (!container) return;

                container.innerHTML = "";

                if (
                    !labelCategories ||
                    Object.keys(labelCategories).length === 0
                ) {
                    return;
                }

                Object.entries(labelCategories).forEach(
                    ([category, labels]) => {
                        const categoryDiv = document.createElement("div");
                        categoryDiv.className = "label-category";

                        const title = document.createElement("h4");
                        title.innerHTML = `
                                        <span>${category}</span>
                                        <span class="label-category-arrow">▶</span>
                                    `;

                        const optionsDiv = document.createElement("div");
                        optionsDiv.className = "label-options collapsed";

                        // Add click handler for expand/collapse
                        title.onclick = (event) => {
                            event.stopPropagation();
                            const arrow = title.querySelector(
                                ".label-category-arrow",
                            );
                            if (optionsDiv.classList.contains("collapsed")) {
                                optionsDiv.classList.remove("collapsed");
                                arrow.textContent = "▼";
                                arrow.classList.add("expanded");
                            } else {
                                optionsDiv.classList.add("collapsed");
                                arrow.textContent = "▶";
                                arrow.classList.remove("expanded");
                            }
                        };

                        labels.forEach((label) => {
                            const chip = document.createElement("span");
                            chip.className = "label-chip";
                            chip.textContent = label;
                            chip.onclick = () =>
                                toggleLabel(label, mode, chip, labelSetIndex);

                            // Add annotation indicator for annotatable labels
                            if (annotatableLabels.has(label)) {
                                chip.style.position = "relative";
                                const indicator =
                                    document.createElement("span");
                                indicator.textContent = "✏️";
                                indicator.style.fontSize = "0.7em";
                                indicator.style.marginLeft = "4px";
                                chip.appendChild(indicator);
                            }

                            optionsDiv.appendChild(chip);
                        });

                        categoryDiv.appendChild(title);
                        categoryDiv.appendChild(optionsDiv);
                        container.appendChild(categoryDiv);
                    },
                );
            }

            // Toggle label selection
            function toggleLabel(
                label,
                mode,
                chipElement,
                labelSetIndex = null,
            ) {
                if (mode === "add" || mode === "edit" || mode === "bulk" || mode === "bulk-remove") {
                    if (chipElement.classList.contains("selected")) {
                        chipElement.classList.remove("selected");

                        // Remove annotation if exists
                        const setId =
                            labelSetIndex !== null
                                ? `${mode}-label-set-${labelSetIndex}`
                                : null;
                        if (setId && annotatableLabels.has(label)) {
                            const annotationInput = document.getElementById(
                                `${setId}-annotation-${label.replace(/[^a-zA-Z0-9-_]/g, "-")}`,
                            );
                            if (annotationInput) {
                                annotationInput.remove();
                            }
                        }
                    } else {
                        chipElement.classList.add("selected");

                        // Add annotation input if this is an annotatable label
                        if (
                            annotatableLabels.has(label) &&
                            labelSetIndex !== null
                        ) {
                            showAnnotationInput(label, mode, labelSetIndex);
                        }
                    }
                } else if (mode === "search") {
                    if (chipElement.classList.contains("selected")) {
                        chipElement.classList.remove("selected");
                        chipElement.classList.add("excluded");

                        // Handle annotated labels
                        if (annotatableLabels.has(label)) {
                            const annotation = getSearchAnnotation(label);
                            const searchLabel = annotation
                                ? `${label} (${annotation})`
                                : label;
                            searchFilters.included.delete(searchLabel);
                            searchFilters.excluded.add(searchLabel);
                        } else {
                            searchFilters.included.delete(label);
                            searchFilters.excluded.add(label);
                        }
                    } else if (chipElement.classList.contains("excluded")) {
                        chipElement.classList.remove("excluded");

                        // Handle annotated labels
                        if (annotatableLabels.has(label)) {
                            const annotation = getSearchAnnotation(label);
                            const searchLabel = annotation
                                ? `${label} (${annotation})`
                                : label;
                            searchFilters.excluded.delete(searchLabel);
                        } else {
                            searchFilters.excluded.delete(label);
                        }
                    } else {
                        chipElement.classList.add("selected");

                        // Handle annotated labels - show annotation input for search
                        if (annotatableLabels.has(label)) {
                            showSearchAnnotationInput(label, chipElement);
                        }

                        // Handle annotated labels
                        if (annotatableLabels.has(label)) {
                            const annotation = getSearchAnnotation(label);
                            const searchLabel = annotation
                                ? `${label} (${annotation})`
                                : label;
                            searchFilters.included.add(searchLabel);
                        } else {
                            searchFilters.included.add(label);
                        }
                    }

                    updateSearchFiltersDisplay();

                    // Invalidate search cache when filters change
                    invalidateSearchCache();

                    performSearch();
                }
            }

            // Show annotation input for annotatable labels
            function showAnnotationInput(label, mode, labelSetIndex) {
                const setId = `${mode}-label-set-${labelSetIndex}`;
                const labelsContainer = document.getElementById(
                    `${setId}-labels`,
                );
                const annotationId = `${setId}-annotation-${label.replace(/[^a-zA-Z0-9-_]/g, "-")}`;

                // Check if annotation input already exists
                if (document.getElementById(annotationId)) return;

                const annotationDiv = document.createElement("div");
                annotationDiv.id = annotationId;
                annotationDiv.style.marginTop = "8px";
                annotationDiv.style.padding = "8px";
                annotationDiv.style.background = "rgba(255, 255, 255, 0.9)";
                annotationDiv.style.borderRadius = "4px";
                annotationDiv.style.border = "1px solid #ddd";

                annotationDiv.innerHTML = `
                                <label style="display: block; font-size: 0.9em; margin-bottom: 4px; color: #555;">
                                    Annotation for "${label}":
                                </label>
                                <input type="text" style="width: 100%; padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em;"
                                       placeholder="e.g., PSI, AES, ..." data-label="${label}">
                            `;

                labelsContainer.appendChild(annotationDiv);
            }

            // Import database from JSON file
            function importDatabase(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const data = JSON.parse(e.target.result);

                        if (data.papers && Array.isArray(data.papers)) {
                            const isFullExport = data.isFullExport || false;
                            let confirmMessage = `Import ${data.papers.length} papers?`;

                            if (isFullExport) {
                                confirmMessage = `Import ${data.papers.length} papers${data.folders ? ` and ${data.folders.length} folders` : ""}?\n\nWARNING: This will overwrite your scratchpad notes, reading status, favorites, and folders.`;
                            } else {
                                confirmMessage += "\n\nThis will preserve your existing scratchpad notes, reading status, favorites, and folders.";
                            }

                            const confirmed = confirm(confirmMessage);

                            if (confirmed) {
                                // Store current personal data if not doing full import
                                const currentPersonalData = new Map();
                                if (!isFullExport) {
                                    papers.forEach(paper => {
                                        currentPersonalData.set(paper.id, {
                                            scratchpad: paper.scratchpad || "",
                                            readingStatus: paper.readingStatus || "referenced",
                                            favorite: paper.favorite || false,
                                            folderId: paper.folderId || ""
                                        });
                                    });
                                }

                                papers = data.papers.map((paper) => {
                                    const baseData = {
                                        ...paper,
                                        labelSets:
                                            paper.labelSets ||
                                            (paper.labels
                                                ? [
                                                      {
                                                          name: "",
                                                          labels: paper.labels,
                                                      },
                                                  ]
                                                : []),
                                        contactEmails: paper.contactEmails || [],
                                    };

                                    // Add personal data
                                    if (isFullExport) {
                                        // Use data from file
                                        baseData.scratchpad = paper.scratchpad || "";
                                        baseData.readingStatus = paper.readingStatus || "referenced";
                                        baseData.favorite = paper.favorite || false;
                                        baseData.folderId = paper.folderId || "";
                                    } else {
                                        // Preserve existing personal data or use defaults
                                        const personalData = currentPersonalData.get(paper.id);
                                        if (personalData) {
                                            baseData.scratchpad = personalData.scratchpad;
                                            baseData.readingStatus = personalData.readingStatus;
                                            baseData.favorite = personalData.favorite;
                                            baseData.folderId = personalData.folderId;
                                        } else {
                                            baseData.scratchpad = "";
                                            baseData.readingStatus = "referenced";
                                            baseData.favorite = false;
                                            baseData.folderId = "";
                                        }
                                    }

                                    return baseData;
                                });

                                // Handle folders
                                if (isFullExport && data.folders) {
                                    folders = data.folders;
                                } else if (!isFullExport) {
                                    // Keep existing folders
                                }

                                // Reset original database for change tracking
                                originalDatabase = JSON.parse(JSON.stringify(data));
                                changeTracker = {
                                    addedPapers: new Set(),
                                    modifiedPapers: new Map(),
                                    deletedPapers: new Set(),
                                    modifiedLabels: new Map()
                                };

                                savePapers();
                                saveFolders();
                                renderFolders();
                                performSearch(); // Re-run search to maintain current view
                                if (
                                    document.getElementById("graph-display")
                                        .style.display !== "none"
                                ) {
                                    renderGraph();
                                }
                                updatePreviousWorksSelect();
                                populateFolderSelects();

                                showMessage(
                                    `Successfully imported ${papers.length} papers${folders.length > 0 ? ` and ${folders.length} folders` : ""}!`,
                                    "success",
                                );
                            }
                        } else {
                            throw new Error("Invalid file format");
                        }
                    } catch (error) {
                        showMessage(
                            "Error importing file: " + error.message,
                            "error",
                        );
                    }

                    // Reset file input
                    event.target.value = "";
                };

                reader.readAsText(file);
            }

            // Make function globally available for module script
            window.importDatabase = importDatabase;

            // Get search annotation for a label
            function getSearchAnnotation(label) {
                const annotationInput = document.getElementById(
                    `search-annotation-${label.replace(/[^a-zA-Z0-9-_]/g, "-")}`,
                );
                return annotationInput ? annotationInput.value.trim() : "";
            }

            // Show annotation input for search
            function showSearchAnnotationInput(label, chipElement) {
                const annotationId = `search-annotation-${label.replace(/[^a-zA-Z0-9-_]/g, "-")}`;

                // Check if annotation input already exists
                if (document.getElementById(annotationId)) return;

                const annotationDiv = document.createElement("div");
                annotationDiv.id = annotationId;
                annotationDiv.className = "annotation-popup";

                const rect = chipElement.getBoundingClientRect();
                annotationDiv.style.top =
                    rect.bottom + window.scrollY + 5 + "px";
                annotationDiv.style.left = rect.left + "px";

                annotationDiv.innerHTML = `
                                <div style="font-size: 0.9em; margin-bottom: 8px; color: #333; font-weight: 500;">
                                    Search annotation for "${label}":
                                </div>
                                <input type="text" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; margin-bottom: 8px;"
                                       placeholder="Leave empty for any, or specify (e.g., PSI)"
                                       onkeydown="if(event.key==='Enter') updateSearchAnnotation('${label}', this.value)"
                                       onfocus="this.select()">
                                <div style="text-align: right;">
                                    <button class="annotation-ok-btn"
                                            style="background: #667eea; color: white; border: none; padding: 4px 12px; border-radius: 4px; cursor: pointer; margin-right: 4px;">
                                        OK
                                    </button>
                                    <button onclick="updateSearchAnnotation('${label}', '')"
                                            style="background: #6c757d; color: white; border: none; padding: 4px 12px; border-radius: 4px; cursor: pointer;">
                                        Any
                                    </button>
                                </div>
                            `;

                // Add event listener for OK button after creating the element
                const okButton = annotationDiv.querySelector('.annotation-ok-btn');
                okButton.addEventListener('click', () => {
                    const input = document.querySelector(`#${CSS.escape(annotationId)} input`);
                    updateSearchAnnotation(label, input ? input.value : '');
                });

                document.body.appendChild(annotationDiv);

                // Focus the input
                setTimeout(() => {
                    const input = annotationDiv.querySelector("input");
                    if (input) input.focus();
                }, 50);

                // Close on click outside
                setTimeout(() => {
                    const closeHandler = (e) => {
                        if (!annotationDiv.contains(e.target)) {
                            updateSearchAnnotation(
                                label,
                                annotationDiv.querySelector("input").value,
                            );
                            document.removeEventListener("click", closeHandler);
                        }
                    };
                    document.addEventListener("click", closeHandler);
                }, 100);
            }

            // Update search annotation
            function updateSearchAnnotation(label, annotation) {
                const annotationDiv = document.getElementById(
                    `search-annotation-${label.replace(/[^a-zA-Z0-9-_]/g, "-")}`,
                );
                if (annotationDiv) {
                    annotationDiv.remove();
                }

                // Update search filters
                const oldPlainLabel = label;
                const oldAnnotatedLabel = `${label} (${annotation})`;

                // Remove any existing entries
                searchFilters.included.delete(oldPlainLabel);
                searchFilters.excluded.delete(oldPlainLabel);

                // Add the new search term
                const searchLabel = annotation
                    ? `${label} (${annotation})`
                    : label;
                searchFilters.included.add(searchLabel);

                updateSearchFiltersDisplay();
                performSearch();
            }

            // Update the display of active search filters
            function updateSearchFiltersDisplay() {
                const container = document.getElementById(
                    "active-search-filters",
                );
                if (!container) return;

                const filters = [];

                // Add included filters
                searchFilters.included.forEach((label) => {
                    filters.push(
                        `<span class="search-filter-display">✓ ${escapeHtml(label)}</span>`,
                    );
                });

                // Add excluded filters
                searchFilters.excluded.forEach((label) => {
                    filters.push(
                        `<span class="search-filter-display search-filter-excluded">✗ ${escapeHtml(label)}</span>`,
                    );
                });

                if (filters.length > 0) {
                    container.innerHTML = `<div style="font-size: 0.9em; color: #555; margin-bottom: 4px;">Active filters:</div>${filters.join("")}`;
                } else {
                    container.innerHTML = "";
                }
            }

            // Initialize label sets for a mode
            function initializeLabelSets(mode) {
                if (mode === "add") {
                    addNewLabelSet("add");
                }
            }

            // Add a new label set
            function addNewLabelSet(mode) {
                const container = document.getElementById(`${mode}-label-sets`);
                if (!container) return;

                const setIndex = container.children.length;
                const setId = `${mode}-label-set-${setIndex}`;

                const labelSetDiv = document.createElement("div");
                labelSetDiv.className = "label-set";
                labelSetDiv.id = setId;

                labelSetDiv.innerHTML = `
                                <div class="label-set-header">
                                    <div class="label-set-name">
                                        <input type="text" placeholder="Label set name (optional) - e.g., 'Main Protocol', 'Variant'"
                                               id="${setId}-name" style="width: 250px;">
                                    </div>
                                    <button type="button" class="label-set-remove" onclick="removeLabelSet('${setId}')"
                                            ${setIndex === 0 ? 'style="visibility: hidden;"' : ""}>
                                        ×
                                    </button>
                                </div>
                                <div class="label-selector" id="${setId}-labels">
                                    <!-- Labels will be populated -->
                                </div>
                            `;

                container.appendChild(labelSetDiv);
                console.log(
                    `[LABEL SETS] Adding label set for mode: ${mode}, setId: ${setId}`,
                );
                renderLabels(`${setId}-labels`, mode, setIndex);
            }

            // Remove a label set
            function removeLabelSet(setId) {
                const element = document.getElementById(setId);
                if (element) {
                    element.remove();
                }
            }

            // Get all label sets from the form
            function getLabelSets(mode) {
                const container = document.getElementById(`${mode}-label-sets`);
                if (!container) return [];

                const labelSets = [];
                Array.from(container.children).forEach((setElement, index) => {
                    if (!setElement.classList.contains("label-set")) return;

                    const nameInput =
                        setElement.querySelector('input[type="text"]');
                    const name = nameInput ? nameInput.value.trim() : "";

                    const selectedLabels = [];
                    const annotations = {};

                    setElement
                        .querySelectorAll(".label-chip.selected")
                        .forEach((chip) => {
                            const labelText = chip.textContent
                                .replace("✏️", "")
                                .trim();
                            selectedLabels.push(labelText);

                            // Check for annotation
                            if (annotatableLabels.has(labelText)) {
                                const setId = setElement.id;
                                const annotationId = `${setId}-annotation-${labelText.replace(/[^a-zA-Z0-9-_]/g, "-")}`;
                                const annotationInput = document.querySelector(
                                    `#${CSS.escape(annotationId)} input`,
                                );
                                if (
                                    annotationInput &&
                                    annotationInput.value.trim()
                                ) {
                                    annotations[labelText] =
                                        annotationInput.value.trim();
                                }
                            }
                        });

                    if (selectedLabels.length > 0) {
                        const labelSet = {
                            name: name,
                            labels: selectedLabels,
                        };

                        if (Object.keys(annotations).length > 0) {
                            labelSet.annotations = annotations;
                        }

                        labelSets.push(labelSet);
                    }
                });

                return labelSets;
            }

            // Set label sets in the form
            function setLabelSets(mode, labelSets) {
                const container = document.getElementById(`${mode}-label-sets`);
                if (!container) return;

                // Clear existing sets
                container.innerHTML = "";

                // Add each label set
                labelSets.forEach((labelSet, index) => {
                    addNewLabelSet(mode);

                    // Set the name
                    const setId = `${mode}-label-set-${index}`;
                    const nameInput = document.getElementById(`${setId}-name`);
                    if (nameInput) {
                        nameInput.value = labelSet.name || "";
                    }

                    // Set selected labels
                    setTimeout(() => {
                        labelSet.labels.forEach((label) => {
                            const chips = document.querySelectorAll(
                                `#${setId}-labels .label-chip`,
                            );
                            chips.forEach((chipElement) => {
                                const chipLabel = chipElement.textContent
                                    .replace("✏️", "")
                                    .trim();
                                if (chipLabel === label) {
                                    chipElement.classList.add("selected");

                                    // Add annotation if exists
                                    if (
                                        annotatableLabels.has(label) &&
                                        labelSet.annotations &&
                                        labelSet.annotations[label]
                                    ) {
                                        showAnnotationInput(label, mode, index);
                                        setTimeout(() => {
                                            const annotationId = `${setId}-annotation-${label.replace(/[^a-zA-Z0-9-_]/g, "-")}`;
                                            const annotationInput =
                                                document.querySelector(
                                                    `#${annotationId} input`,
                                                );
                                            if (annotationInput) {
                                                annotationInput.value =
                                                    labelSet.annotations[label];
                                            }
                                        }, 50);
                                    }
                                }
                            });
                        });
                    }, 200);
                });

                // Ensure at least one label set exists
                if (labelSets.length === 0) {
                    addNewLabelSet(mode);
                }
            }

            // Initialize bulk remove label sets
            function initializeBulkRemoveLabelSets() {
                const container = document.getElementById("bulk-remove-label-sets");
                if (!container) return;

                // Clear existing content
                container.innerHTML = "";

                // Add a single label set for bulk remove
                const labelSetDiv = document.createElement("div");
                labelSetDiv.className = "label-set";
                labelSetDiv.id = "bulk-remove-label-set-0";

                labelSetDiv.innerHTML = `
                    <div class="label-set-header">
                        <div class="label-set-name">
                            <input type="text" placeholder="Label set name (optional)"
                                   id="bulk-remove-label-set-0-name" style="width: 250px;">
                        </div>
                    </div>
                    <div class="label-selector" id="bulk-remove-label-set-0-labels">
                        <!-- Labels will be populated -->
                    </div>
                `;

                container.appendChild(labelSetDiv);
                renderLabels("bulk-remove-label-set-0-labels", "bulk-remove", 0);
            }

            // Fetch paper metadata from ePrint
            async function fetchPaperMetadata() {
                const url = document.getElementById("eprint-url").value.trim();
                if (!url) {
                    showMessage("Please enter a paper URL", "error");
                    return;
                }

                try {
                    showMessage("Fetching metadata...", "info");

                    // Detect URL type and validate format
                    let paperId = "";
                    let urlType = "";

                    const eprintMatch = url.match(
                        /eprint\.iacr\.org\/(\d{4}\/\d+)$/,
                    );
                    const springerMatch = url.match(
                        /link\.springer\.com\/chapter\/10\.1007\/(.+)$/,
                    );
                    const acmMatch = url.match(
                        /dl\.acm\.org\/doi\/10\.1145\/(.+)$/,
                    );
                    const ieeeMatch = url.match(
                        /ieeexplore\.ieee\.org\/document\/(\d+)/,
                    );

                    if (eprintMatch) {
                        paperId = eprintMatch[1];
                        urlType = "eprint";
                    } else if (springerMatch) {
                        paperId = springerMatch[1];
                        urlType = "springer";
                    } else if (acmMatch) {
                        paperId = acmMatch[1];
                        urlType = "acm";
                    } else if (ieeeMatch) {
                        paperId = ieeeMatch[1];
                        urlType = "ieee";
                    } else {
                        throw new Error(
                            "Unsupported URL format. Expected: https://eprint.iacr.org/YYYY/NNNN, https://link.springer.com/chapter/10.1007/..., https://dl.acm.org/doi/10.1145/..., or https://ieeexplore.ieee.org/document/NNNN",
                        );
                    }

                    // Try direct fetch first (works if CORS is disabled or local server)
                    try {
                        const response = await fetch(url, {
                            mode: "cors",
                            headers: {
                                Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                                "User-Agent":
                                    "Mozilla/5.0 (compatible; Paper Manager)",
                            },
                        });
                        if (response.ok) {
                            const html = await response.text();

                            // Parse the HTML directly
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(
                                html,
                                "text/html",
                            );

                            // Extract metadata from the HTML
                            const metadata = parseHtmlMetadata(
                                doc,
                                paperId,
                                urlType,
                            );

                            // Populate form with extracted metadata
                            document.getElementById("paper-title").value =
                                metadata.title;
                            document.getElementById("paper-authors").value =
                                metadata.authors;
                            document.getElementById("paper-abstract").value =
                                metadata.abstract;
                            document.getElementById("paper-date").value =
                                metadata.date;

                            // Store contact emails for later use
                            if (
                                metadata.contactEmails &&
                                metadata.contactEmails.length > 0
                            ) {
                                window.currentPaperContactEmails =
                                    metadata.contactEmails;
                                showMessage(
                                    `Metadata fetched successfully! Found ${metadata.contactEmails.length} contact email${metadata.contactEmails.length > 1 ? "s" : ""}`,
                                    "success",
                                );
                            } else {
                                showMessage(
                                    "Metadata fetched successfully!",
                                    "success",
                                );
                            }

                            document.getElementById(
                                "metadata-form",
                            ).style.display = "block";
                            updatePreviousWorksSelect();
                            return;
                        }
                    } catch (fetchError) {
                        console.log(
                            "Direct fetch failed (CORS blocked):",
                            fetchError.message,
                        );

                        // Provide specific guidance based on URL type
                        if (urlType === "springer") {
                            showMessage(
                                "⚠️ Springer Nature blocks direct access. Please use manual parsing: 1) Open the paper page, 2) Copy all text (Ctrl+A, Ctrl+C), 3) Paste below and click Parse Content.",
                                "info",
                            );
                        }
                    }

                    // Fallback: Show manual entry instructions with solutions
                    const corsMessage =
                        urlType === "springer"
                            ? "⚠️ Springer Nature blocks direct fetching (stricter CORS than ePrint). Please use manual parsing below - copy the entire page content and paste it."
                            : urlType === "acm"
                              ? "⚠️ ACM Digital Library blocks direct fetching. Please use manual parsing below - copy the entire page content and paste it."
                              : "⚠️ Browser security blocks direct fetching. Solutions: 1) Use Chrome with --disable-web-security flag, 2) Install CORS extension, or 3) Use manual parsing below.";
                    showMessage(corsMessage, "info");

                    // Pre-fill with paper ID for convenience
                    if (urlType === "eprint") {
                        document.getElementById("paper-title").value =
                            `Paper ${paperId}`;
                    } else if (urlType === "springer") {
                        document.getElementById("paper-title").value =
                            `Springer Paper`;
                    } else if (urlType === "acm") {
                        document.getElementById("paper-title").value =
                            `ACM Paper`;
                    } else if (urlType === "ieee") {
                        document.getElementById("paper-title").value =
                            `IEEE Paper`;
                    }
                    document.getElementById("paper-date").value = "";

                    document.getElementById("metadata-form").style.display =
                        "block";
                    updatePreviousWorksSelect();

                    // Show the manual parser
                    document.getElementById("manual-parser").style.display =
                        "block";
                } catch (error) {
                    console.log("Fetch error:", error);
                    showMessage(error.message, "error");

                    // Still show the form for manual entry
                    if (urlType === "eprint") {
                        document.getElementById("paper-title").value =
                            `Paper ${paperId}`;
                    } else if (urlType === "springer") {
                        document.getElementById("paper-title").value =
                            `Springer Paper`;
                    } else if (urlType === "acm") {
                        document.getElementById("paper-title").value =
                            `ACM Paper`;
                    } else if (urlType === "ieee") {
                        document.getElementById("paper-title").value =
                            `IEEE Paper`;
                    }
                    document.getElementById("paper-date").value = "";

                    document.getElementById("metadata-form").style.display =
                        "block";
                    updatePreviousWorksSelect();
                }
            }

            // Parse metadata from HTML DOM (when direct fetch works)
            function parseHtmlMetadata(doc, paperId, urlType = "eprint") {
                let title = "";
                let authors = "";
                let abstract = "";
                let contactEmails = [];
                let date = "Unknown date";

                if (urlType === "acm") {
                    // Parse ACM Digital Library metadata

                    // Extract title from h1 with property="name" first
                    const titleElement = doc.querySelector(
                        'h1[property="name"]',
                    );
                    if (titleElement) {
                        title = titleElement.textContent.trim();
                    } else {
                        // Fallback: Extract title from page title (remove " | Proceedings of..." suffix)
                        const titleElement2 = doc.querySelector("title");
                        if (titleElement2) {
                            title = titleElement2.textContent
                                .split("|")[0]
                                .trim();
                        }
                    }

                    // Extract authors from structured data
                    const authorElements = doc.querySelectorAll(
                        '[property="author"][typeof="Person"]',
                    );
                    const authorList = [];
                    authorElements.forEach((authorEl) => {
                        const givenName = authorEl.querySelector(
                            '[property="givenName"]',
                        );
                        const familyName = authorEl.querySelector(
                            '[property="familyName"]',
                        );
                        if (givenName && familyName) {
                            const fullName = `${givenName.textContent.trim()} ${familyName.textContent.trim()}`;
                            authorList.push(fullName);
                        }
                    });

                    // Fallback: try alternative author selector patterns
                    if (authorList.length === 0) {
                        const authorElements2 = doc.querySelectorAll(
                            '.contributors [property="author"]',
                        );
                        authorElements2.forEach((authorEl) => {
                            const givenName = authorEl.querySelector(
                                '[property="givenName"]',
                            );
                            const familyName = authorEl.querySelector(
                                '[property="familyName"]',
                            );
                            if (givenName && familyName) {
                                const fullName = `${givenName.textContent.trim()} ${familyName.textContent.trim()}`;
                                authorList.push(fullName);
                            }
                        });
                    }

                    if (authorList.length > 0) {
                        authors = authorList.join(", ");
                    }

                    // Extract abstract from the abstract section
                    const abstractSection = doc.querySelector(
                        '#abstract[property="abstract"]',
                    );
                    if (abstractSection) {
                        // Get all paragraph content including list items
                        const allTextContent = abstractSection.textContent
                            .replace(/\s*Abstract\s*/i, "") // Remove "Abstract" heading
                            .replace(/\s+/g, " ") // Normalize whitespace
                            .trim();

                        if (allTextContent && allTextContent.length > 50) {
                            abstract = allTextContent;
                        }
                    }

                    // Fallback: try alternative abstract selectors
                    if (!abstract || abstract.length < 50) {
                        const abstractSection2 = doc.querySelector(
                            '[property="abstract"]',
                        );
                        if (abstractSection2) {
                            const paragraphs =
                                abstractSection2.querySelectorAll(
                                    '[role="paragraph"]',
                                );
                            const abstractParts = [];
                            paragraphs.forEach((p) => {
                                const text = p.textContent.trim();
                                if (text) {
                                    abstractParts.push(text);
                                }
                            });
                            if (abstractParts.length > 0) {
                                abstract = abstractParts.join(" ").trim();
                            }
                        }
                    }

                    // Extract date from publication date span
                    const dateElement = doc.querySelector(
                        ".core-date-published",
                    );
                    if (dateElement) {
                        const dateText = dateElement.textContent.trim();
                        const parsedDate = new Date(dateText);
                        if (!isNaN(parsedDate)) {
                            date = parsedDate.toISOString().split("T")[0];
                        }
                    }
                } else if (urlType === "springer") {
                    // Parse Springer Nature metadata

                    // Extract title from page title (remove " | SpringerLink" suffix)
                    const titleElement = doc.querySelector("title");
                    if (titleElement) {
                        title = titleElement.textContent
                            .replace(/\s*\|\s*SpringerLink\s*$/, "")
                            .trim();
                    }

                    // Extract authors from meta tags
                    const authorMetas = doc.querySelectorAll(
                        'meta[name="citation_author"]',
                    );
                    const authorList = [];
                    authorMetas.forEach((meta) => {
                        const authorName = meta.getAttribute("content").trim();
                        if (authorName) {
                            authorList.push(authorName);
                        }
                    });

                    if (authorList.length > 0) {
                        authors = authorList.join(", ");
                    }

                    // Extract abstract from the abstract section
                    const abstractSection = doc.querySelector(
                        'section[aria-labelledby="Abs1"]',
                    );
                    if (abstractSection) {
                        const abstractContent = abstractSection.querySelector(
                            ".c-article-section__content",
                        );
                        if (abstractContent) {
                            // Get all paragraph texts from the abstract
                            const paragraphs =
                                abstractContent.querySelectorAll("p");
                            const abstractParts = [];
                            paragraphs.forEach((p) => {
                                const text = p.textContent.trim();
                                if (text && !text.includes("Work done while")) {
                                    abstractParts.push(text);
                                }
                            });
                            if (abstractParts.length > 0) {
                                abstract = abstractParts.join(" ").trim();
                            }
                        }
                    }

                    // Extract date from "First Online" information
                    const dateTimeElement = doc.querySelector("time[datetime]");
                    if (dateTimeElement) {
                        const dateTimeValue =
                            dateTimeElement.getAttribute("datetime");
                        if (dateTimeValue) {
                            date = dateTimeValue;
                        }
                    }
                } else if (urlType === "ieee") {
                    // Parse IEEE Xplore metadata

                    // Extract title from page title (remove " | IEEE ..." suffix)
                    const titleElement = doc.querySelector("title");
                    if (titleElement) {
                        const titleText = titleElement.textContent;
                        title = titleText.split("|")[0].trim();
                    }

                    // Try to extract metadata from xplGlobal.document.metadata
                    const scripts = doc.querySelectorAll("script");
                    let metadata = null;

                    for (const script of scripts) {
                        const scriptContent = script.textContent;
                        if (
                            scriptContent.includes(
                                "xplGlobal.document.metadata",
                            )
                        ) {
                            try {
                                // Extract the metadata object from the script
                                const metadataMatch = scriptContent.match(
                                    /xplGlobal\.document\.metadata\s*=\s*({.*?});/s,
                                );
                                if (metadataMatch) {
                                    metadata = JSON.parse(metadataMatch[1]);
                                    break;
                                }
                            } catch (e) {
                                console.log(
                                    "Could not parse IEEE metadata:",
                                    e,
                                );
                            }
                        }
                    }

                    if (metadata) {
                        // Extract authors from metadata
                        if (
                            metadata.authors &&
                            Array.isArray(metadata.authors)
                        ) {
                            const authorList = [];
                            metadata.authors.forEach((author) => {
                                if (author.firstName && author.lastName) {
                                    authorList.push(
                                        `${author.firstName} ${author.lastName}`,
                                    );
                                } else if (author.name) {
                                    authorList.push(author.name);
                                }
                            });
                            if (authorList.length > 0) {
                                authors = authorList.join(", ");
                            }
                        }

                        // Extract abstract from metadata
                        if (metadata.abstract) {
                            abstract = metadata.abstract.trim();
                        }

                        // Extract date from metadata
                        if (metadata.publicationDate) {
                            const parsedDate = new Date(
                                metadata.publicationDate,
                            );
                            if (!isNaN(parsedDate)) {
                                date = parsedDate.toISOString().split("T")[0];
                            }
                        } else if (metadata.publicationYear) {
                            date = `${metadata.publicationYear}-01-01`;
                        }
                    }

                    // Fallback: try to extract from meta tags
                    if (!title) {
                        const titleMeta = doc.querySelector(
                            'meta[name="citation_title"]',
                        );
                        if (titleMeta) {
                            title = titleMeta.getAttribute("content").trim();
                        }
                    }

                    if (!authors) {
                        const authorMetas = doc.querySelectorAll(
                            'meta[name="citation_author"]',
                        );
                        const authorList = [];
                        authorMetas.forEach((meta) => {
                            const authorName = meta
                                .getAttribute("content")
                                .trim();
                            if (authorName) {
                                authorList.push(authorName);
                            }
                        });
                        if (authorList.length > 0) {
                            authors = authorList.join(", ");
                        }
                    }

                    if (!abstract) {
                        const abstractMeta = doc.querySelector(
                            'meta[name="description"]',
                        );
                        if (abstractMeta) {
                            abstract = abstractMeta
                                .getAttribute("content")
                                .trim();
                        }
                    }

                    if (!date || date === "Unknown date") {
                        const dateMeta = doc.querySelector(
                            'meta[name="citation_publication_date"]',
                        );
                        if (dateMeta) {
                            const dateStr = dateMeta.getAttribute("content");
                            const parsedDate = new Date(dateStr);
                            if (!isNaN(parsedDate)) {
                                date = parsedDate.toISOString().split("T")[0];
                            }
                        }
                    }
                } else {
                    // Parse ePrint metadata (existing logic)

                    // Extract title from meta tag first, fallback to h3
                    const titleMeta = doc.querySelector(
                        'meta[name="citation_title"]',
                    );
                    if (titleMeta) {
                        title = titleMeta.getAttribute("content").trim();
                    } else {
                        const titleElement = doc.querySelector("h3");
                        if (titleElement) {
                            title = titleElement.textContent.trim();
                        }
                    }

                    // Extract authors from meta tags
                    const authorMetas = doc.querySelectorAll(
                        'meta[name="citation_author"]',
                    );
                    const authorList = [];
                    authorMetas.forEach((meta) => {
                        const authorName = meta.getAttribute("content").trim();
                        if (authorName) {
                            authorList.push(authorName);
                        }
                    });

                    if (authorList.length > 0) {
                        authors = authorList.join(", ");
                    }

                    // Extract abstract
                    const abstractHeading = Array.from(
                        doc.querySelectorAll("*"),
                    ).find((el) => el.textContent.trim() === "Abstract");
                    if (abstractHeading) {
                        let current = abstractHeading.nextElementSibling;
                        const abstractParts = [];

                        while (
                            current &&
                            !current.textContent.includes("Metadata") &&
                            !current.textContent.includes("Category")
                        ) {
                            const text = current.textContent.trim();
                            if (text && text.length > 20) {
                                abstractParts.push(text);
                            }
                            current = current.nextElementSibling;
                        }

                        if (abstractParts.length > 0) {
                            abstract = abstractParts.join(" ").trim();
                        }
                    }

                    // Extract date
                    const bodyText = doc.body.textContent;
                    const dateMatch = bodyText.match(
                        /(\d{4}-\d{2}-\d{2}):\s*received/i,
                    );
                    if (dateMatch) {
                        date = dateMatch[1];
                    }

                    // Extract contact author emails
                    const contactSection = Array.from(
                        doc.querySelectorAll("dt"),
                    ).find(
                        (dt) => dt.textContent.trim() === "Contact author(s)",
                    );
                    if (contactSection) {
                        const emailContainer =
                            contactSection.nextElementSibling;
                        if (emailContainer) {
                            const emailSpan =
                                emailContainer.querySelector(".font-monospace");
                            if (emailSpan) {
                                const emailText = emailSpan.innerHTML;
                                // Extract and de-obfuscate emails
                                const emailLines = emailText.split("<br>");
                                emailLines.forEach((line) => {
                                    // Remove HTML tags and get raw text
                                    const tempDiv =
                                        document.createElement("div");
                                    tempDiv.innerHTML = line;
                                    let emailText =
                                        tempDiv.textContent ||
                                        tempDiv.innerText ||
                                        "";
                                    emailText = emailText.trim();

                                    if (emailText && emailText.includes("@")) {
                                        // De-obfuscate email: replace spaces around @ and add dots
                                        let email = emailText.replace(
                                            /\s*@\s*/g,
                                            "@",
                                        );
                                        // Add dots between name parts and before domain extension
                                        email = email.replace(/\s+/g, ".");
                                        // Ensure proper domain extension
                                        email = email.replace(
                                            /(\w+)\s+(\w+)$/,
                                            "$1.$2",
                                        );
                                        contactEmails.push(email);
                                    }
                                });
                            }
                        }
                    }
                }

                return {
                    title:
                        title ||
                        (urlType === "springer"
                            ? "Springer Paper"
                            : urlType === "acm"
                              ? "ACM Paper"
                              : `Paper ${paperId}`),
                    authors: authors || "Unknown Authors",
                    abstract: abstract || "No abstract available",
                    date: date,
                    contactEmails: contactEmails,
                };
            }

            // Show manual parser interface
            function showManualParser() {
                const manualParser = document.getElementById("manual-parser");
                manualParser.style.display =
                    manualParser.style.display === "none" ? "block" : "none";
            }

            // Parse manually pasted content
            function parseManualContent() {
                const content = document
                    .getElementById("page-content")
                    .value.trim();
                let url = document.getElementById("eprint-url").value.trim();

                if (!content) {
                    showMessage("Please paste the paper page content", "error");
                    return;
                }

                try {
                    let paperId = "Unknown";
                    let urlType = "";
                    let metadata;

                    // Detect if this is Springer Nature content
                    if (
                        content.includes("Skip to main content") ||
                        content.includes("Springer Nature Link") ||
                        content.includes("First Online:") ||
                        content.includes("Conference paper") ||
                        content.includes("Part of the book series") ||
                        content.includes("Lecture Notes in Computer Science") ||
                        content.includes("Advances in Cryptology")
                    ) {
                        urlType = "springer";

                        // Try to extract Springer identifier from URL if available
                        if (url) {
                            const springerMatch = url.match(
                                /link\.springer\.com\/chapter\/10\.1007\/(.+)$/,
                            );
                            if (springerMatch) {
                                paperId = springerMatch[1];
                            }
                        }

                        metadata = parseSpringerContent(content, paperId);
                    } else if (
                        content.includes("ACM Digital Library") ||
                        content.includes("dl.acm.org") ||
                        content.includes("Proceedings of") ||
                        content.includes("core-date-published") ||
                        content.includes("Share on") ||
                        content.includes("Authors:") ||
                        content.includes("Published:") ||
                        content.includes("Association for Computing Machinery")
                    ) {
                        urlType = "acm";

                        // Try to extract ACM identifier from URL if available
                        if (url) {
                            const acmMatch = url.match(
                                /dl\.acm\.org\/doi\/10\.1145\/(.+)$/,
                            );
                            if (acmMatch) {
                                paperId = acmMatch[1];
                            }
                        }

                        // Use plaintext parser if this looks like copy-pasted text
                        if (
                            content.includes("Share on") &&
                            content.includes("Authors:")
                        ) {
                            metadata = parseAcmPlaintext(content, paperId);
                        } else {
                            metadata = parseAcmContent(content, paperId);
                        }
                    } else if (
                        content.includes("IEEE Xplore") ||
                        content.includes("ieeexplore.ieee.org") ||
                        content.includes("xplGlobal.document.metadata") ||
                        content.includes("IEEE Conference Publication") ||
                        content.includes("IEEE Computer Society") ||
                        content.includes("IEEE Transaction") ||
                        content.includes("© IEEE") ||
                        content.includes("articleNumber") ||
                        content.includes("displayPublicationTitle") ||
                        content.includes("formulaStrippedArticleTitle")
                    ) {
                        urlType = "ieee";

                        // Try to extract IEEE identifier from URL if available
                        if (url) {
                            const ieeeMatch = url.match(
                                /ieeexplore\.ieee\.org\/document\/(\d+)/,
                            );
                            if (ieeeMatch) {
                                paperId = ieeeMatch[1];
                            }
                        }

                        metadata = parseIeeePlaintext(content, paperId);
                    } else {
                        // Assume ePrint content
                        urlType = "eprint";

                        let paperIdMatch = url
                            ? url.match(/\/(\d{4}\/\d+)$/)
                            : null;

                        if (paperIdMatch) {
                            paperId = paperIdMatch[1];
                        } else {
                            const contentPaperMatch =
                                content.match(/Paper (\d{4}\/\d+)/);
                            if (contentPaperMatch) {
                                paperId = contentPaperMatch[1];
                                if (!url) {
                                    url = `https://eprint.iacr.org/${paperId}`;
                                    document.getElementById(
                                        "eprint-url",
                                    ).value = url;
                                }
                            }
                        }

                        metadata = parseEprintContent(content, paperId);
                    }

                    document.getElementById("paper-title").value =
                        metadata.title;
                    document.getElementById("paper-authors").value =
                        metadata.authors;
                    document.getElementById("paper-abstract").value =
                        metadata.abstract;
                    document.getElementById("paper-date").value = metadata.date;

                    // Store contact emails for later use
                    if (
                        metadata.contactEmails &&
                        metadata.contactEmails.length > 0
                    ) {
                        window.currentPaperContactEmails =
                            metadata.contactEmails;
                        showMessage(
                            `Metadata parsed successfully! Found ${metadata.contactEmails.length} contact email${metadata.contactEmails.length > 1 ? "s" : ""}`,
                            "success",
                        );
                    } else {
                        showMessage("Metadata parsed successfully!", "success");
                    }

                    document.getElementById("metadata-form").style.display =
                        "block";
                    document.getElementById("manual-parser").style.display =
                        "none";
                    updatePreviousWorksSelect();

                    showMessage("Metadata parsed successfully!", "success");
                } catch (error) {
                    showMessage(
                        `Error parsing content: ${error.message}`,
                        "error",
                    );
                }
            }

            // Parse Springer Nature content from pasted text
            function parseSpringerContent(content, paperId) {
                let title = "";
                let authors = "";
                let abstract = "";
                let contactEmails = [];
                let date = "Unknown date";

                // Extract title - find text between first and second "Conference paper" occurrences
                const fullText = content;
                const lines = content.split("\n");

                // Find all occurrences of "Conference paper"
                const firstOccurrence = fullText.indexOf("Conference paper");
                if (firstOccurrence !== -1) {
                    const afterFirst = fullText.substring(
                        firstOccurrence + "Conference paper".length,
                    );
                    const secondOccurrence =
                        afterFirst.indexOf("Conference paper");

                    if (secondOccurrence !== -1) {
                        // Extract text between the two occurrences
                        const titleSection = afterFirst.substring(
                            0,
                            secondOccurrence,
                        );

                        // Clean up the title - remove line breaks and extra whitespace
                        const cleanTitle = titleSection
                            .replace(/\n+/g, " ")
                            .replace(/\s+/g, " ")
                            .trim();

                        // Remove any leading/trailing non-letter characters and common navigation text
                        const finalTitle = cleanTitle
                            .replace(/^[^\w]*/, "")
                            .replace(/[^\w)]*$/, "")
                            .trim();

                        if (finalTitle.length > 10) {
                            title = finalTitle;
                        }
                    }
                }

                // Extract authors - look for pattern like "Name, Name & Name"
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (
                        (line.includes("&") || line.includes(",")) &&
                        line.length > 10 &&
                        line.length < 100 &&
                        !line.includes("Part of") &&
                        !line.includes("Conference") &&
                        !line.includes("@") &&
                        /^[A-Za-z\s,&.]+$/.test(line)
                    ) {
                        authors = line.replace(/\s+/g, " ").trim();
                        break;
                    }
                }

                // Extract abstract - find text between "Abstract" and "Work done while"
                const abstractMatch = content.match(
                    /Abstract\s+(.*?)(?=Work done while|Download to read|Keywords:|$)/s,
                );
                if (abstractMatch) {
                    let abstractText = abstractMatch[1].trim();

                    // Remove metadata that appears before the actual abstract
                    abstractText = abstractText.replace(/^.*?Abstract\s*/, "");

                    // Clean up the text by removing obvious metadata patterns
                    const cleanLines = [];
                    const lines = abstractText.split("\n");
                    let foundRealContent = false;

                    for (const line of lines) {
                        const trimmed = line.trim();

                        // Skip metadata lines
                        if (
                            trimmed.includes("Conference paper") ||
                            trimmed.includes("First Online:") ||
                            trimmed.includes("pp ") ||
                            trimmed.includes("Cite this") ||
                            trimmed.includes("Download") ||
                            trimmed.includes("Advances in Cryptology") ||
                            trimmed.includes("Part of the book") ||
                            trimmed.includes("Included in") ||
                            trimmed.includes("Accesses") ||
                            trimmed.includes("Citations") ||
                            trimmed.includes("Altmetric") ||
                            trimmed.includes("LNCS") ||
                            trimmed.includes("volume") ||
                            /^\d+[kK]?\s/.test(trimmed) ||
                            trimmed.length < 20
                        ) {
                            continue;
                        }

                        // Once we find substantial content, start collecting
                        if (trimmed.length > 30 && /^[A-Z]/.test(trimmed)) {
                            foundRealContent = true;
                        }

                        if (foundRealContent && trimmed) {
                            cleanLines.push(trimmed);
                        }
                    }

                    if (cleanLines.length > 0) {
                        abstract = cleanLines.join(" ").trim();
                    }
                }

                // Extract date from "First Online" line
                const dateMatch = content.match(
                    /First Online:\s*(\d{2}\s+\w+\s+\d{4})/,
                );
                if (dateMatch) {
                    const dateStr = dateMatch[1];
                    const parsedDate = new Date(dateStr);
                    if (!isNaN(parsedDate)) {
                        date = parsedDate.toISOString().split("T")[0];
                    }
                }

                return {
                    title: title || "Springer Paper",
                    authors: authors || "Unknown Authors",
                    abstract: abstract || "No abstract available",
                    date: date,
                    contactEmails: contactEmails,
                };
            }

            // Parse ACM Digital Library content from pasted text
            function parseAcmContent(content, paperId) {
                let title = "";
                let authors = "";
                let abstract = "";
                let contactEmails = [];
                let date = new Date().toISOString().split("T")[0];

                const lines = content.split("\n");

                // Extract title - look for the main title before " | Proceedings"
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (
                        line.includes(" | Proceedings") ||
                        line.includes(" | ACM")
                    ) {
                        const titlePart = line.split("|")[0].trim();
                        if (titlePart.length > 10) {
                            title = titlePart;
                            break;
                        }
                    }
                }

                // Extract authors - look for patterns with givenName and familyName
                const authorPattern =
                    /<span property="givenName">([^<]+)<\/span>\s*<span property="familyName">([^<]+)<\/span>/g;
                let authorMatch;
                const authorList = [];
                while ((authorMatch = authorPattern.exec(content)) !== null) {
                    const givenName = authorMatch[1].trim();
                    const familyName = authorMatch[2].trim();
                    if (givenName && familyName) {
                        authorList.push(`${givenName} ${familyName}`);
                    }
                }

                if (authorList.length > 0) {
                    authors = authorList.join(", ");
                } else {
                    // Fallback 1: Look for authors in contributors section
                    const contributorsMatch = content.match(
                        /<div class="contributors">.*?<\/div>/s,
                    );
                    if (contributorsMatch) {
                        const contributorsSection = contributorsMatch[0];
                        const authorPattern2 =
                            /<span property="author"[^>]*>.*?<a[^>]*>.*?<span property="givenName">([^<]+)<\/span>\s*<span property="familyName">([^<]+)<\/span>/gs;
                        let authorMatch2;
                        const authorList2 = [];
                        while (
                            (authorMatch2 =
                                authorPattern2.exec(contributorsSection)) !==
                            null
                        ) {
                            const givenName = authorMatch2[1].trim();
                            const familyName = authorMatch2[2].trim();
                            if (givenName && familyName) {
                                authorList2.push(`${givenName} ${familyName}`);
                            }
                        }
                        if (authorList2.length > 0) {
                            authors = authorList2.join(", ");
                        }
                    }

                    // Fallback 2: Look for "Authors:" text pattern
                    if (!authors) {
                        const authorsMatch =
                            content.match(/Authors:\s*([^<\n]+)/i);
                        if (authorsMatch) {
                            authors = authorsMatch[1].trim();
                        }
                    }
                }

                // Extract abstract - find content in the abstract section
                const abstractMatch = content.match(
                    /<section[^>]*id="abstract"[^>]*>.*?<\/section>/s,
                );
                if (abstractMatch) {
                    const abstractSection = abstractMatch[0];

                    // Method 1: Extract all text content from the abstract section
                    let abstractText = abstractSection
                        .replace(/<h2[^>]*>.*?<\/h2>/s, "") // Remove heading
                        .replace(/<[^>]*>/g, " ") // Remove all HTML tags
                        .replace(/\s+/g, " ") // Normalize whitespace
                        .trim();

                    if (abstractText && abstractText.length > 50) {
                        abstract = abstractText;
                    } else {
                        // Method 2: Try to extract main paragraph and list items separately
                        const paragraphMatch = abstractSection.match(
                            /<div[^>]*role="paragraph"[^>]*>(.*?)<(?:div[^>]*role="list"|\/div>)/s,
                        );
                        let mainText = "";

                        if (paragraphMatch) {
                            mainText = paragraphMatch[1]
                                .replace(/<[^>]*>/g, " ")
                                .replace(/\s+/g, " ")
                                .trim();
                        }

                        // Extract all list items
                        const listItemPattern =
                            /<div[^>]*role="listitem"[^>]*>.*?<div[^>]*role="paragraph"[^>]*>(.*?)<\/div>/gs;
                        let listMatch;
                        const listItems = [];

                        while (
                            (listMatch =
                                listItemPattern.exec(abstractSection)) !== null
                        ) {
                            const itemText = listMatch[1]
                                .replace(/<[^>]*>/g, " ")
                                .replace(/\s+/g, " ")
                                .trim();
                            if (itemText) {
                                listItems.push(itemText);
                            }
                        }

                        // Combine main text with list items
                        if (mainText) {
                            abstract = mainText;
                            if (listItems.length > 0) {
                                abstract +=
                                    " Our results include: " +
                                    listItems.join("; ");
                            }
                        } else if (listItems.length > 0) {
                            abstract =
                                "Our results include: " + listItems.join("; ");
                        }
                    }
                }

                // Fallback: look for text after "Abstract" keyword if nothing found
                if (!abstract || abstract.length < 50) {
                    const abstractStart = content.indexOf("Abstract");
                    if (abstractStart !== -1) {
                        const afterAbstract = content.substring(abstractStart);
                        const abstractLines = afterAbstract
                            .split("\n")
                            .slice(1);
                        const abstractParts = [];
                        for (const line of abstractLines) {
                            const trimmed = line.trim();
                            if (
                                trimmed &&
                                !trimmed.includes("Keywords") &&
                                !trimmed.includes("References") &&
                                !trimmed.includes("Bibliometrics") &&
                                trimmed.length > 20
                            ) {
                                abstractParts.push(trimmed);
                                if (abstractParts.join(" ").length > 800) break;
                            }
                        }
                        if (abstractParts.length > 0) {
                            abstract = abstractParts
                                .join(" ")
                                .replace(/<[^>]*>/g, " ")
                                .replace(/\s+/g, " ")
                                .trim();
                        }
                    }
                }

                // Extract date from core-date-published
                const dateMatch = content.match(
                    /core-date-published[">]+([^<]+)/,
                );
                if (dateMatch) {
                    const dateStr = dateMatch[1].trim();
                    const parsedDate = new Date(dateStr);
                    if (!isNaN(parsedDate)) {
                        date = parsedDate.toISOString().split("T")[0];
                    }
                }

                // Debug logging
                console.log("ACM Plaintext Parser Results:", {
                    title: title || "ACM Paper",
                    authors: authors || "Unknown Authors",
                    abstract:
                        (abstract || "No abstract available").substring(
                            0,
                            200,
                        ) + "...",
                    abstractLength: (abstract || "").length,
                    date: date,
                    contactEmails: contactEmails,
                });

                return {
                    title: title || "ACM Paper",
                    authors: authors || "Unknown Authors",
                    abstract: abstract || "No abstract available",
                    date: date,
                    contactEmails: contactEmails,
                };
            }

            // Parse ACM Digital Library content from plaintext (for copy-paste scenarios)
            function parseAcmPlaintext(content, paperId) {
                let title = "";
                let authors = "";
                let abstract = "";
                let contactEmails = [];
                let date = new Date().toISOString().split("T")[0];

                console.log(
                    "Parsing ACM plaintext content, length:",
                    content.length,
                );
                console.log("Sample content:", content.substring(0, 500));

                const lines = content
                    .split("\n")
                    .map((line) => line.trim())
                    .filter((line) => line.length > 0);

                // Extract title - look for line after "Share on"
                for (let i = 0; i < lines.length - 1; i++) {
                    if (lines[i] === "Share on") {
                        if (i + 1 < lines.length) {
                            const potentialTitle = lines[i + 1];
                            // Make sure it's not a navigation item or metadata
                            if (
                                potentialTitle.length > 10 &&
                                !potentialTitle.includes("Authors:") &&
                                !potentialTitle.includes("Home") &&
                                !potentialTitle.includes("Conference") &&
                                !potentialTitle.includes("Browse") &&
                                !potentialTitle.startsWith("STOC") &&
                                !potentialTitle.startsWith("FOCS")
                            ) {
                                title = potentialTitle;
                                console.log(
                                    "Found title after 'Share on':",
                                    title,
                                );
                                break;
                            } else {
                                console.log(
                                    "Rejected potential title:",
                                    potentialTitle,
                                );
                            }
                        }
                    }
                }

                // Extract authors - look for line starting with "Authors:" and extract the names
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.startsWith("Authors:")) {
                        // Extract the part after "Authors:" and before "Authors Info & Claims"
                        const authorsText = line
                            .replace("Authors:", "")
                            .replace("Authors Info & Claims", "")
                            .trim();
                        if (authorsText && authorsText.length > 0) {
                            authors = authorsText;
                            console.log("Found authors:", authors);
                            break;
                        }
                    }
                }

                // Extract date - look for line starting with "Published:"
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.startsWith("Published:")) {
                        const dateText = line
                            .replace("Published:", "")
                            .replace("Publication History", "")
                            .trim();
                        const parsedDate = new Date(dateText);
                        if (!isNaN(parsedDate)) {
                            date = parsedDate.toISOString().split("T")[0];
                            console.log("Found date:", date);
                            break;
                        }
                    }
                }

                // Extract abstract - find content between "Abstract" and "Formats available"
                let abstractStartIndex = -1;
                let abstractEndIndex = -1;

                for (let i = 0; i < lines.length; i++) {
                    if (lines[i] === "Abstract") {
                        abstractStartIndex = i + 1;
                    }
                    if (lines[i] === "Formats available") {
                        abstractEndIndex = i;
                        break;
                    }
                }

                if (
                    abstractStartIndex > 0 &&
                    abstractEndIndex > abstractStartIndex
                ) {
                    const abstractLines = lines.slice(
                        abstractStartIndex,
                        abstractEndIndex,
                    );

                    // Filter out non-abstract content
                    const cleanAbstractLines = [];
                    for (const line of abstractLines) {
                        if (
                            line &&
                            line.length > 10 &&
                            !line.includes("PDF") &&
                            !line.includes("eReader") &&
                            !line.includes("Information & Contributors") &&
                            !line.includes("Bibliometrics") &&
                            !line.includes("View Options") &&
                            !line.includes("References") &&
                            !line.includes("Share") &&
                            !line.includes("citation") &&
                            !line.includes("Downloads") &&
                            !line.match(/^\d+$/)
                        ) {
                            // Skip standalone numbers
                            cleanAbstractLines.push(line);
                        }
                    }

                    if (cleanAbstractLines.length > 0) {
                        abstract = cleanAbstractLines.join(" ").trim();
                        console.log(
                            "Found abstract:",
                            abstract.substring(0, 100) + "...",
                        );
                    }
                }

                return {
                    title: title || "ACM Paper",
                    authors: authors || "Unknown Authors",
                    abstract: abstract || "No abstract available",
                    date: date,
                    contactEmails: contactEmails,
                };
            }

            // Parse IEEE Xplore content from plaintext (for copy-paste scenarios)
            function parseIeeePlaintext(content, paperId) {
                let title = "";
                let authors = "";
                let abstract = "";
                let contactEmails = [];
                let date = new Date().toISOString().split("T")[0];

                console.log("=== IEEE PLAINTEXT PARSING ===");
                console.log("Parsing IEEE plaintext content");
                console.log("Content length:", content.length);
                console.log(
                    "Has 'IEEE Xplore':",
                    content.includes("IEEE Xplore"),
                );
                console.log(
                    "Has 'xplGlobal.document.metadata':",
                    content.includes("xplGlobal.document.metadata"),
                );

                // Try to extract metadata from xplGlobal.document.metadata if present
                if (content.includes("xplGlobal.document.metadata")) {
                    try {
                        const metadataMatch = content.match(
                            /xplGlobal\.document\.metadata\s*=\s*({.*?});/s,
                        );
                        if (metadataMatch) {
                            const metadata = JSON.parse(metadataMatch[1]);

                            // Extract title
                            if (metadata.formulaStrippedArticleTitle) {
                                title = metadata.formulaStrippedArticleTitle;
                            } else if (metadata.title) {
                                title = metadata.title.split("|")[0].trim();
                            }

                            // Extract authors
                            if (
                                metadata.authors &&
                                Array.isArray(metadata.authors)
                            ) {
                                const authorList = [];
                                metadata.authors.forEach((author) => {
                                    if (author.firstName && author.lastName) {
                                        authorList.push(
                                            `${author.firstName} ${author.lastName}`,
                                        );
                                    } else if (author.name) {
                                        authorList.push(author.name);
                                    }
                                });
                                if (authorList.length > 0) {
                                    authors = authorList.join(", ");
                                }
                            }

                            // Extract abstract
                            if (metadata.abstract) {
                                abstract = metadata.abstract.trim();
                            }

                            // Extract date
                            if (metadata.publicationDate) {
                                const parsedDate = new Date(
                                    metadata.publicationDate,
                                );
                                if (!isNaN(parsedDate)) {
                                    date = parsedDate
                                        .toISOString()
                                        .split("T")[0];
                                }
                            } else if (metadata.publicationYear) {
                                date = `${metadata.publicationYear}-01-01`;
                            }

                            console.log("Extracted from metadata:", {
                                title,
                                authors,
                                abstractLength: abstract.length,
                                date,
                            });
                        }
                    } catch (error) {
                        console.log(
                            "Failed to parse IEEE metadata JSON:",
                            error,
                        );
                    }
                }

                // Fallback: extract from plaintext patterns
                if (!title || !authors || !abstract) {
                    const lines = content
                        .split("\n")
                        .map((line) => line.trim())
                        .filter((line) => line.length > 0);

                    // Extract title from page title pattern
                    if (!title) {
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i];
                            if (
                                line.includes(" | IEEE ") &&
                                line.length > 10 &&
                                line.length < 200
                            ) {
                                title = line.split("|")[0].trim();
                                console.log(
                                    "Found title from page title:",
                                    title,
                                );
                                break;
                            }
                        }
                    }

                    // Extract authors - look for "Authors:" or structured author lines
                    if (!authors) {
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i];
                            if (line.startsWith("Authors:")) {
                                const authorsText = line
                                    .replace("Authors:", "")
                                    .trim();
                                if (authorsText && authorsText.length > 0) {
                                    authors = authorsText;
                                    console.log("Found authors:", authors);
                                    break;
                                }
                            }
                        }
                    }

                    // Extract abstract - look for "Abstract" section
                    if (!abstract) {
                        let abstractStartIndex = -1;
                        let abstractEndIndex = -1;

                        for (let i = 0; i < lines.length; i++) {
                            if (
                                lines[i] === "Abstract" ||
                                lines[i].startsWith("Abstract:")
                            ) {
                                abstractStartIndex = i + 1;
                            }
                            if (
                                abstractStartIndex > -1 &&
                                (lines[i] === "Keywords" ||
                                    lines[i] === "References" ||
                                    lines[i] === "Index Terms" ||
                                    lines[i].startsWith("Published in:") ||
                                    lines[i].includes("DOI:"))
                            ) {
                                abstractEndIndex = i;
                                break;
                            }
                        }

                        if (
                            abstractStartIndex > 0 &&
                            abstractEndIndex > abstractStartIndex
                        ) {
                            const abstractLines = lines.slice(
                                abstractStartIndex,
                                abstractEndIndex,
                            );
                            const cleanAbstractLines = [];

                            for (const line of abstractLines) {
                                if (
                                    line &&
                                    line.length > 10 &&
                                    !line.includes("View full text") &&
                                    !line.includes("Download PDF") &&
                                    !line.includes("Purchase") &&
                                    !line.includes("Subscribe") &&
                                    !line.match(/^\d+$/) // Skip standalone numbers
                                ) {
                                    cleanAbstractLines.push(line);
                                }
                            }

                            if (cleanAbstractLines.length > 0) {
                                abstract = cleanAbstractLines.join(" ").trim();
                                console.log(
                                    "Found abstract:",
                                    abstract.substring(0, 100) + "...",
                                );
                            }
                        }
                    }

                    // Extract date - look for publication date patterns
                    if (date === new Date().toISOString().split("T")[0]) {
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i];
                            if (
                                line.startsWith("Published in:") ||
                                line.startsWith("Date of Publication:")
                            ) {
                                const dateText = line.split(":")[1]?.trim();
                                if (dateText) {
                                    const parsedDate = new Date(dateText);
                                    if (!isNaN(parsedDate)) {
                                        date = parsedDate
                                            .toISOString()
                                            .split("T")[0];
                                        console.log("Found date:", date);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                return {
                    title: title || "IEEE Paper",
                    authors: authors || "Unknown Authors",
                    abstract: abstract || "No abstract available",
                    date: date,
                    contactEmails: contactEmails,
                };
            }

            // Parse ePrint content from pasted text
            function parseEprintContent(content, paperId) {
                const lines = content
                    .split("\n")
                    .map((line) => line.trim())
                    .filter((line) => line.length > 0);

                let title = "";
                let authors = "";
                let abstract = "";
                let contactEmails = [];
                let date = new Date().toISOString().split("T")[0];

                // Extract title - look for the line after "Paper YYYY/NNNN"
                for (let i = 0; i < lines.length - 1; i++) {
                    if (lines[i].match(/^Paper \d{4}\/\d+$/)) {
                        if (i + 1 < lines.length) {
                            title = lines[i + 1].trim();
                            break;
                        }
                    }
                }

                // Extract authors - they appear after the title and before "Abstract"
                let authorStartIndex = -1;
                let abstractIndex = -1;

                if (title) {
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i] === title) {
                            authorStartIndex = i + 1;
                            break;
                        }
                    }
                }

                for (let i = 0; i < lines.length; i++) {
                    if (lines[i] === "Abstract") {
                        abstractIndex = i;
                        break;
                    }
                }

                if (authorStartIndex > 0 && abstractIndex > authorStartIndex) {
                    const authorLines = lines.slice(
                        authorStartIndex,
                        abstractIndex,
                    );
                    const authorBlocks = [];

                    for (const line of authorLines) {
                        if (
                            !line ||
                            line === "Abstract" ||
                            line.startsWith("Paper ")
                        )
                            continue;

                        if (line.includes(",")) {
                            const parts = line.split(",");
                            const name = parts[0].trim();
                            const affiliation = parts.slice(1).join(",").trim();

                            if (name && affiliation) {
                                authorBlocks.push(`${name} (${affiliation})`);
                            } else if (name) {
                                authorBlocks.push(name);
                            }
                        } else if (
                            line.length > 2 &&
                            !line.includes("IACR") &&
                            !line.includes("Logo") &&
                            !line.includes("Archive")
                        ) {
                            authorBlocks.push(line);
                        }
                    }

                    if (authorBlocks.length > 0) {
                        authors = authorBlocks.join(", ");
                    }
                }

                // Extract abstract
                let abstractStartLine = -1;
                let metadataStartLine = -1;

                for (let i = 0; i < lines.length; i++) {
                    if (lines[i] === "Abstract") {
                        abstractStartLine = i + 1;
                    }
                    if (lines[i] === "Metadata") {
                        metadataStartLine = i;
                        break;
                    }
                }

                if (
                    abstractStartLine > 0 &&
                    metadataStartLine > abstractStartLine
                ) {
                    const abstractLines = lines.slice(
                        abstractStartLine,
                        metadataStartLine,
                    );
                    abstract = abstractLines.join(" ").trim();
                }

                // Extract date
                const dateMatch = content.match(
                    /(\d{4}-\d{2}-\d{2}):\s*received/i,
                );
                if (dateMatch) {
                    date = dateMatch[1];
                } else {
                    const yearMatch = paperId.match(/^(\d{4})/);
                    if (yearMatch) {
                        const year = yearMatch[1];
                        date = `${year}-01-01`;
                    }
                }

                // Extract contact author emails
                let contactStartIndex = -1;
                let contactEndIndex = -1;

                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim() === "Contact author(s)") {
                        contactStartIndex = i + 1;
                    }
                    if (
                        contactStartIndex > -1 &&
                        lines[i].trim() === "History"
                    ) {
                        contactEndIndex = i;
                        break;
                    }
                }

                if (
                    contactStartIndex > -1 &&
                    contactEndIndex > contactStartIndex
                ) {
                    const emailLines = lines.slice(
                        contactStartIndex,
                        contactEndIndex,
                    );
                    emailLines.forEach((line) => {
                        line = line.trim();
                        if (line && line.includes("@")) {
                            // De-obfuscate email: remove spaces around @ and add dots
                            let email = line.replace(/\s*@\s*/g, "@");
                            // Add dots between name parts and before domain extension
                            const parts = email.split("@");
                            if (parts.length === 2) {
                                const namePart = parts[0].replace(/\s+/g, ".");
                                const domainPart = parts[1].replace(
                                    /\s+/g,
                                    ".",
                                );
                                email = `${namePart}@${domainPart}`;
                                contactEmails.push(email);
                            }
                        }
                    });
                }

                title = title.replace(/\{|\}/g, "").trim();
                authors = authors.trim();

                return {
                    title: title || `Paper ${paperId}`,
                    authors: authors || "Unknown Authors",
                    abstract: abstract || "No abstract available",
                    date: date,
                    contactEmails: contactEmails,
                };
            }

            // Update previous works select
            function updatePreviousWorksSelect() {
                const select = document.getElementById("previous-works");
                if (!select) return;

                select.innerHTML = "";

                papers.forEach((paper, index) => {
                    const option = document.createElement("option");
                    option.value = index;
                    option.textContent = paper.isPlaceholder
                        ? `${paper.title} (needs metadata)`
                        : paper.title;
                    if (paper.isPlaceholder) {
                        option.style.fontStyle = "italic";
                        option.style.color = "#999";
                    }
                    select.appendChild(option);
                });

                updateSelectedPreviousWorksDisplay();
            }

            // Search previous works
            function searchPreviousWorks() {
                const searchTerm = document
                    .getElementById("previous-work-search")
                    .value.toLowerCase();
                const select = document.getElementById("previous-works");

                select.innerHTML = "";

                papers.forEach((paper, index) => {
                    if (
                        !searchTerm ||
                        paper.title.toLowerCase().includes(searchTerm) ||
                        paper.authors.toLowerCase().includes(searchTerm)
                    ) {
                        const option = document.createElement("option");
                        option.value = index;
                        option.textContent = paper.isPlaceholder
                            ? `${paper.title} (needs metadata)`
                            : paper.title;
                        if (paper.isPlaceholder) {
                            option.style.fontStyle = "italic";
                            option.style.color = "#999";
                        }
                        select.appendChild(option);
                    }
                });
            }

            // Set view mode
            function setViewMode(mode) {
                currentViewMode = mode;

                // Update button states in both locations
                const buttonSelectors = [
                    "view-normal",
                    "view-compact",
                    "view-expanded",
                    "main-view-normal",
                    "main-view-compact",
                    "main-view-expanded",
                ];
                buttonSelectors.forEach((id) => {
                    const btn = document.getElementById(id);
                    if (btn) {
                        btn.classList.remove("active");
                    }
                });

                const activeButtons =
                    mode === "normal"
                        ? ["view-normal", "main-view-normal"]
                        : mode === "compact"
                          ? ["view-compact", "main-view-compact"]
                          : ["view-expanded", "main-view-expanded"];

                activeButtons.forEach((id) => {
                    const btn = document.getElementById(id);
                    if (btn) {
                        btn.classList.add("active");
                    }
                });

                performSearch(); // Maintain current search state
            }

            // Update display of selected previous works
            function updateSelectedPreviousWorksDisplay() {
                const select = document.getElementById("previous-works");
                const display = document.getElementById(
                    "selected-previous-works",
                );
                if (!select || !display) return;

                const selectedOptions = Array.from(select.selectedOptions);
                if (selectedOptions.length === 0) {
                    display.innerHTML =
                        '<em style="color: #999;">No papers selected</em>';
                } else {
                    display.innerHTML = selectedOptions
                        .map(
                            (option) =>
                                `<div class="selected-paper-item">${escapeHtml(option.textContent)}</div>`,
                        )
                        .join("");
                }
            }

            // Add previous work by URL
            function addPreviousWorkByUrl() {
                const urlInput = document.getElementById("previous-work-url");
                const url = urlInput.value.trim();

                if (!url) {
                    showMessage("Please enter an ePrint URL", "error");
                    return;
                }

                const paperIdMatch = url.match(
                    /eprint\.iacr\.org\/(\d{4}\/\d+)$/,
                );
                if (!paperIdMatch) {
                    showMessage(
                        "Invalid ePrint URL format. Expected: https://eprint.iacr.org/YYYY/NNNN",
                        "error",
                    );
                    return;
                }

                const paperId = paperIdMatch[1];
                const existingPaper = papers.find((p) => p.url === url);

                if (existingPaper) {
                    const select = document.getElementById("previous-works");
                    const paperIndex = papers.indexOf(existingPaper);
                    const option = select.querySelector(
                        `option[value="${paperIndex}"]`,
                    );
                    if (option) {
                        option.selected = true;
                        updateSelectedPreviousWorksDisplay();
                        showMessage(
                            "Selected existing paper from database",
                            "success",
                        );
                    }
                } else {
                    const placeholderPaper = {
                        id: Date.now() + Math.random(),
                        title: `Paper ${paperId} (placeholder)`,
                        authors: "Unknown Authors",
                        abstract: "Placeholder - add metadata via editing",
                        date: new Date().toISOString().split("T")[0],
                        url: url,
                        labelSets: [],
                        previousWorks: [],
                        addedDate: new Date().toISOString(),
                        isPlaceholder: true,
                        folder: "",
                    };

                    papers.push(placeholderPaper);
                    savePapers();
                    updatePreviousWorksSelect();

                    const select = document.getElementById("previous-works");
                    const newIndex = papers.length - 1;
                    const option = select.querySelector(
                        `option[value="${newIndex}"]`,
                    );
                    if (option) {
                        option.selected = true;
                        updateSelectedPreviousWorksDisplay();
                    }

                    showMessage(
                        "Created placeholder paper - you can edit it later to add metadata",
                        "success",
                    );
                }

                urlInput.value = "";
            }

            // Setup previous works listeners
            function setupPreviousWorksListeners() {
                const select = document.getElementById("previous-works");
                if (select && !select.hasAttribute("data-listener-added")) {
                    select.addEventListener(
                        "change",
                        updateSelectedPreviousWorksDisplay,
                    );
                    select.setAttribute("data-listener-added", "true");
                }
            }

            // Save paper to database
            async function savePaper() {
                const title = document
                    .getElementById("paper-title")
                    .value.trim();
                const authors = document
                    .getElementById("paper-authors")
                    .value.trim();
                const abstract = document
                    .getElementById("paper-abstract")
                    .value.trim();
                const date = document.getElementById("paper-date").value;
                const url = document.getElementById("eprint-url").value.trim();
                const folder = document.getElementById("paper-folder").value;

                // Allow saving if either main fields are filled OR previous works are selected
                const hasMainContent = title && authors && date && url;
                const hasPreviousWorks = document.getElementById("previous-works").selectedOptions.length > 0;

                if (!hasMainContent && !hasPreviousWorks) {
                    showMessage("Please fill in the main fields OR select some previous works", "error");
                    return;
                }

                // If only previous works selected, create a minimal paper entry
                if (!hasMainContent && hasPreviousWorks) {
                    const previousWorks = Array.from(
                        document.getElementById("previous-works").selectedOptions,
                    ).map((option) => parseInt(option.value));

                    const paper = {
                        id: Date.now() + Math.random(),
                        title: "Previous Works Collection",
                        authors: "",
                        abstract: "",
                        date: new Date().toISOString(),
                        url: "",
                        labelSets: [],
                        previousWorks,
                        addedDate: new Date().toISOString(),
                        folder: folder,
                        scratchpad: "",
                        readingStatus: "referenced",
                        contactEmails: [],
                        favorite: false,
                        isPlaceholder: true,
                    };

                    papers.push(paper);

                    // Track change
                    trackChange('add', paper);

                    console.log(`[FORM DEBUG] ✅ Added previous works collection with ${previousWorks.length} papers`);
                    const saveSuccess = await savePapers();

                    if (saveSuccess) {
                        showMessage("Previous works added successfully!", "success");
                        document.getElementById("add-paper-form").reset();
                        closeBatchAddModal();
                        performSearch();
                    }
                    return;
                }

                const labelSets = getLabelSets("add");
                const previousWorks = Array.from(
                    document.getElementById("previous-works").selectedOptions,
                ).map((option) => parseInt(option.value));

                const paper = {
                    id: Date.now() + Math.random(),
                    title,
                    authors,
                    abstract,
                    date,
                    url,
                    labelSets: labelSets,
                    previousWorks,
                    addedDate: new Date().toISOString(),
                    folder: folder,
                    scratchpad: "",
                    readingStatus: "referenced",
                    contactEmails: window.currentPaperContactEmails || [],
                    favorite: false,
                };

                // Clear temporary contact emails
                window.currentPaperContactEmails = null;

                papers.push(paper);

                // Track change
                trackChange('add', paper);

                console.log(
                    `[FORM DEBUG] ✅ Added paper: "${paper.title}" | Total papers: ${papers.length}`,
                );
                const saveSuccess = await savePapers();
                console.log(
                    `[FORM DEBUG] Save operation ${saveSuccess ? "succeeded" : "failed"}`,
                );

                // Invalidate caches when data changes
                invalidateSearchCache();
                paperElementCache.clear();

                // Reset form
                document.getElementById("eprint-url").value = "";
                document.getElementById("paper-title").value = "";
                document.getElementById("paper-authors").value = "";
                document.getElementById("paper-abstract").value = "";
                document.getElementById("paper-date").value = "";
                document.getElementById("paper-folder").value = "";
                document.getElementById("page-content").value = "";
                document.getElementById("metadata-form").style.display = "none";
                document.getElementById("manual-parser").style.display = "none";

                // Reset label sets
                const labelSetsContainer =
                    document.getElementById("add-label-sets");
                if (labelSetsContainer) {
                    labelSetsContainer.innerHTML = "";
                    setTimeout(() => addNewLabelSet("add"), 50);
                }

                performSearch(); // Maintain current search state
                renderGraph();
                updatePreviousWorksSelect();
                setupPreviousWorksListeners();

                showMessage("Paper saved successfully!", "success");
            }

            // Get all subfolders of a folder (including the folder itself)
            function getAllSubfolders(folderName) {
                const subfolders = new Set([folderName]);

                function addSubfoldersRecursively(parentName) {
                    folders.forEach((folder) => {
                        if (folder.parent === parentName) {
                            subfolders.add(folder.name);
                            addSubfoldersRecursively(folder.name);
                        }
                    });
                }

                addSubfoldersRecursively(folderName);
                return subfolders;
            }

            // Check if a paper belongs to the current folder or any of its subfolders
            function isPaperInCurrentFolderHierarchy(paper) {
                const allowedFolders = getAllSubfolders(currentFolder);
                return allowedFolders.has(paper.folder);
            }

            // Advanced search functions - Proper recursive descent parser
            function evaluateAdvancedQuery(query, paper) {
                console.log(
                    `DEBUG: evaluateAdvancedQuery called with query="${query}" for paper="${paper.title}"`,
                );

                // For simple queries without operators or field searches, do basic text search
                // Improved detection: check if operators are actually used as operators (not just words)
                const hasRealOperators = query.match(/\b(AND|OR|NOT)\s+\w/i);
                const hasFieldSearches = query.match(/(title|author|abstract|year|status|email|date):/i);
                const hasQuotes = query.includes('"');
                const hasParens = query.includes("(") || query.includes(")");

                if (!hasRealOperators && !hasFieldSearches && !hasQuotes && !hasParens) {
                    const searchText =
                        `${paper.title} ${paper.authors} ${paper.abstract}`.toLowerCase();
                    const result = searchText.includes(query.toLowerCase());
                    console.log(`DEBUG: Simple search "${query}" -> ${result}`);
                    return result;
                }

                try {
                    const tokens = tokenizeQuery(query);
                    console.log(`DEBUG: Tokens for "${query}":`, tokens);
                    const parser = new QueryParser(tokens, paper);
                    const result = parser.parseExpression();
                    console.log(
                        `DEBUG: Advanced search "${query}" -> ${result}`,
                    );
                    return result;
                } catch (e) {
                    console.warn(
                        `Query parsing failed: ${e.message}, falling back to simple search`,
                    );
                    // Fallback to simple text search
                    const searchText =
                        `${paper.title} ${paper.authors} ${paper.abstract}`.toLowerCase();
                    const result = searchText.includes(query.toLowerCase());
                    console.log(
                        `DEBUG: Fallback search "${query}" -> ${result}`,
                    );
                    return result;
                }
            }

            // Tokenizer for query parsing
            function tokenizeQuery(query) {
                const tokens = [];
                let i = 0;

                while (i < query.length) {
                    // Skip whitespace
                    while (i < query.length && /\s/.test(query[i])) {
                        i++;
                    }

                    if (i >= query.length) break;

                    // Handle quoted strings (including quoted field searches)
                    if (query[i] === '"') {
                        let start = i + 1;
                        i++;
                        while (i < query.length && query[i] !== '"') {
                            i++;
                        }
                        if (i < query.length) i++; // Skip closing quote
                        const quotedContent = query.slice(start, i - 1);

                        // Check if this is a quoted field search like "author:alice silverberg"
                        const fieldMatch = quotedContent.match(
                            /^(title|author|abstract|year|status|email|date):(.+)$/i,
                        );
                        if (fieldMatch) {
                            tokens.push({
                                type: "FIELD_SEARCH",
                                field: fieldMatch[1].toLowerCase(),
                                value: fieldMatch[2].trim(),
                            });
                        } else {
                            tokens.push({
                                type: "QUOTED_STRING",
                                value: quotedContent,
                            });
                        }
                        continue;
                    }

                    // Handle parentheses
                    if (query[i] === "(") {
                        tokens.push({ type: "LPAREN", value: "(" });
                        i++;
                        continue;
                    }

                    if (query[i] === ")") {
                        tokens.push({ type: "RPAREN", value: ")" });
                        i++;
                        continue;
                    }

                    // Handle field searches (field:value or field:"quoted value")
                    const fieldMatch = query
                        .slice(i)
                        .match(/^(title|author|abstract|year|status|email|date):/i);
                    if (fieldMatch) {
                        const field = fieldMatch[1].toLowerCase();
                        i += fieldMatch[0].length;

                        // Skip whitespace after colon
                        while (i < query.length && /\s/.test(query[i])) {
                            i++;
                        }

                        // Get the value after the colon
                        let value = "";
                        if (i < query.length && query[i] === '"') {
                            // Quoted field value
                            i++; // Skip opening quote
                            let start = i;
                            while (i < query.length && query[i] !== '"') {
                                i++;
                            }
                            value = query.slice(start, i);
                            if (i < query.length) i++; // Skip closing quote
                        } else {
                            // Unquoted field value - collect until operator, parenthesis, or another field
                            let start = i;
                            while (i < query.length) {
                                // Stop at parentheses
                                if (/[()]/.test(query[i])) {
                                    break;
                                }
                                // Stop at operators (with word boundaries)
                                if (
                                    query.slice(i).match(/^\s*(AND|OR|NOT)\s+/i)
                                ) {
                                    break;
                                }
                                // Stop at another field search
                                if (
                                    query
                                        .slice(i)
                                        .match(
                                            /^\s+(title|author|abstract|year|status|email):/i,
                                        )
                                ) {
                                    break;
                                }
                                i++;
                            }
                            value = query.slice(start, i).trim();
                        }

                        tokens.push({
                            type: "FIELD_SEARCH",
                            field: field,
                            value: value,
                        });
                        continue;
                    }

                    // Handle operators
                    const operatorMatch = query
                        .slice(i)
                        .match(/^(AND|OR|NOT)\b/i);
                    if (operatorMatch) {
                        tokens.push({
                            type: "OPERATOR",
                            value: operatorMatch[1].toUpperCase(),
                        });
                        i += operatorMatch[0].length;
                        continue;
                    }

                    // Handle regular words
                    let start = i;
                    while (
                        i < query.length &&
                        !/[\s()]/.test(query[i]) &&
                        !query.slice(i).match(/^\s*(AND|OR|NOT)/i)
                    ) {
                        i++;
                    }

                    if (i > start) {
                        tokens.push({
                            type: "WORD",
                            value: query.slice(start, i),
                        });
                    }
                }

                return tokens;
            }

            // Query parser class
            class QueryParser {
                constructor(tokens, paper) {
                    this.tokens = tokens;
                    this.paper = paper;
                    this.pos = 0;
                }

                parseExpression() {
                    return this.parseOr();
                }

                parseOr() {
                    let left = this.parseAnd();

                    while (
                        this.peek() &&
                        this.peek().type === "OPERATOR" &&
                        this.peek().value === "OR"
                    ) {
                        this.consume(); // consume OR
                        const right = this.parseAnd();
                        left = left || right;
                    }

                    return left;
                }

                parseAnd() {
                    let left = this.parseNot();

                    while (
                        this.peek() &&
                        ((this.peek().type === "OPERATOR" &&
                            this.peek().value === "AND") ||
                            (this.peek().type !== "OPERATOR" &&
                                this.peek().type !== "RPAREN"))
                    ) {
                        if (
                            this.peek().type === "OPERATOR" &&
                            this.peek().value === "AND"
                        ) {
                            this.consume(); // consume AND
                        }
                        // Implicit AND for adjacent terms

                        const right = this.parseNot();
                        left = left && right;
                    }

                    return left;
                }

                parseNot() {
                    if (
                        this.peek() &&
                        this.peek().type === "OPERATOR" &&
                        this.peek().value === "NOT"
                    ) {
                        this.consume(); // consume NOT
                        return !this.parsePrimary();
                    }

                    return this.parsePrimary();
                }

                parsePrimary() {
                    const token = this.peek();

                    if (!token) {
                        throw new Error("Unexpected end of query");
                    }

                    if (token.type === "LPAREN") {
                        this.consume(); // consume (
                        const result = this.parseExpression();
                        if (!this.peek() || this.peek().type !== "RPAREN") {
                            throw new Error("Missing closing parenthesis");
                        }
                        this.consume(); // consume )
                        return result;
                    }

                    if (token.type === "FIELD_SEARCH") {
                        this.consume();
                        return this.evaluateFieldSearch(
                            token.field,
                            token.value,
                        );
                    }

                    if (token.type === "QUOTED_STRING") {
                        this.consume();
                        return this.evaluateTextSearch(token.value);
                    }

                    if (token.type === "WORD") {
                        this.consume();
                        return this.evaluateTextSearch(token.value);
                    }

                    throw new Error(`Unexpected token: ${token.type}`);
                }

                peek() {
                    return this.pos < this.tokens.length
                        ? this.tokens[this.pos]
                        : null;
                }

                consume() {
                    return this.pos < this.tokens.length
                        ? this.tokens[this.pos++]
                        : null;
                }

                evaluateFieldSearch(field, value) {
                    const paper = this.paper;
                    let result = false;

                    // Check for case-sensitive search (# prefix)
                    let caseSensitive = false;
                    if (value.startsWith("#")) {
                        caseSensitive = true;
                        value = value.substring(1); // Remove # prefix
                    }

                    // Only log for date searches with "unknown" to reduce spam
                    if (field === "date" && value.toLowerCase().includes("unknown")) {
                        console.log(
                            `DEBUG: Date search ${field}:"${value}" on paper "${paper.title}" (actual date: "${paper.date}")`,
                        );
                    }

                    switch (field) {
                        case "title":
                            if (caseSensitive) {
                                result = paper.title.includes(value);
                            } else {
                                result = paper.title
                                    .toLowerCase()
                                    .includes(value.toLowerCase());
                            }
                            console.log(
                                `DEBUG: Title search: "${value}" in "${paper.title}" = ${result} (case sensitive: ${caseSensitive})`,
                            );
                            break;
                        case "author":
                            if (caseSensitive) {
                                result = paper.authors.includes(value);
                            } else {
                                result = paper.authors
                                    .toLowerCase()
                                    .includes(value.toLowerCase());
                            }
                            console.log(
                                `DEBUG: Author search: "${value}" in "${paper.authors}" = ${result} (case sensitive: ${caseSensitive})`,
                            );
                            break;
                        case "abstract":
                            const abstractText = paper.abstract || "";
                            if (caseSensitive) {
                                result = abstractText.includes(value);
                            } else {
                                result = abstractText
                                    .toLowerCase()
                                    .includes(value.toLowerCase());
                            }
                            break;
                        case "year":
                            const paperYear = new Date(
                                paper.date,
                            ).getFullYear();
                            result = evaluateYearCondition(paperYear, value);
                            break;
                        case "status":
                            const paperStatus =
                                paper.readingStatus || "referenced";
                            result =
                                paperStatus.toLowerCase() ===
                                value.toLowerCase();
                            break;
                        case "email":
                            const paperEmails = paper.contactEmails || [];
                            result = paperEmails.some((email) =>
                                email
                                    .toLowerCase()
                                    .includes(value.toLowerCase()),
                            );
                            break;
                        case "date":
                            const paperDate = paper.date || "Unknown date";
                            // Handle special searches like "unknown date"
                            if (value.toLowerCase().includes("unknown")) {
                                // Check for various unknown date representations
                                const dateObj = new Date(paper.date);
                                const isInvalidDate = isNaN(dateObj.getTime());

                                result = !paper.date ||
                                        paper.date === "" ||
                                        paper.date === "Unknown" ||
                                        paper.date === "Unknown date" ||
                                        (paper.date && paper.date.toLowerCase().includes("unknown")) ||
                                        isInvalidDate;

                                // Debug logging for unknown date search
                                if (value.toLowerCase().includes("unknown")) {
                                    console.log(`  Paper "${paper.title}": date="${paper.date}", isEmpty=${!paper.date}, isEmptyString=${paper.date === ""}, isInvalidDate=${isInvalidDate}, result=${result}`);
                                }
                            } else if (value.match(/^[<>=]\d{4}$/)) {
                                // Handle year comparisons like <1999, >2020, =2018
                                const paperYear = new Date(paper.date).getFullYear();
                                result = evaluateYearCondition(paperYear, value);
                            } else {
                                // Regular date search
                                result = paperDate
                                    .toLowerCase()
                                    .includes(value.toLowerCase());
                            }
                            break;
                        default:
                            result = false;
                    }

                    console.log(
                        `DEBUG: Field search ${field}:"${value}" final result = ${result}`,
                    );
                    return result;
                }

                evaluateTextSearch(text) {
                    const searchText =
                        `${this.paper.title} ${this.paper.authors} ${this.paper.abstract}`.toLowerCase();
                    return searchText.includes(text.toLowerCase());
                }
            }

            function evaluateYearCondition(paperYear, condition) {
                // Handle year ranges like 2020-2022
                if (condition.includes("-")) {
                    const [startYear, endYear] = condition
                        .split("-")
                        .map((y) => parseInt(y.trim()));
                    if (!isNaN(startYear) && !isNaN(endYear)) {
                        return paperYear >= startYear && paperYear <= endYear;
                    }
                }

                // Handle comparison operators
                if (condition.startsWith(">=")) {
                    const targetYear = parseInt(condition.substring(2));
                    return !isNaN(targetYear) && paperYear >= targetYear;
                } else if (condition.startsWith("<=")) {
                    const targetYear = parseInt(condition.substring(2));
                    return !isNaN(targetYear) && paperYear <= targetYear;
                } else if (condition.startsWith(">")) {
                    const targetYear = parseInt(condition.substring(1));
                    return !isNaN(targetYear) && paperYear > targetYear;
                } else if (condition.startsWith("<")) {
                    const targetYear = parseInt(condition.substring(1));
                    return !isNaN(targetYear) && paperYear < targetYear;
                } else {
                    // Exact year match
                    const targetYear = parseInt(condition);
                    return !isNaN(targetYear) && paperYear === targetYear;
                }
            }

            // Perform search
            function performSearch() {
                if (papers.length === 0) {
                    const container = document.getElementById("papers-list");
                    if (container) {
                        container.innerHTML =
                            '<div class="loading">No papers added yet. Add your first paper to get started!</div>';
                    }
                    return;
                }

                const query =
                    document.getElementById("search-query")?.value.trim() || "";

                searchFilters.query = query;

                try {
                    // Get filtered papers
                    const filteredPapers = getCurrentlyFilteredPapers();

                    console.log(`DEBUG SEARCH: Query="${query}", Found=${filteredPapers.length} papers`);
                    if (query.includes("date:") && query.includes("unknown")) {
                        console.log("DEBUG: Checking first 5 papers for unknown dates:");
                        filteredPapers.slice(0, 5).forEach((paper, i) => {
                            console.log(`  Paper ${i}: title="${paper.title}", date="${paper.date}"`);
                        });
                    }

                    currentlyFilteredPapers = filteredPapers;

                    renderPapers(filteredPapers);
                } catch (error) {
                    console.error("Error in performSearch:", error);
                    // Fallback: show all papers if search fails
                    currentlyFilteredPapers = papers;
                    renderPapers(papers);
                }

                // Update graph to show only filtered papers (debounced for performance)
                if (
                    document.getElementById("graph-display")?.style.display !==
                    "none"
                ) {
                    if (window.graphUpdateTimeout) {
                        clearTimeout(window.graphUpdateTimeout);
                    }
                    window.graphUpdateTimeout = setTimeout(() => {
                        console.log(`[GRAPH UPDATE DEBUG] Graph update timeout triggered - currentlyFilteredPapers:`, currentlyFilteredPapers.length);
                        renderGraph();
                    }, 100);
                }
            }

            // Clear all filters
            function clearFilters() {
                searchFilters.included.clear();
                searchFilters.excluded.clear();
                searchFilters.query = "";
                favoriteFilterActive = false;

                document.getElementById("search-query").value = "";
                document
                    .querySelectorAll("#search-labels .label-chip")
                    .forEach((chip) => {
                        chip.classList.remove("selected", "excluded");
                    });

                // Reset favorite filter button
                const favoriteBtn = document.getElementById(
                    "favorite-filter-btn",
                );
                if (favoriteBtn) {
                    favoriteBtn.style.background = "";
                    favoriteBtn.style.color = "";
                    favoriteBtn.textContent = "⭐ Favorites";
                }

                updateSearchFiltersDisplay();
                currentlyFilteredPapers = [];
                performSearch(); // Use performSearch to properly reset view

                // Update graph when filters are cleared
                if (
                    document.getElementById("graph-display").style.display !==
                    "none"
                ) {
                    renderGraph();
                }
            }

            // Render papers list
            // Virtual scrolling state
            let virtualScrollState = {
                itemHeight: 150, // Estimated height per paper item
                containerHeight: 0,
                scrollTop: 0,
                visibleStart: 0,
                visibleEnd: 0,
                buffer: 5, // Extra items to render above/below visible area
            };

            function createPaperElement(paper) {
                const cacheKey = `${paper.id}-${currentViewMode}-${paperSelectionMode}-${paper.favorite}-${paper.scratchpad && paper.scratchpad.trim() ? "has-content" : "no-content"}-${selectedPapers.has(paper.id)}`;

                if (paperElementCache.has(cacheKey)) {
                    return paperElementCache.get(cacheKey);
                }

                const element = document.createElement("div");
                element.className = `paper-item ${currentViewMode}${paper.isPlaceholder ? " placeholder-paper" : ""}${paperSelectionMode ? " selectable" : ""}${paperSelectionMode && selectedPapers.has(paper.id) ? " selected" : ""}`;
                element.setAttribute("data-paper-id", paper.id);

                element.innerHTML = `
                    <div class="favorite-star-icon ${paper.favorite ? "favorited" : ""}" data-paper-id="${paper.id}" data-action="favorite" title="${paper.favorite ? "Remove from favorites" : "Add to favorites"}">${paper.favorite ? "⭐" : "☆"}</div>
                    <div class="scratchpad-icon${paper.scratchpad && paper.scratchpad.trim() ? " has-content" : ""}" data-paper-id="${paper.id}" data-action="scratchpad" title="${paper.scratchpad && paper.scratchpad.trim() ? "Open scratchpad (has content)" : "Open scratchpad"}">📝</div>
                    ${paper.contactEmails && paper.contactEmails.length > 0 ? `<div class="email-contact-icon" data-paper-id="${paper.id}" data-action="email" title="Email authors (${paper.contactEmails.length} contacts)">📧</div>` : ""}
                    <div class="reading-status-icon ${paper.readingStatus || "referenced"}" data-paper-id="${paper.id}" data-action="status" title="${getReadingStatusLabel(paper.readingStatus || "referenced")}">${getReadingStatusIcon(paper.readingStatus || "referenced")}</div>
                    <div class="paper-title">${paperSelectionMode ? `<input type="checkbox" class="paper-checkbox" ${selectedPapers.has(paper.id) ? "checked" : ""} data-paper-id="${paper.id}" data-action="checkbox">` : ""}${escapeHtml(paper.title)}${paper.isPlaceholder ? ' <span class="placeholder-indicator">(needs metadata)</span>' : ""}</div>
                    <div class="paper-authors">${escapeHtml(paper.authors)}</div>
                    <div class="paper-date">${new Date(paper.date).toLocaleDateString()}</div>
                    ${currentViewMode === "expanded" ? `<div class="paper-abstract">${escapeHtml(paper.abstract || "No abstract available")}</div>` : ""}
                    ${currentViewMode === "expanded" && paper.url ? `<div class="paper-url"><a href="${paper.url}" target="_blank" onclick="event.stopPropagation()">${paper.url}</a></div>` : ""}
                    <div class="paper-label-sets">
                        ${(paper.labelSets || [])
                            .map(
                                (labelSet) => `
                            <div class="paper-label-set">
                                ${labelSet.name ? `<span class="paper-label-set-name">${escapeHtml(labelSet.name)}:</span>` : ""}
                                ${labelSet.labels
                                    .map((label) => {
                                        const annotation =
                                            labelSet.annotations &&
                                            labelSet.annotations[label]
                                                ? ` (${escapeHtml(labelSet.annotations[label])})`
                                                : "";
                                        return `<span class="label-chip">${escapeHtml(label)}${annotation}</span>`;
                                    })
                                    .join("")}
                            </div>
                        `,
                            )
                            .join("")}
                    </div>
                `;

                // Add single event listener for the entire paper element
                element.addEventListener("click", (e) => {
                    const target = e.target;
                    const action = target.getAttribute("data-action");
                    const paperId = target.getAttribute("data-paper-id");

                    if (action && paperId) {
                        e.preventDefault();
                        e.stopPropagation();

                        switch (action) {
                            case "favorite":
                                toggleFavorite(paperId);
                                break;
                            case "scratchpad":
                                openScratchpad(paperId);
                                break;
                            case "email":
                                emailAuthors(paperId);
                                break;
                            case "status":
                                cycleReadingStatus(paperId);
                                break;
                            case "checkbox":
                                togglePaperSelection(paperId);
                                break;
                        }
                        return false;
                    } else {
                        // Default paper click behavior
                        e.preventDefault();
                        e.stopPropagation();
                        if (paperSelectionMode) {
                            togglePaperSelection(paper.id);
                        } else {
                            viewPaper(paper.id);
                        }
                    }
                });

                // Cache the element if cache isn't too large
                if (paperElementCache.size < 1000) {
                    paperElementCache.set(cacheKey, element.cloneNode(true));
                }

                return element;
            }

            function calculateVisibleRange(
                scrollTop,
                containerHeight,
                totalItems,
            ) {
                const start = Math.max(
                    0,
                    Math.floor(scrollTop / virtualScrollState.itemHeight) -
                        virtualScrollState.buffer,
                );
                const visibleCount = Math.ceil(
                    containerHeight / virtualScrollState.itemHeight,
                );
                const end = Math.min(
                    totalItems,
                    start + visibleCount + virtualScrollState.buffer * 2,
                );
                return { start, end };
            }

            function renderPapersVirtual(papersToRender) {
                const container = document.getElementById("papers-list");
                if (!container) return;

                // Ensure we have valid papers to render
                if (!papersToRender || papersToRender.length === 0) {
                    console.warn("renderPapersVirtual called with no papers");
                    return;
                }

                const { start, end } = calculateVisibleRange(
                    virtualScrollState.scrollTop,
                    virtualScrollState.containerHeight,
                    papersToRender.length,
                );

                // Create container for virtual scrolling if it doesn't exist
                let virtualContainer = container.querySelector(
                    ".virtual-scroll-container",
                );
                if (!virtualContainer) {
                    virtualContainer = document.createElement("div");
                    virtualContainer.className = "virtual-scroll-container";
                    virtualContainer.style.position = "relative";
                    container.appendChild(virtualContainer);
                }

                // Set total height for scrollbar
                virtualContainer.style.height = `${papersToRender.length * virtualScrollState.itemHeight}px`;

                // Clear visible content
                const existingContent =
                    virtualContainer.querySelector(".virtual-content");
                if (existingContent) {
                    existingContent.remove();
                }

                // Create content container
                const contentContainer = document.createElement("div");
                contentContainer.className = "virtual-content";
                contentContainer.style.position = "absolute";
                contentContainer.style.top = `${start * virtualScrollState.itemHeight}px`;
                contentContainer.style.width = "100%";

                // Render visible papers
                for (let i = start; i < end; i++) {
                    if (i >= papersToRender.length) break;
                    const paper = papersToRender[i];
                    if (!paper) continue;
                    const element = createPaperElement(paper);
                    contentContainer.appendChild(element);
                }

                virtualContainer.appendChild(contentContainer);
                virtualScrollState.visibleStart = start;
                virtualScrollState.visibleEnd = end;
            }

            function renderPapers(papersToRender = null) {
                const container = document.getElementById("papers-list");
                if (!container) {
                    console.error(
                        "renderPapers: papers-list container not found",
                    );
                    return;
                }

                // If no papers provided, use currently filtered papers if available
                if (!papersToRender) {
                    if (currentlyFilteredPapers.length > 0) {
                        papersToRender = currentlyFilteredPapers;
                    } else {
                        papersToRender = papers.filter(
                            isPaperInCurrentFolderHierarchy,
                        );

                        // Apply favorite filter if active
                        if (favoriteFilterActive) {
                            papersToRender = papersToRender.filter(
                                (paper) => paper.favorite,
                            );
                        }
                    }
                }

                console.log(`DEBUG RENDER: About to render ${papersToRender.length} papers`);

                if (papersToRender.length === 0) {
                    const folderText =
                        currentFolder && currentFolder !== ""
                            ? ` in "${currentFolder}"`
                            : "";
                    container.innerHTML = `<div class="loading">No papers found${folderText}</div>`;
                    console.log("DEBUG RENDER: No papers to render, showing 'No papers found'");
                    return;
                }

                // Sort papers based on current sort order
                const sortedPapers = sortPapers([...papersToRender]);

                // Update reading status statistics
                updateReadingStatusStats(papersToRender);

                // Temporarily disable virtual scrolling to fix search interaction issues
                // Use regular rendering for all datasets
                container.innerHTML = sortedPapers
                    .map(
                        (paper) => `
                                    <div class="paper-item ${currentViewMode}${paper.isPlaceholder ? " placeholder-paper" : ""}${paperSelectionMode ? " selectable" : ""}${paperSelectionMode && selectedPapers.has(paper.id) ? " selected" : ""}" data-paper-id="${paper.id}" onclick="${paperSelectionMode ? `togglePaperSelection('${paper.id}')` : `viewPaper('${paper.id}')`}">
                                        <div class="favorite-star-icon ${paper.favorite ? "favorited" : ""}" onclick="event.stopPropagation(); toggleFavorite('${paper.id}')" title="${paper.favorite ? "Remove from favorites" : "Add to favorites"}">${paper.favorite ? "⭐" : "☆"}</div>
                                        <div class="scratchpad-icon${paper.scratchpad && paper.scratchpad.trim() ? " has-content" : ""}" onclick="event.stopPropagation(); openScratchpad('${paper.id}')" title="${paper.scratchpad && paper.scratchpad.trim() ? "Open scratchpad (has content)" : "Open scratchpad"}">📝</div>
                                        ${paper.contactEmails && paper.contactEmails.length > 0 ? `<div class="email-contact-icon" onclick="event.stopPropagation(); emailAuthors('${paper.id}')" title="Email authors (${paper.contactEmails.length} contacts)">📧</div>` : ""}
                                        <div class="reading-status-icon ${paper.readingStatus || "referenced"}" onclick="event.stopPropagation(); cycleReadingStatus('${paper.id}')" title="${getReadingStatusLabel(paper.readingStatus || "referenced")}">${getReadingStatusIcon(paper.readingStatus || "referenced")}</div>
                                        <div class="paper-title">${paperSelectionMode ? `<input type="checkbox" class="paper-checkbox" ${selectedPapers.has(paper.id) ? "checked" : ""} onclick="event.stopPropagation(); togglePaperSelection('${paper.id}')">` : ""}${escapeHtml(paper.title)}${paper.isPlaceholder ? ' <span class="placeholder-indicator">(needs metadata)</span>' : ""}</div>
                                        <div class="paper-authors">${escapeHtml(paper.authors)}</div>
                                        <div class="paper-date">${new Date(paper.date).toLocaleDateString()}</div>
                                        ${currentViewMode === "expanded" ? `<div class="paper-abstract">${escapeHtml(paper.abstract || "No abstract available")}</div>` : ""}
                                        ${currentViewMode === "expanded" && paper.url ? `<div class="paper-url"><a href="${paper.url}" target="_blank" onclick="event.stopPropagation()">${paper.url}</a></div>` : ""}
                                        <div class="paper-label-sets">
                                            ${(paper.labelSets || [])
                                                .map(
                                                    (labelSet) => `
                                                <div class="paper-label-set">
                                                    ${labelSet.name ? `<span class="paper-label-set-name">${escapeHtml(labelSet.name)}:</span>` : ""}
                                                    ${labelSet.labels
                                                        .map((label) => {
                                                            const annotation =
                                                                labelSet.annotations &&
                                                                labelSet
                                                                    .annotations[
                                                                    label
                                                                ]
                                                                    ? ` (${escapeHtml(labelSet.annotations[label])})`
                                                                    : "";
                                                            return `<span class="label-chip">${escapeHtml(label)}${annotation}</span>`;
                                                        })
                                                        .join("")}
                                                </div>
                                            `,
                                                )
                                                .join("")}
                                        </div>
                                    </div>
                                `,
                    )
                    .join("");
            }

            // Escape HTML to prevent XSS
            function escapeHtml(text) {
                const div = document.createElement("div");
                div.textContent = text;
                return div.innerHTML;
            }

            // View paper details
            function viewPaper(paperId) {
                const paper = papers.find(
                    (p) => p.id.toString() === paperId.toString(),
                );
                if (!paper) return;

                currentEditingPaper = paper;

                const previousWorks =
                    paper.previousWorks || paper.relatedPapers || [];
                const relatedTitles =
                    previousWorks
                        .map((index) => papers[index]?.title)
                        .filter((title) => title)
                        .join(", ") || "None";

                // Update the refresh metadata button with the correct paper ID
                const refreshBtn = document.getElementById(
                    "refresh-metadata-btn",
                );
                if (refreshBtn) {
                    refreshBtn.setAttribute(
                        "onclick",
                        `refreshMetadata('${paper.id}')`,
                    );
                }

                document.getElementById("paper-details").innerHTML = `
                                <div class="input-group">
                                    <label><strong>Title</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px;">${escapeHtml(paper.title)}</div>
                                </div>
                                <div class="input-group">
                                    <label><strong>Authors</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px;">${escapeHtml(paper.authors)}</div>
                                </div>
                                <div class="input-group">
                                    <label><strong>Date</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px;">${new Date(paper.date).toLocaleDateString()}</div>
                                </div>
                                <div class="input-group">
                                    <label><strong>Folder</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px;">${paper.folder || "Root"}</div>
                                </div>
                                <div class="input-group">
                                    <label><strong>Reading Status</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px; display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 18px;">${getReadingStatusIcon(paper.readingStatus || "referenced")}</span>
                                        <span style="font-weight: 500; color: #555;">${getReadingStatusLabel(paper.readingStatus || "referenced")}</span>
                                        <button class="btn btn-secondary" style="margin-left: auto; padding: 4px 8px; font-size: 12px;" onclick="cycleReadingStatus('${paper.id}'); setTimeout(() => viewPaper('${paper.id}'), 100);">Change Status</button>
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label><strong>Abstract</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px; max-height: 150px; overflow-y: auto;">${escapeHtml(paper.abstract)}</div>
                                </div>
                                <div class="input-group">
                                    <label><strong>ePrint URL</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px;">
                                        <a href="${escapeHtml(paper.url)}" target="_blank" style="color: #667eea; text-decoration: none;">${escapeHtml(paper.url)}</a>
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label><strong>Scratchpad</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px; display: flex; align-items: center; gap: 8px;">
                                        <span>${paper.scratchpad && paper.scratchpad.trim() ? "📝 Has notes" : "📝 No notes yet"}</span>
                                        <button class="btn btn-secondary" style="margin-left: auto; padding: 4px 8px; font-size: 12px;" onclick="closePaperModal(); openScratchpad('${paper.id}');">Open Scratchpad</button>
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label><strong>Contact Authors</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px;">
                                        ${
                                            paper.contactEmails &&
                                            paper.contactEmails.length > 0
                                                ? `<div style="margin-bottom: 8px;">
                                                ${paper.contactEmails.map((email) => `<div style="margin: 4px 0; font-family: monospace; font-size: 13px; color: #555;">📧 ${escapeHtml(email)}</div>`).join("")}
                                               </div>
                                               <div style="display: flex; gap: 8px;">
                                                   <button class="btn btn-secondary" style="padding: 4px 8px; font-size: 12px;" onclick="emailAuthors('${paper.id}');">Email All Authors</button>
                                                   <button class="btn btn-secondary" style="padding: 4px 8px; font-size: 12px;" onclick="editContactEmails('${paper.id}');">Edit Emails</button>
                                               </div>`
                                                : `<div style="color: #666; font-style: italic;">No contact emails available</div>
                                               <button class="btn btn-secondary" style="padding: 4px 8px; font-size: 12px; margin-top: 8px;" onclick="editContactEmails('${paper.id}');">Add Emails</button>`
                                        }
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label><strong>Label Sets</strong></label>
                                    <div class="paper-label-sets" style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px;">
                                        ${
                                            (paper.labelSets || []).length > 0
                                                ? (paper.labelSets || [])
                                                      .map(
                                                          (labelSet) => `
                                                <div class="paper-label-set" style="margin: 6px 0;">
                                                    ${labelSet.name ? `<span class="paper-label-set-name">${escapeHtml(labelSet.name)}:</span>` : ""}
                                                    ${labelSet.labels
                                                        .map((label) => {
                                                            const annotation =
                                                                labelSet.annotations &&
                                                                labelSet
                                                                    .annotations[
                                                                    label
                                                                ]
                                                                    ? ` (${escapeHtml(labelSet.annotations[label])})`
                                                                    : "";
                                                            return `<span class="label-chip" style="background: rgba(102, 126, 234, 0.1); color: #667eea; margin: 2px;">${escapeHtml(label)}${annotation}</span>`;
                                                        })
                                                        .join("")}
                                                </div>
                                            `,
                                                      )
                                                      .join("")
                                                : `<div style="color: #666; font-style: italic;">No labels assigned</div>`
                                        }
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label><strong>Previous Works</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px;">${escapeHtml(relatedTitles)}</div>
                                </div>
                                <div class="input-group">
                                    <label><strong>ePrint URL</strong></label>
                                    <div style="padding: 12px; background: rgba(240, 242, 247, 0.5); border-radius: 8px;">
                                        <a href="${escapeHtml(paper.url)}" target="_blank" style="color: #667eea; text-decoration: none; word-break: break-all;">${escapeHtml(paper.url)}</a>
                                    </div>
                                </div>
                            `;

                document.getElementById("paper-modal").style.display = "block";
            }

            // Close paper modal
            function closePaperModal() {
                document.getElementById("paper-modal").style.display = "none";
                currentEditingPaper = null;
                document.getElementById("paper-details").style.display =
                    "block";
                document.getElementById("paper-edit-form").style.display =
                    "none";
            }

            // Open paper link
            function openPaperLink() {
                if (currentEditingPaper && currentEditingPaper.url) {
                    window.open(currentEditingPaper.url, "_blank");
                }
            }

            // Enable editing mode
            function enableEditing() {
                if (!currentEditingPaper) return;

                const paper = currentEditingPaper;

                document.getElementById("paper-edit-form").innerHTML = `
                                <div class="input-group">
                                    <label for="edit-title">Title</label>
                                    <input type="text" id="edit-title" value="${escapeHtml(paper.title)}">
                                </div>
                                <div class="input-group">
                                    <label for="edit-authors">Authors</label>
                                    <input type="text" id="edit-authors" value="${escapeHtml(paper.authors)}">
                                </div>
                                <div class="input-group">
                                    <label for="edit-date">Date</label>
                                    <input type="date" id="edit-date" value="${paper.date}">
                                </div>
                                <div class="input-group">
                                    <label for="edit-folder">Folder</label>
                                    <select id="edit-folder">
                                        <option value="">Root</option>
                                    </select>
                                </div>
                                <div class="input-group">
                                    <label for="edit-abstract">Abstract</label>
                                    <textarea id="edit-abstract" rows="6">${escapeHtml(paper.abstract)}</textarea>
                                </div>
                                <div class="input-group">
                                    <label for="edit-url">ePrint URL</label>
                                    <input type="url" id="edit-url" value="${escapeHtml(paper.url)}">
                                </div>
                                <div class="input-group">
                                    <label for="edit-contact-emails">Contact Emails (one per line)</label>
                                    <textarea id="edit-contact-emails" rows="3" placeholder="author1@example.com&#10;author2@example.com">${(paper.contactEmails || []).join("\n")}</textarea>
                                </div>

                                <div class="section-title">Label Sets</div>
                                <div class="label-sets-container">
                                    <div id="edit-label-sets"></div>
                                    <button type="button" class="add-label-set-btn" onclick="addNewLabelSet('edit')">
                                        <span>➕</span> Add New Label Set
                                    </button>
                                </div>

                                <div class="section-title">Previous Works</div>
                                <div class="related-papers-section">
                                    <div class="input-group">
                                        <label for="edit-previous-work-url">Add by ePrint URL</label>
                                        <div class="related-papers-url-input">
                                            <input type="url" id="edit-previous-work-url" placeholder="https://eprint.iacr.org/YYYY/NNN">
                                            <button type="button" class="btn" onclick="addEditPreviousWorkByUrl()">
                                                <span>➕</span> Add
                                            </button>
                                        </div>
                                    </div>
                                    <div class="input-group">
                                        <label>Search and select from existing papers</label>
                                        <input type="text" id="edit-previous-work-search" placeholder="Search existing papers..." oninput="searchEditPreviousWorks()" class="related-papers-search">
                                        <select id="edit-previous-works" multiple size="4" class="related-papers-select">
                                            <!-- Will be populated with existing papers -->
                                        </select>
                                    </div>
                                    <div class="input-group">
                                        <label>Selected papers:</label>
                                        <div id="edit-selected-previous-works" class="selected-papers-display">
                                            <em style="color: #999;">No papers selected</em>
                                        </div>
                                    </div>
                                </div>

                                <div style="display: flex; gap: 12px; margin-top: 20px;">
                                    <button class="btn btn-success" onclick="saveEditedPaper()">
                                        <span>💾</span> Save Changes
                                    </button>
                                    <button class="btn" onclick="cancelEditing()">
                                        <span>❌</span> Cancel
                                    </button>
                                </div>
                            `;

                // Populate folder select and set current value
                populateFolderSelects();
                setTimeout(() => {
                    const editFolderSelect =
                        document.getElementById("edit-folder");
                    if (editFolderSelect) {
                        editFolderSelect.value = paper.folder || "";
                    }
                }, 100);

                // Populate label sets
                setTimeout(() => {
                    setLabelSets("edit", paper.labelSets || []);
                }, 100);

                // Populate previous works
                searchEditPreviousWorks();

                // Set selected previous works
                setTimeout(() => {
                    const previousWorksSelect = document.getElementById(
                        "edit-previous-works",
                    );
                    const previousWorks =
                        paper.previousWorks || paper.relatedPapers || [];
                    if (previousWorks) {
                        previousWorks.forEach((index) => {
                            const option = previousWorksSelect.querySelector(
                                `option[value="${index}"]`,
                            );
                            if (option) {
                                option.selected = true;
                            }
                        });
                    }
                    updateEditSelectedPreviousWorksDisplay();
                }, 200);

                document.getElementById("paper-details").style.display = "none";
                document.getElementById("paper-edit-form").style.display =
                    "block";
            }

            // Search edit related papers
            function searchEditPreviousWorks() {
                const searchTerm = document
                    .getElementById("edit-previous-work-search")
                    .value.toLowerCase();
                const select = document.getElementById("edit-previous-works");

                select.innerHTML = "";

                papers.forEach((paper, index) => {
                    if (
                        !searchTerm ||
                        paper.title.toLowerCase().includes(searchTerm) ||
                        paper.authors.toLowerCase().includes(searchTerm)
                    ) {
                        const option = document.createElement("option");
                        option.value = index;
                        option.textContent = paper.isPlaceholder
                            ? `${paper.title} (needs metadata)`
                            : paper.title;
                        select.appendChild(option);
                    }
                });
            }

            // Update display of selected edit related papers
            function updateEditSelectedPreviousWorksDisplay() {
                const select = document.getElementById("edit-previous-works");
                const display = document.getElementById(
                    "edit-selected-previous-works",
                );
                if (!select || !display) return;

                const selectedOptions = Array.from(select.selectedOptions);
                if (selectedOptions.length === 0) {
                    display.innerHTML =
                        '<em style="color: #999;">No papers selected</em>';
                } else {
                    display.innerHTML = selectedOptions
                        .map(
                            (option) =>
                                `<div class="selected-paper-item">${escapeHtml(option.textContent)}</div>`,
                        )
                        .join("");
                }
            }

            // Add related paper by URL in edit mode
            function addEditPreviousWorkByUrl() {
                const urlInput = document.getElementById(
                    "edit-previous-work-url",
                );
                const url = urlInput.value.trim();

                if (!url) {
                    showMessage("Please enter an ePrint URL", "error");
                    return;
                }

                const paperIdMatch = url.match(
                    /eprint\.iacr\.org\/(\d{4}\/\d+)$/,
                );
                if (!paperIdMatch) {
                    showMessage(
                        "Invalid ePrint URL format. Expected: https://eprint.iacr.org/YYYY/NNNN",
                        "error",
                    );
                    return;
                }

                const paperId = paperIdMatch[1];
                const existingPaper = papers.find((p) => p.url === url);

                if (existingPaper) {
                    const select = document.getElementById(
                        "edit-previous-works",
                    );
                    const paperIndex = papers.indexOf(existingPaper);
                    const option = select.querySelector(
                        `option[value="${paperIndex}"]`,
                    );
                    if (option) {
                        option.selected = true;
                        updateEditSelectedPreviousWorksDisplay();
                        showMessage(
                            "Selected existing paper from database",
                            "success",
                        );
                    }
                } else {
                    const placeholderPaper = {
                        id: Date.now() + Math.random(),
                        title: `Paper ${paperId} (placeholder)`,
                        authors: "Unknown Authors",
                        abstract: "Placeholder - add metadata via editing",
                        date: new Date().toISOString().split("T")[0],
                        url: url,
                        labelSets: [],
                        relatedPapers: [],
                        addedDate: new Date().toISOString(),
                        isPlaceholder: true,
                        folder: "",
                    };

                    papers.push(placeholderPaper);
                    savePapers();
                    searchEditPreviousWorks();

                    const select = document.getElementById(
                        "edit-previous-works",
                    );
                    const newIndex = papers.length - 1;
                    const option = select.querySelector(
                        `option[value="${newIndex}"]`,
                    );
                    if (option) {
                        option.selected = true;
                        updateEditSelectedPreviousWorksDisplay();
                    }

                    showMessage(
                        "Created placeholder paper - you can edit it later to add metadata",
                        "success",
                    );
                }

                urlInput.value = "";
            }

            // Cancel editing
            function cancelEditing() {
                document.getElementById("paper-details").style.display =
                    "block";
                document.getElementById("paper-edit-form").style.display =
                    "none";
            }

            // Save edited paper
            function saveEditedPaper() {
                if (!currentEditingPaper) return;

                const paperIndex = papers.findIndex(
                    (p) => p.id === currentEditingPaper.id,
                );
                if (paperIndex === -1) return;

                const title = document
                    .getElementById("edit-title")
                    .value.trim();
                const authors = document
                    .getElementById("edit-authors")
                    .value.trim();
                const abstract = document
                    .getElementById("edit-abstract")
                    .value.trim();
                const date = document.getElementById("edit-date").value;
                const url = document.getElementById("edit-url").value.trim();
                const folder = document.getElementById("edit-folder").value;
                const contactEmailsText = document
                    .getElementById("edit-contact-emails")
                    .value.trim();

                // Allow editing papers even with missing fields - don't force validation on edit
                // Users should be able to edit labels, previous works, etc. without fixing all metadata

                // Parse contact emails
                const contactEmails = contactEmailsText
                    .split("\n")
                    .map((email) => email.trim())
                    .filter((email) => email.length > 0 && email.includes("@"));

                console.log("[EDIT DEBUG] Getting label sets for edit mode");
                const labelSets = getLabelSets("edit");
                console.log("[EDIT DEBUG] Retrieved label sets:", labelSets);
                const previousWorks = Array.from(
                    document.getElementById("edit-previous-works")
                        .selectedOptions,
                ).map((option) => parseInt(option.value));

                const editSelect = document.getElementById(
                    "edit-previous-works",
                );
                if (
                    editSelect &&
                    !editSelect.hasAttribute("data-listener-added")
                ) {
                    editSelect.addEventListener(
                        "change",
                        updateEditSelectedPreviousWorksDisplay,
                    );
                    editSelect.setAttribute("data-listener-added", "true");
                }

                console.log("[EDIT DEBUG] Before update - paper labelSets:", papers[paperIndex].labelSets);

                // Store original paper for change tracking
                const originalPaper = { ...currentEditingPaper };

                papers[paperIndex] = {
                    ...papers[paperIndex],
                    title,
                    authors,
                    abstract,
                    date,
                    url,
                    labelSets: labelSets,
                    previousWorks,
                    folder: folder,
                    contactEmails: contactEmails,
                    isPlaceholder: false, // Remove placeholder status when edited
                };

                // Track change
                trackChange('modify', papers[paperIndex], originalPaper);

                console.log("[EDIT DEBUG] After update - paper labelSets:", papers[paperIndex].labelSets);

                // Invalidate caches when data changes
                invalidateSearchCache();
                paperElementCache.clear();

                console.log(
                    `[DELETE DEBUG] Deleted paper: "${currentEditingPaper.title}" | Remaining papers: ${papers.length}`,
                );
                savePapers();

                showMessage("Paper updated successfully!", "success");
                closePaperModal();
                performSearch(); // Maintain current search state
                renderGraph();
            }

            // Delete paper
            function deletePaper() {
                if (!currentEditingPaper) return;

                if (
                    confirm(
                        `Are you sure you want to delete "${currentEditingPaper.title}"?`,
                    )
                ) {
                    // Track change before deleting
                    trackChange('delete', currentEditingPaper);

                    papers = papers.filter(
                        (p) => p.id !== currentEditingPaper.id,
                    );

                    // Invalidate caches when data changes
                    invalidateSearchCache();
                    paperElementCache.clear();

                    updatePaperCount();
                    savePapers();

                    showMessage("Paper deleted successfully!", "success");
                    closePaperModal();
                    performSearch(); // Maintain current search state
                    if (
                        document.getElementById("graph-display").style
                            .display !== "none"
                    ) {
                        renderGraph();
                    }
                }
            }

            // Render relationship graph
            function toggleGraph() {
                const graphDisplay = document.getElementById("graph-display");
                const showBtn = document.getElementById("show-graph-btn");
                const hideBtn = document.getElementById("hide-graph-btn");

                const refreshBtn = document.getElementById("refresh-graph-btn");
                if (graphDisplay.style.display === "none") {
                    graphDisplay.style.display = "block";
                    showBtn.style.display = "none";
                    hideBtn.style.display = "inline-block";
                    refreshBtn.style.display = "inline-block";
                    renderGraph();
                } else {
                    graphDisplay.style.display = "none";
                    showBtn.style.display = "inline-block";
                    hideBtn.style.display = "none";
                    refreshBtn.style.display = "none";
                }
            }

            function refreshGraph() {
                // Clear any focused nodes and refresh graph with current search results
                focusedNode = null;
                renderGraph();
            }

            function renderGraph() {
                const graphDisplay = document.getElementById("graph-display");
                if (graphDisplay.style.display === "none") return;

                const svg = d3.select("#relationship-graph");
                svg.selectAll("*").remove();

                if (papers.length === 0) return;

                // Use currentlyFilteredPapers if available (for connected components), otherwise get filtered papers
                const filteredPapers = currentlyFilteredPapers.length > 0 ? currentlyFilteredPapers : getCurrentlyFilteredPapers();

                if (filteredPapers.length === 0) return;

                // Limit graph size for performance with large datasets
                const maxGraphNodes = 500;
                const graphPapers =
                    filteredPapers.length > maxGraphNodes
                        ? filteredPapers.slice(0, maxGraphNodes)
                        : filteredPapers;

                if (filteredPapers.length > maxGraphNodes) {
                    showMessage(
                        `Graph limited to ${maxGraphNodes} papers for performance. Apply filters to see specific papers.`,
                        "info",
                    );
                }

                const graphType =
                    document.getElementById("graph-type-select").value;

                const width = svg.node().clientWidth;
                const height = svg.node().clientHeight;

                let nodes = graphPapers.map((paper) => ({
                    id: paper.id,
                    title: paper.title,
                    date: paper.date,
                    labelSets: paper.labelSets || [],
                    authors: paper.authors,
                    isPlaceholder: paper.isPlaceholder || false,
                }));

                let links = [];

                if (graphType === "followup") {
                    // Follow-up graph (existing functionality)
                    graphPapers.forEach((paper) => {
                        const previousWorks =
                            paper.previousWorks || paper.relatedPapers || [];
                        if (previousWorks && previousWorks.length > 0) {
                            previousWorks.forEach((relatedIndex) => {
                                const referencedPaper = papers[relatedIndex];
                                // Only add link if both papers are in filtered results
                                if (
                                    referencedPaper &&
                                    graphPapers.some(
                                        (p) => p.id === referencedPaper.id,
                                    )
                                ) {
                                    links.push({
                                        source: referencedPaper.id,
                                        target: paper.id,
                                        sourceTitle: referencedPaper.title,
                                        targetTitle: paper.title,
                                        hasDirection: true,
                                    });
                                }
                            });

                            // Track change
                            trackChange('modify', paper, originalPaper);
                        }
                    });
                } else if (graphType === "author") {
                    // Author graph - connect papers with common authors
                    for (let i = 0; i < filteredPapers.length; i++) {
                        for (let j = i + 1; j < filteredPapers.length; j++) {
                            const paper1 = filteredPapers[i];
                            const paper2 = filteredPapers[j];

                            // Simple author matching (case-insensitive)
                            const authors1 = paper1.authors
                                .toLowerCase()
                                .split(/[,;&]/)
                                .map((a) => a.trim());
                            const authors2 = paper2.authors
                                .toLowerCase()
                                .split(/[,;&]/)
                                .map((a) => a.trim());

                            const hasCommonAuthor = authors1.some((a1) =>
                                authors2.some(
                                    (a2) => a1 === a2 && a1.length > 2,
                                ),
                            );

                            if (hasCommonAuthor) {
                                links.push({
                                    source: paper1.id,
                                    target: paper2.id,
                                    sourceTitle: paper1.title,
                                    targetTitle: paper2.title,
                                    hasDirection: false,
                                });
                            }
                        }
                    }
                }

                // Apply focus filter if a node is focused
                if (focusedNode) {
                    const focusedNodeIds = new Set([focusedNode]);

                    // Add all nodes connected to the focused node
                    links.forEach((link) => {
                        if (link.source === focusedNode) {
                            focusedNodeIds.add(link.target);
                        }
                        if (link.target === focusedNode) {
                            focusedNodeIds.add(link.source);
                        }
                    });

                    // Filter nodes and links to only show the focused subgraph
                    nodes = nodes.filter((node) => focusedNodeIds.has(node.id));
                    links = links.filter(
                        (link) =>
                            focusedNodeIds.has(link.source) &&
                            focusedNodeIds.has(link.target),
                    );
                }

                // Create arrow marker definition
                const defs = svg.append("defs");

                defs.append("marker")
                    .attr("id", "arrowhead")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 15)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", "#999");

                const simulation = d3
                    .forceSimulation(nodes)
                    .force(
                        "link",
                        d3
                            .forceLink(links)
                            .id((d) => d.id)
                            .distance(120)
                            .strength(0.3),
                    )
                    .force("charge", d3.forceManyBody().strength(-50))
                    .force(
                        "center",
                        d3.forceCenter(width / 2, height / 2).strength(0.05),
                    )
                    .force("collision", d3.forceCollide().radius(35))
                    .force("x", d3.forceX(width / 2).strength(0.02))
                    .force("y", d3.forceY(height / 2).strength(0.02))
                    .alphaDecay(0.05)
                    .velocityDecay(0.8)
                    .alpha(0.3);

                const link = svg
                    .append("g")
                    .selectAll("line")
                    .data(links)
                    .enter()
                    .append("line")
                    .attr("stroke", "#999")
                    .attr("stroke-opacity", 0.8)
                    .attr("stroke-width", 2)
                    .attr("marker-end", (d) =>
                        d.hasDirection ? "url(#arrowhead)" : null,
                    )
                    .style("cursor", "pointer");

                link.append("title").text(
                    (d) => `${d.sourceTitle} → ${d.targetTitle}`,
                );

                const node = svg
                    .append("g")
                    .selectAll("circle")
                    .data(nodes)
                    .enter()
                    .append("circle")
                    .attr("r", 12)
                    .attr("fill", (d) => {
                        if (d.isPlaceholder) return "#ccc";

                        // Handle invalid dates by using a default color
                        const dateTime = new Date(d.date).getTime();
                        if (isNaN(dateTime)) return "#999"; // Gray for invalid dates

                        const validNodes = nodes.filter((n) => !n.isPlaceholder && !isNaN(new Date(n.date).getTime()));
                        if (validNodes.length === 0) return "#667eea"; // Default blue

                        const minTime = Math.min(...validNodes.map((n) => new Date(n.date).getTime()));
                        const maxTime = Math.max(...validNodes.map((n) => new Date(n.date).getTime()));
                        const timeRange = maxTime - minTime || 1;
                        const position = (dateTime - minTime) / timeRange;
                        const hue = 240 + position * 60;
                        return `hsl(${hue}, 70%, 60%)`;
                    })
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 2)
                    .style("cursor", "pointer")
                    .call(
                        d3
                            .drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended),
                    )
                    .on("click", (event, d) => {
                        event.preventDefault();
                        event.stopPropagation();

                        // Check for Ctrl+click (Windows/Linux) or Cmd+click (Mac) for connected component
                        if (event.ctrlKey || event.metaKey) {
                            console.log(`[MODIFIER CLICK DEBUG] ${event.metaKey ? 'Cmd' : 'Ctrl'}+click on paper: ${d.title}`);
                            showConnectedComponent(d.id);
                            return;
                        }

                        // Simple single click - view paper
                        console.log(`[CLICK DEBUG] Single click on paper: ${d.title}`);
                        viewPaper(d.id);
                    })
                    .on("contextmenu", (event, d) => {
                        // Right-click alternative for connected component
                        event.preventDefault();
                        event.stopPropagation();
                        console.log(`[RIGHT CLICK DEBUG] Right click on paper: ${d.title}`);
                        showConnectedComponent(d.id);
                    });

                node.append("title").text((d) => {
                    const labelSetsText =
                        d.labelSets.length > 0
                            ? `\nLabel sets: ${d.labelSets.map((ls) => ls.name || "Unnamed").join(", ")}`
                            : "";
                    const focusText = focusedNode
                        ? "\nSingle-click: view details, Double-click: unfocus"
                        : "\nSingle-click: view details, Double-click: focus on connections";
                    return `${d.title}\n${d.authors}\n${new Date(d.date).toLocaleDateString()}${labelSetsText}${d.isPlaceholder ? "\n(Placeholder - needs metadata)" : ""}${focusText}`;
                });

                // Add labels
                const label = svg
                    .append("g")
                    .selectAll("text")
                    .data(nodes)
                    .enter()
                    .append("text")
                    .text((d) => {
                        const title =
                            d.title.length > 40
                                ? d.title.substring(0, 37) + "..."
                                : d.title;
                        return title;
                    })
                    .attr("font-size", "11px")
                    .attr("font-weight", "500")
                    .attr("dx", 18)
                    .attr("dy", 4)
                    .attr("fill", "#333")
                    .style("pointer-events", "none")
                    .style("user-select", "none");

                // Add date labels
                const dateLabel = svg
                    .append("g")
                    .selectAll("text")
                    .data(nodes)
                    .enter()
                    .append("text")
                    .text((d) => new Date(d.date).getFullYear())
                    .attr("font-size", "9px")
                    .attr("dx", 18)
                    .attr("dy", 16)
                    .attr("fill", "#666")
                    .style("pointer-events", "none")
                    .style("user-select", "none");

                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }

                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }

                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }

                simulation.on("tick", () => {
                    // Apply boundary constraints with padding
                    const padding = 50;
                    nodes.forEach((d) => {
                        d.x = Math.max(padding, Math.min(width - padding, d.x));
                        d.y = Math.max(
                            padding,
                            Math.min(height - padding, d.y),
                        );
                    });

                    link.attr("x1", (d) => d.source.x)
                        .attr("y1", (d) => d.source.y)
                        .attr("x2", (d) => d.target.x)
                        .attr("y2", (d) => d.target.y);

                    node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);

                    label.attr("x", (d) => d.x).attr("y", (d) => d.y);

                    dateLabel.attr("x", (d) => d.x).attr("y", (d) => d.y);

                    // Auto-stabilize: stop simulation when it settles
                    if (simulation.alpha() < 0.01) {
                        simulation.stop();
                        console.log("Graph stabilized - movement stopped");
                    }
                });

                // Add manual stabilization after a timeout for large graphs
                setTimeout(
                    () => {
                        if (simulation.alpha() > 0.01) {
                            simulation.alpha(0.01).restart();
                            console.log("Force-stabilizing large graph");
                        }
                    },
                    nodes.length > 50 ? 5000 : 3000,
                );

                // Add legend
                if (nodes.length > 0) {
                    const legend = svg
                        .append("g")
                        .attr("transform", `translate(10, 10)`);

                    const filteredCount = filteredPapers.length;
                    const totalCount = papers.length;
                    const isFiltered = filteredCount < totalCount;

                    legend
                        .append("text")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("font-size", "12px")
                        .attr("font-weight", "bold")
                        .attr("fill", "#333")
                        .text(
                            focusedNode
                                ? "Focused Subgraph"
                                : graphType === "followup"
                                  ? "Paper Dependencies"
                                  : "Author Connections",
                        );

                    if (isFiltered) {
                        legend
                            .append("text")
                            .attr("x", 0)
                            .attr("y", 14)
                            .attr("font-size", "10px")
                            .attr("fill", "#667eea")
                            .attr("font-weight", "bold")
                            .text(
                                `Showing ${filteredCount} of ${totalCount} papers`,
                            );
                    }

                    const descriptionY = isFiltered ? 28 : 18;

                    if (graphType === "followup") {

                    } else if (graphType === "author") {
                        legend
                            .append("text")
                            .attr("x", 0)
                            .attr("y", descriptionY)
                            .attr("font-size", "10px")
                            .attr("fill", "#666")
                            .text("Lines connect papers with common authors");
                    }

                    const colorY = isFiltered ? 42 : 32;



                    const instructionY = isFiltered ? 56 : 46;

                    if (focusedNode) {
                        legend
                            .append("text")
                            .attr("x", 0)
                            .attr("y", instructionY)
                            .attr("font-size", "10px")
                            .attr("fill", "#667eea")
                            .attr("font-weight", "bold")
                            .text("💡 Click: View • Ctrl/Cmd+Click: Connected Component");
                    } else {

                    }
                }
            }

            // Show messages
            function showMessage(message, type, allowStacking = false) {
                // Remove messages based on stacking preference
                if (!allowStacking) {
                    // Remove only messages of the same type to allow different types to coexist
                    document
                        .querySelectorAll(`.message.${type}`)
                        .forEach((el) => el.remove());
                } else {
                    // For stacking messages, only remove identical messages
                    document
                        .querySelectorAll(`.message.${type}`)
                        .forEach((el) => {
                            if (el.textContent === message) {
                                el.remove();
                            }
                        });
                }

                const messageDiv = document.createElement("div");
                messageDiv.className = `message ${type}`;
                messageDiv.textContent = message;

                // Add stacking class if multiple messages of same type exist
                const existingMessagesOfType = document.querySelectorAll(`.message.${type}`);
                if (existingMessagesOfType.length > 0) {
                    messageDiv.style.marginTop = '5px';
                }

                const sidebar = document.querySelector(".sidebar");
                if (sidebar) {
                    sidebar.insertBefore(messageDiv, sidebar.firstChild);

                    // Different timeout for different message types
                    const timeout = type === 'error' ? 8000 : 5000;
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, timeout);
                }
            }

            // Show CORS help modal
            function showCorsHelp() {
                const modal = document.createElement("div");
                modal.style.cssText = `
                                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                                background: rgba(0,0,0,0.5); z-index: 10000; display: flex;
                                align-items: center; justify-content: center;
                            `;

                modal.innerHTML = `
                                <div style="background: white; max-width: 600px; margin: 20px; padding: 30px; border-radius: 12px; max-height: 80vh; overflow-y: auto;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                        <h2 style="margin: 0; color: #333;">🔧 Enable "Fetch Metadata" Feature</h2>
                                        <button onclick="this.parentElement.parentElement.parentElement.remove()"
                                                style="background: none; border: none; font-size: 24px; cursor: pointer; color: #999;">×</button>
                                    </div>

                                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                        <strong>Why is this needed?</strong><br>
                                        Browsers block cross-origin requests (CORS) for security. ePrint.iacr.org doesn't allow direct fetching from other websites.
                                    </div>

                                    <h3 style="color: #667eea;">🚀 Solution 1: Chrome with CORS Disabled (Recommended)</h3>
                                    <ol style="margin-bottom: 20px;">
                                        <li><strong>Close ALL Chrome windows</strong></li>
                                        <li><strong>Create a shortcut</strong> or run this command:</li>
                                    </ol>

                                    <div style="background: #f1f3f4; padding: 12px; border-radius: 6px; font-family: monospace; margin: 10px 0; overflow-x: auto;">
                                        <strong>Windows:</strong><br>
                                        <span style="color: #d63384; font-size: 0.9em;">
                                        "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe" --disable-web-security --user-data-dir="C:\\temp\\chrome-dev"
                                        </span><br><br>
                                        <strong>macOS:</strong><br>
                                        <span style="color: #d63384; font-size: 0.9em;">
                                        open -n -a /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --args --user-data-dir="/tmp/chrome_dev" --disable-web-security
                                        </span><br><br>
                                        <strong>Linux:</strong><br>
                                        <span style="color: #d63384; font-size: 0.9em;">
                                        google-chrome --disable-web-security --user-data-dir="/tmp/chrome_dev"
                                        </span>
                                    </div>

                                    <h3 style="color: #28a745;">🔧 Solution 2: CORS Unblock Extension (Easier)</h3>
                                    <ol style="margin-bottom: 20px;">
                                        <li><strong>Install CORS Unblock extension:</strong><br>
                                            <a href="https://chromewebstore.google.com/detail/cors-unblock/hadoojkfknbjgoppkecpgamiajljiief"
                                               target="_blank" style="color: #667eea; text-decoration: none;">
                                                → Chrome Web Store Link
                                            </a>
                                        </li>
                                        <li><strong>Enable the extension</strong> by clicking its icon in the toolbar</li>
                                        <li><strong>Refresh this page</strong> and try "Fetch Metadata" again</li>
                                        <li><strong>Disable when done</strong> for security (optional)</li>
                                    </ol>

                                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 12px; border-radius: 6px; margin: 10px 0;">
                                        <strong>⚠️ Security Note:</strong> Both solutions disable CORS protection. Only use when needed and consider disabling afterwards.
                                    </div>

                                    <div style="text-align: center; margin-top: 20px;">
                                        <button onclick="this.parentElement.parentElement.parentElement.remove()"
                                                style="background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">
                                            Got it!
                                        </button>
                                    </div>
                                </div>
                            `;

                document.body.appendChild(modal);

                modal.addEventListener("click", (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            // Close modal when clicking outside
            window.addEventListener("click", function (event) {
                const modal = document.getElementById("paper-modal");
                if (event.target === modal) {
                    closePaperModal();
                }
            });

            // Scratchpad functions
            function openScratchpad(paperId) {
                const paper = papers.find((p) => p.id == paperId);
                if (!paper) return;

                currentScratchpadPaper = paper;
                document.getElementById("scratchpad-title").textContent =
                    `Scratchpad - ${paper.title}`;
                document.getElementById("scratchpad-textarea").value =
                    paper.scratchpad || "";
                updateScratchpadPreview();
                document.getElementById("scratchpad-modal").style.display =
                    "block";
            }

            function closeScratchpadModal() {
                document.getElementById("scratchpad-modal").style.display =
                    "none";
                currentScratchpadPaper = null;
            }

            function switchScratchpadTab(tab) {
                document
                    .querySelectorAll(".scratchpad-tab")
                    .forEach((t) => t.classList.remove("active"));
                document
                    .querySelectorAll(".scratchpad-tab-content")
                    .forEach((t) => t.classList.remove("active"));

                document
                    .querySelector(
                        `.scratchpad-tab:nth-child(${tab === "edit" ? "1" : "2"})`,
                    )
                    .classList.add("active");
                document
                    .getElementById(`scratchpad-${tab}`)
                    .classList.add("active");

                if (tab === "preview") {
                    updateScratchpadPreview();
                }
            }

            function updateScratchpadPreview() {
                const content = document.getElementById(
                    "scratchpad-textarea",
                ).value;
                const preview = document.getElementById(
                    "scratchpad-preview-content",
                );
                preview.innerHTML = parseMarkdown(content);
            }

            function parseMarkdown(text) {
                return (
                    text
                        // Headers
                        .replace(/^### (.*$)/gim, "<h3>$1</h3>")
                        .replace(/^## (.*$)/gim, "<h2>$1</h2>")
                        .replace(/^# (.*$)/gim, "<h1>$1</h1>")
                        // Bold and italic
                        .replace(/\*\*(.*?)\*\*/gim, "<strong>$1</strong>")
                        .replace(/\*(.*?)\*/gim, "<em>$1</em>")
                        // Links
                        .replace(
                            /\[([^\]]+)\]\(([^)]+)\)/gim,
                            '<a href="$2" target="_blank">$1</a>',
                        )
                        // Code
                        .replace(
                            /```([^`]+)```/gim,
                            "<pre><code>$1</code></pre>",
                        )
                        .replace(/`([^`]+)`/gim, "<code>$1</code>")
                        // Lists
                        .replace(/^\* (.*)$/gim, "<li>$1</li>")
                        .replace(/^\d+\. (.*)$/gim, "<li>$1</li>")
                        // Blockquotes
                        .replace(/^\> (.*)$/gim, "<blockquote>$1</blockquote>")
                        // Convert line breaks
                        .split("\n")
                        .map((line) => line.trim())
                        .filter((line) => line !== "")
                        .map((line) => {
                            if (line.startsWith("<li>")) return line;
                            if (
                                line.startsWith("<h") ||
                                line.startsWith("<blockquote") ||
                                line.startsWith("<pre>")
                            )
                                return line;
                            return line + "<br>";
                        })
                        .join("\n")
                        // Wrap consecutive list items
                        .replace(
                            /(<li>.*?<\/li>(\n<li>.*?<\/li>)*)/gim,
                            "<ul>$1</ul>",
                        )
                        .replace(
                            /(<blockquote>.*?<\/blockquote>(\n<blockquote>.*?<\/blockquote>)*)/gim,
                            '<div class="blockquote-group">$1</div>',
                        )
                );
            }

            function saveScratchpad() {
                if (!currentScratchpadPaper) return;

                const content = document.getElementById(
                    "scratchpad-textarea",
                ).value;
                currentScratchpadPaper.scratchpad = content;
                savePapers();
                showMessage("Scratchpad saved!", "success");
                closeScratchpadModal();
                performSearch(); // Maintain current search state
            }

            // Sorting functions
            function changeSortOrder() {
                const sortSelect =
                    document.getElementById("sort-order") ||
                    document.getElementById("main-sort-order");
                currentSortOrder = sortSelect.value;

                // Sync both select elements
                const otherSelect =
                    sortSelect.id === "sort-order"
                        ? document.getElementById("main-sort-order")
                        : document.getElementById("sort-order");
                if (otherSelect) {
                    otherSelect.value = currentSortOrder;
                }

                performSearch(); // Maintain current search state
            }

            function sortPapers(papers) {
                return papers.sort((a, b) => {
                    switch (currentSortOrder) {
                        case "date-desc":
                            return new Date(b.date) - new Date(a.date);
                        case "date-asc":
                            return new Date(a.date) - new Date(b.date);
                        case "title-asc":
                            return a.title.localeCompare(b.title);
                        case "title-desc":
                            return b.title.localeCompare(a.title);
                        case "author-asc":
                            return a.authors.localeCompare(b.authors);
                        case "author-desc":
                            return b.authors.localeCompare(a.authors);
                        case "status-asc":
                            const statusOrderA = readingStatuses.findIndex(
                                (s) =>
                                    s.key === (a.readingStatus || "referenced"),
                            );
                            const statusOrderB = readingStatuses.findIndex(
                                (s) =>
                                    s.key === (b.readingStatus || "referenced"),
                            );
                            return statusOrderA - statusOrderB;
                        case "status-desc":
                            const statusOrderDescA = readingStatuses.findIndex(
                                (s) =>
                                    s.key === (a.readingStatus || "referenced"),
                            );
                            const statusOrderDescB = readingStatuses.findIndex(
                                (s) =>
                                    s.key === (b.readingStatus || "referenced"),
                            );
                            return statusOrderDescB - statusOrderDescA;
                        default:
                            return new Date(b.date) - new Date(a.date);
                    }
                });
            }

            // Graph focus functions
            function toggleGraphFocus(nodeId) {
                if (focusedNode === nodeId) {
                    // Unfocus - show all nodes
                    focusedNode = null;
                } else {
                    // Focus on this node and its connections
                    focusedNode = nodeId;
                }
                renderGraph();
            }

            function showConnectedComponent(nodeId) {
                console.log(`[CONNECTED COMPONENT DEBUG] Function called with nodeId: ${nodeId}`);
                console.log(`[CONNECTED COMPONENT] Starting search for node: ${nodeId}`);

                // Find all papers connected to this node (transitively)
                const connectedIds = new Set();
                const toExplore = [nodeId];

                // Find the paper to get its title for debugging
                const startPaper = papers.find(p => p.id === nodeId);
                console.log(`[CONNECTED COMPONENT] Starting paper: "${startPaper ? startPaper.title : 'NOT FOUND'}"`);
                console.log(`[CONNECTED COMPONENT] Paper has previousWorks:`, startPaper ? startPaper.previousWorks : 'NO PAPER');

                while (toExplore.length > 0) {
                    const currentId = toExplore.pop();
                    if (connectedIds.has(currentId)) continue;

                    console.log(`[CONNECTED COMPONENT] Exploring paper ID: ${currentId}`);
                    connectedIds.add(currentId);
                    const currentPaper = papers.find(p => p.id === currentId);

                    if (currentPaper) {
                        console.log(`[CONNECTED COMPONENT] Found paper: "${currentPaper.title}"`);

                        // Add previous works (papers this one references)
                        const previousWorks = currentPaper.previousWorks || [];
                        console.log(`[CONNECTED COMPONENT] Previous works indices:`, previousWorks);

                        previousWorks.forEach(index => {
                            const referencedPaper = papers[index];
                            console.log(`[CONNECTED COMPONENT] Checking previous work at index ${index}:`, referencedPaper ? referencedPaper.title : 'NOT FOUND');
                            if (referencedPaper && !connectedIds.has(referencedPaper.id)) {
                                console.log(`[CONNECTED COMPONENT] Adding to explore: "${referencedPaper.title}" (${referencedPaper.id})`);
                                toExplore.push(referencedPaper.id);
                            }
                        });

                        // Add follow-ups (papers that reference this one)
                        papers.forEach((paper, paperIndex) => {
                            const previousWorks = paper.previousWorks || [];
                            if (previousWorks.some(index => papers[index] && papers[index].id === currentId)) {
                                if (!connectedIds.has(paper.id)) {
                                    console.log(`[CONNECTED COMPONENT] Found follow-up: "${paper.title}" (${paper.id})`);
                                    toExplore.push(paper.id);
                                }
                            }
                        });
                    } else {
                        console.log(`[CONNECTED COMPONENT] Paper with ID ${currentId} not found in papers array`);
                    }
                }

                console.log(`[CONNECTED COMPONENT] Final connected IDs:`, Array.from(connectedIds));

                // Update current filtered papers to only show connected component
                const connectedPapers = papers.filter(p => connectedIds.has(p.id));
                console.log(`[CONNECTED COMPONENT] Connected papers:`, connectedPapers.map(p => p.title));

                console.log(`[CONNECTED COMPONENT] Before update - currentlyFilteredPapers:`, currentlyFilteredPapers.length);
                currentlyFilteredPapers = connectedPapers;
                console.log(`[CONNECTED COMPONENT] After update - currentlyFilteredPapers:`, currentlyFilteredPapers.length);

                // Re-render papers list and graph
                console.log(`[CONNECTED COMPONENT] Calling renderPapers with:`, currentlyFilteredPapers.length, "papers");
                renderPapers(currentlyFilteredPapers);
                console.log(`[CONNECTED COMPONENT] Calling renderGraph`);
                renderGraph();
                console.log(`[CONNECTED COMPONENT] After renderGraph - currentlyFilteredPapers:`, currentlyFilteredPapers.length);
            }

            function showGraphHelp() {
                // Remove existing popup if any
                const existingOverlay = document.querySelector(
                    ".graph-help-popup-overlay",
                );
                if (existingOverlay) {
                    existingOverlay.remove();
                }

                // Create overlay
                const overlay = document.createElement("div");
                overlay.className = "graph-help-popup-overlay";
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                overlay.onclick = () => overlay.remove();

                // Create popup
                const popup = document.createElement("div");
                popup.className = "graph-help-popup";
                popup.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 24px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
                    margin: 20px;
                `;
                popup.onclick = (e) => e.stopPropagation();

                popup.innerHTML = `
                    <h3 style="margin-bottom: 20px; color: #667eea;">📊 Paper Relationships Graph Help</h3>
                    <div style="line-height: 1.6;">
                        <h4 style="color: #333; margin-top: 0;">🔍 What the Graph Shows:</h4>
                        <ul style="margin-bottom: 16px; padding-left: 20px;">
                            <li><strong>Nodes:</strong> Papers from your current search results</li>
                            <li><strong>New searches:</strong> Add more nodes to the existing graph</li>
                            <li><strong>Colors:</strong> Blue→Purple gradient based on publication date</li>
                            <li><strong>Gray nodes:</strong> Papers with invalid/missing dates</li>
                        </ul>

                        <h4 style="color: #333;">🔗 What Links Represent:</h4>
                        <ul style="margin-bottom: 16px; padding-left: 20px;">
                            <li><strong>Follow-up Graph:</strong> Arrows show citation relationships (A→B means B cites A as previous work)</li>
                            <li><strong>Author Graph:</strong> Lines connect papers with shared authors</li>
                        </ul>

                        <h4 style="color: #333;">🔄 Controls:</h4>
                        <ul style="margin-bottom: 16px; padding-left: 20px;">
                            <li><strong>Refresh Graph:</strong> Reset to show only current search results</li>
                            <li><strong>Single Click:</strong> View paper details</li>
                            <li><strong>Cmd+Click (Mac) / Ctrl+Click (PC):</strong> Show full connected component</li>
                            <li><strong>Right-Click:</strong> Alternative to show connected component</li>
                        </ul>

                        <h4 style="color: #333;">🌐 Connected Component:</h4>
                        <p style="margin-bottom: 16px;">
                            When you <strong>Cmd+Click</strong> a node, the system finds all papers connected to it
                            (directly or indirectly through citations) and shows only those papers. This helps you
                            discover related work even if it wasn't in your original search results.
                        </p>

                        <div style="background: #f0f4f8; padding: 12px; border-radius: 6px; margin-bottom: 16px;">
                            <strong>💡 Pro Tip:</strong> Use connected components to explore research lineages -
                            click on a seminal paper to see its entire citation tree!
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button style="background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;"
                                onclick="this.closest('.graph-help-popup-overlay').remove()">Got it!</button>
                    </div>
                `;

                overlay.appendChild(popup);
                document.body.appendChild(overlay);
            }

            // Export database without personal data (scratchpad, reading status, folders)
            async function exportDatabase() {
                try {
                    showMessage("Preparing export...", "info");

                    // Ensure we have the latest data from IndexedDB
                    await loadPapers();
                    await loadFolders();

                    // Include extension papers in export
                    let allPapers = [...papers];
                    const extensionStored = localStorage.getItem(
                        "cryptoExtensionPapers",
                    );
                    if (extensionStored) {
                        const extensionPapers = JSON.parse(extensionStored);
                        const existingUrls = new Set(papers.map((p) => p.url));
                        const existingIds = new Set(papers.map((p) => p.id));

                        extensionPapers.forEach((extPaper) => {
                            if (
                                !existingUrls.has(extPaper.url) &&
                                !existingIds.has(extPaper.id)
                            ) {
                                allPapers.push(extPaper);
                            }
                        });

                        if (extensionPapers.length > 0) {
                            console.log(
                                `[EXPORT] Including ${extensionPapers.length} extension papers`,
                            );
                        }
                    }

                    // Remove personal data from papers
                    const cleanPapers = allPapers.map(paper => {
                        const cleanPaper = { ...paper };
                        delete cleanPaper.scratchpad;
                        delete cleanPaper.readingStatus;
                        delete cleanPaper.favorite;
                        delete cleanPaper.folderId;
                        return cleanPaper;
                    });

                    const data = {
                        papers: cleanPapers,
                        version: "2.0",
                        exportDate: new Date().toISOString(),
                    };

                    const blob = new Blob([JSON.stringify(data, null, 2)], {
                        type: "application/json",
                    });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `mpc_db_${new Date().toISOString().split("T")[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    showMessage(
                        `Database exported successfully! ${cleanPapers.length} papers included (without personal data).`,
                        "success",
                    );
                } catch (error) {
                    console.error("Export failed:", error);
                    showMessage(
                        "Export failed. Check console for details.",
                        "error",
                    );
                }
            }

            // Make function globally available for module script
            window.exportDatabase = exportDatabase;

            // Reading status functions
            function getReadingStatusIcon(status) {
                const statusObj = readingStatuses.find((s) => s.key === status);
                return statusObj ? statusObj.icon : "📚";
            }

            function getReadingStatusLabel(status) {
                const statusObj = readingStatuses.find((s) => s.key === status);
                return statusObj ? statusObj.label : "Referenced";
            }

            function cycleReadingStatus(paperId) {
                const paper = papers.find((p) => p.id == paperId);
                if (!paper) return;

                const currentIndex = readingStatuses.findIndex(
                    (s) => s.key === (paper.readingStatus || "referenced"),
                );
                const nextIndex = (currentIndex + 1) % readingStatuses.length;
                paper.readingStatus = readingStatuses[nextIndex].key;

                // Invalidate caches when data changes
                invalidateSearchCache();
                paperElementCache.clear();

                savePapers();
                performSearch(); // Maintain current search state
                showMessage(
                    `Reading status: ${readingStatuses[nextIndex].label}`,
                    "info",
                );
            }

            // Toggle favorite status
            function toggleFavorite(paperId) {
                const paper = papers.find((p) => p.id == paperId);
                if (!paper) return;

                paper.favorite = !paper.favorite;

                // Invalidate caches when data changes
                invalidateSearchCache();
                paperElementCache.clear();

                savePapers();
                performSearch(); // Maintain current search state
                showMessage(
                    paper.favorite
                        ? "Added to favorites ⭐"
                        : "Removed from favorites",
                    "info",
                );
            }

            // Toggle favorite filter
            function toggleFavoriteFilter() {
                favoriteFilterActive = !favoriteFilterActive;
                const btn = document.getElementById("favorite-filter-btn");

                if (favoriteFilterActive) {
                    btn.style.background = "#ffd700";
                    btn.style.color = "#333";
                    btn.textContent = "⭐ Favorites (On)";
                } else {
                    btn.style.background = "";
                    btn.style.color = "";
                    btn.textContent = "⭐ Favorites";
                }

                performSearch(); // Refresh search results
            }

            // Edit contact emails function
            function editContactEmails(paperId) {
                const paper = papers.find((p) => p.id == paperId);
                if (!paper) return;

                const currentEmails = (paper.contactEmails || []).join("\n");
                const newEmails = prompt(
                    "Edit contact emails (one per line):",
                    currentEmails,
                );

                if (newEmails !== null) {
                    const emailList = newEmails
                        .split("\n")
                        .map((email) => email.trim())
                        .filter(
                            (email) => email.length > 0 && email.includes("@"),
                        );

                    paper.contactEmails = emailList;
                    savePapers();
                    performSearch(); // Maintain current search state

                    // Refresh modal if it's open
                    const modal = document.getElementById("paper-modal");
                    if (modal && modal.style.display === "block") {
                        viewPaper(paperId);
                    }

                    showMessage(
                        `Updated contact emails: ${emailList.length} email${emailList.length !== 1 ? "s" : ""}`,
                        "success",
                    );
                }
            }

            // Quick reading status filter
            function filterByReadingStatus(status) {
                const searchQuery = document.getElementById("search-query");

                if (status === "all") {
                    // Clear any existing status filters but keep other search terms
                    let currentQuery = searchQuery.value;
                    currentQuery = currentQuery
                        .replace(/\bstatus:\w+/gi, "")
                        .trim();
                    // Clean up extra spaces and operators
                    currentQuery = currentQuery
                        .replace(/\s+(AND|OR|NOT)\s+$/gi, "")
                        .trim();
                    currentQuery = currentQuery
                        .replace(/^(AND|OR|NOT)\s+/gi, "")
                        .trim();
                    searchQuery.value = currentQuery;
                } else {
                    // Add or replace status filter
                    let currentQuery = searchQuery.value;
                    // Remove existing status filters
                    currentQuery = currentQuery
                        .replace(/\bstatus:\w+/gi, "")
                        .trim();
                    // Clean up extra spaces and operators
                    currentQuery = currentQuery
                        .replace(/\s+(AND|OR|NOT)\s+$/gi, "")
                        .trim();
                    currentQuery = currentQuery
                        .replace(/^(AND|OR|NOT)\s+/gi, "")
                        .trim();

                    // Add new status filter
                    const statusQuery = `status:${status}`;
                    if (currentQuery && currentQuery.length > 0) {
                        currentQuery = `${currentQuery} AND ${statusQuery}`;
                    } else {
                        currentQuery = statusQuery;
                    }
                    searchQuery.value = currentQuery;
                }

                updatePaperCount();
                performSearch();
            }

            // Update reading status statistics
            function updateReadingStatusStats(papers) {
                const stats = {};
                readingStatuses.forEach((status) => {
                    stats[status.key] = 0;
                });

                papers.forEach((paper) => {
                    // Ensure readingStatus is properly set, default to "referenced"
                    if (!paper.readingStatus) {
                        paper.readingStatus = "referenced";
                    }
                    const status = paper.readingStatus;
                    if (stats.hasOwnProperty(status)) {
                        stats[status]++;
                    } else {
                        // If status is not recognized, count as referenced
                        stats["referenced"]++;
                    }
                });

                const total = papers.length;
                const timestamp = new Date().toLocaleTimeString();

                // Enhanced debugging for paper count
                console.log(
                    `[COUNT DEBUG] Displaying ${total} papers at ${timestamp}`,
                );

                // Update paper count display
                const paperCountElement = document.getElementById(
                    "paper-count-display",
                );
                if (paperCountElement) {
                    paperCountElement.innerHTML = `${total} total papers`;
                }

                const statsHtml = `
                                <strong>Reading Status:</strong>
                                ${readingStatuses
                                    .map(
                                        (status) =>
                                            `${status.icon} ${stats[status.key]} ${status.label}`,
                                    )
                                    .join(" • ")}
                            `;

                const statsContainer = document.getElementById(
                    "reading-status-stats",
                );
                if (statsContainer) {
                    statsContainer.innerHTML = statsHtml;
                }
            }

            // Email authors function
            function emailAuthors(paperId) {
                const paper = papers.find((p) => p.id == paperId);
                if (
                    !paper ||
                    !paper.contactEmails ||
                    paper.contactEmails.length === 0
                ) {
                    showMessage(
                        "No contact emails available for this paper",
                        "error",
                    );
                    return;
                }

                const subject = encodeURIComponent(`Regarding: ${paper.title}`);
                const body = encodeURIComponent(`Dear Authors,

            I hope this email finds you well. I am writing regarding your paper titled "${paper.title}".

            [Your message here]

            Best regards,
            [Your name]`);

                const mailtoLink = `mailto:${paper.contactEmails.join(",")}?subject=${subject}&body=${body}`;

                // Open default email client
                window.open(mailtoLink);

                showMessage(
                    `Opening email to ${paper.contactEmails.length} author${paper.contactEmails.length > 1 ? "s" : ""}`,
                    "success",
                );
            }

            // Search validation function
            function validateSearchQuery() {
                const query = document
                    .getElementById("search-query")
                    .value.trim();
                const feedback = document.getElementById(
                    "search-validation-feedback",
                );

                if (!query) {
                    feedback.style.display = "none";
                    return;
                }

                // Check for year range syntax
                const yearRangeRegex = /year:(\d{4})-(\d{4})/gi;
                let match;
                let hasError = false;
                let errorMessage = "";

                while ((match = yearRangeRegex.exec(query)) !== null) {
                    const startYear = parseInt(match[1]);
                    const endYear = parseInt(match[2]);

                    if (startYear > endYear) {
                        hasError = true;
                        errorMessage = `Invalid year range: ${startYear}-${endYear}. Start year must be <= end year.`;
                        break;
                    }

                    if (startYear < 1900 || endYear > 2030) {
                        hasError = true;
                        errorMessage = `Year range ${startYear}-${endYear} seems unusual. Use years between 1900-2030.`;
                        break;
                    }
                }

                // Check for malformed year operators
                const yearOpRegex = /year:(>|>=|<|<=)(\d{4})/gi;
                while ((match = yearOpRegex.exec(query)) !== null) {
                    const year = parseInt(match[2]);
                    if (year < 1900 || year > 2030) {
                        hasError = true;
                        errorMessage = `Year ${year} seems unusual. Use years between 1900-2030.`;
                        break;
                    }
                }

                if (hasError) {
                    feedback.textContent = errorMessage;
                    feedback.style.display = "block";
                } else {
                    feedback.style.display = "none";
                }
            }

            // Validate search query and debounce search execution
            let searchTimeout;
            function validateAndDebounceSearch() {
                const query = document
                    .getElementById("search-query")
                    .value.trim();

                // Always validate the query
                validateSearchQuery();

                // Clear previous timeout
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }

                // Don't search on incomplete field queries
                if (
                    query.match(
                        /\b(title|author|abstract|year|status|email):\s*$/,
                    ) ||
                    query.match(
                        /\b(title|author|abstract|year|status|email):[^\s]{1,2}\s*$/,
                    )
                ) {
                    return; // Wait for user to complete the field query
                }

                // Don't search on very short queries unless they're complete
                if (
                    query.length > 0 &&
                    query.length < 3 &&
                    !query.includes(":")
                ) {
                    return;
                }

                // Adaptive debouncing - shorter delay for simple queries, longer for complex ones
                const isComplexQuery =
                    query.includes(":") ||
                    query.includes("AND") ||
                    query.includes("OR");
                const debounceDelay = isComplexQuery ? 500 : 200;

                // Debounce the search
                searchTimeout = setTimeout(() => {
                    performSearch();
                }, debounceDelay);
            }

            // Refresh metadata function
            // Show search help popup
            function showSearchHelp() {
                // Remove existing popup if any
                const existingOverlay = document.querySelector(
                    ".help-popup-overlay",
                );
                if (existingOverlay) {
                    existingOverlay.remove();
                }

                // Create overlay
                const overlay = document.createElement("div");
                overlay.className = "help-popup-overlay";
                overlay.onclick = () => overlay.remove();

                // Create popup
                const popup = document.createElement("div");
                popup.className = "help-popup";
                popup.innerHTML = `
                    <h3>Advanced Search Help</h3>
                    <div style="line-height: 1.6; max-height: 400px; overflow-y: auto;">
                        <strong>Field Searches:</strong><br/>
                        • <code>title:keyword</code> - Search in paper titles<br/>
                        • <code>author:name</code> - Search in author names<br/>
                        • <code>abstract:keyword</code> - Search in abstracts<br/>
                        • <code>year:2020</code> or <code>year:>2020</code> or <code>year:2020-2022</code><br/>
                        • <code>date:"unknown date"</code> - Find papers with unknown dates<br/>
                        • <code>date:2023</code> - Search by specific date/year<br/>
                        • <code>status:read</code> (read, reading, to-read, skimmed, referenced)<br/>
                        • <code>email:domain.com</code> - Search in contact emails<br/><br/>

                        <strong>Case Sensitivity:</strong><br/>
                        • Searches are case-insensitive by default<br/>
                        • Use <code>#</code> for case-sensitive searches: <code>title:#OT</code><br/>
                        • Example: <code>title:#ECDSA</code> finds "ECDSA" but not "ecdsa"<br/><br/>

                        <strong>Boolean Operators:</strong><br/>
                        • <code>AND</code> - Both conditions must be true<br/>
                        • <code>OR</code> - Either condition can be true<br/>
                        • <code>NOT</code> - Exclude matching papers<br/><br/>

                        <strong>Parentheses:</strong> Use <code>()</code> to group conditions<br/><br/>

                        <strong>Quoted Phrases:</strong> Use <code>"exact phrase"</code> for exact matches<br/><br/>

                        <strong>Examples:</strong><br/>
                        • <code>cryptography protocol</code> (general search)<br/>
                        • <code>and RAM Support</code> (searches for "and" + "RAM" + "Support")<br/>
                        • <code>author:yuval ishai</code> (multi-word without quotes)<br/>
                        • <code>author:yuval OR author:couteau</code><br/>
                        • <code>author:"yuval ishai" OR author:"silvio micali"</code><br/>
                        • <code>("author:alice silverberg" OR author:bob) AND title:secure</code><br/>
                        • <code>(author:alice OR author:bob) AND title:secure</code><br/>
                        • <code>title:#ECDSA</code> (case-sensitive search for "ECDSA")<br/>
                        • <code>title:zero knowledge AND NOT author:smith</code><br/>
                        • <code>status:to-read AND (year:>2020 OR author:important)</code><br/>
                        • <code>email:gmail.com AND year:2020-2023</code>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button class="btn" onclick="this.closest('.help-popup-overlay').remove()">Close</button>
                    </div>
                `;

                overlay.appendChild(popup);
                document.body.appendChild(overlay);
            }

            // Toggle label filter section
            function toggleLabelFilter() {
                const arrow = document.querySelector(".collapsible-arrow");
                const content = document.getElementById("label-filter-content");

                if (content.classList.contains("expanded")) {
                    arrow.classList.remove("expanded");
                    content.classList.remove("expanded");
                } else {
                    arrow.classList.add("expanded");
                    content.classList.add("expanded");
                }
            }

            // Refresh all metadata function
            async function refreshAllMetadata() {
                // Get currently visible papers (same logic as renderPapers uses)
                const visiblePapers = papers.filter(
                    isPaperInCurrentFolderHierarchy,
                );

                if (visiblePapers.length === 0) {
                    showMessage("No papers to refresh", "info");
                    return;
                }

                const confirmMessage = `Refresh metadata for ${visiblePapers.length} visible paper${visiblePapers.length === 1 ? "" : "s"}? This will update paper information from ePrint pages.`;

                if (!confirm(confirmMessage)) {
                    return;
                }

                let successCount = 0;
                let errorCount = 0;

                showMessage(
                    `Starting refresh of ${visiblePapers.length} papers...`,
                    "info",
                );

                for (let i = 0; i < visiblePapers.length; i++) {
                    const paper = visiblePapers[i];

                    // Skip papers without URLs or non-ePrint URLs
                    if (!paper.url || !paper.url.includes("eprint.iacr.org")) {
                        continue;
                    }

                    try {
                        // Show progress
                        showMessage(
                            `Refreshing ${i + 1}/${visiblePapers.length}: ${paper.title}`,
                            "info",
                        );

                        // Extract paper ID
                        const paperIdMatch = paper.url.match(
                            /eprint\.iacr\.org\/(\d{4}\/\d+)$/,
                        );
                        const eprintId = paperIdMatch
                            ? paperIdMatch[1]
                            : "Unknown";

                        // Try direct fetch first (same as individual refresh)
                        try {
                            const response = await fetch(paper.url);
                            if (response.ok) {
                                const html = await response.text();

                                // Parse the HTML directly using same method as individual refresh
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(
                                    html,
                                    "text/html",
                                );

                                // Extract metadata from the HTML using parseHtmlMetadata
                                const metadata = parseHtmlMetadata(
                                    doc,
                                    eprintId,
                                );

                                // Update the paper
                                const paperIndex = papers.findIndex(
                                    (p) => p.id === paper.id,
                                );
                                if (paperIndex !== -1) {
                                    papers[paperIndex] = {
                                        ...papers[paperIndex],
                                        title: metadata.title,
                                        authors: metadata.authors,
                                        abstract: metadata.abstract,
                                        date: metadata.date,
                                        contactEmails:
                                            metadata.contactEmails ||
                                            papers[paperIndex].contactEmails ||
                                            [],
                                        isPlaceholder: false,
                                    };
                                }

                                successCount++;
                            } else {
                                throw new Error(
                                    `HTTP ${response.status}: ${response.statusText}`,
                                );
                            }
                        } catch (fetchError) {
                            throw new Error(
                                `Cannot fetch ${paper.url}: ${fetchError.message}. Make sure CORS is disabled or use CORS extension.`,
                            );
                        }

                        // Small delay to avoid overwhelming the server
                        await new Promise((resolve) =>
                            setTimeout(resolve, 500),
                        );
                    } catch (error) {
                        errorCount++;
                        console.error(
                            `Error refreshing ${paper.title}:`,
                            error,
                        );
                    }
                }

                // Save the updated papers
                savePapers();
                performSearch(); // Maintain current search state
                if (
                    document.getElementById("graph-display").style.display !==
                    "none"
                ) {
                    renderGraph();
                }

                // Show final result
                if (successCount > 0 && errorCount === 0) {
                    showMessage(
                        `✅ Successfully refreshed ${successCount} paper${successCount === 1 ? "" : "s"}!`,
                        "success",
                    );
                } else if (successCount > 0 && errorCount > 0) {
                    showMessage(
                        `⚠️ Refreshed ${successCount} paper${successCount === 1 ? "" : "s"}, ${errorCount} failed. Enable CORS fix for better results.`,
                        "success",
                    );
                } else {
                    showMessage(
                        `❌ Failed to refresh papers. Enable CORS fix (click 🌐 CORS Fix button) and try again.`,
                        "error",
                    );
                }
            }

            async function refreshMetadata(
                paperId,
                urlOverride = null,
                skipConfirm = false,
            ) {
                const paper = papers.find((p) => p.id == paperId);
                const paperUrl = urlOverride || (paper ? paper.url : null);

                if (!paper || !paperUrl) {
                    showMessage("No URL available for this paper", "error");
                    return false;
                }

                if (
                    !skipConfirm &&
                    !confirm(
                        `Refresh metadata for "${paper.title}"? This will update the paper information from the source page.`,
                    )
                ) {
                    return false;
                }

                try {
                    if (!skipConfirm) {
                        showMessage("Refreshing metadata...", "info");
                    }

                    // Detect URL type and validate format
                    let paperId_extracted = "";
                    let urlType = "";

                    const eprintMatch = paperUrl.match(
                        /eprint\.iacr\.org\/(\d{4}\/\d+)$/,
                    );
                    const springerMatch = paperUrl.match(
                        /link\.springer\.com\/chapter\/10\.1007\/(.+)$/,
                    );
                    const acmMatch = paperUrl.match(
                        /dl\.acm\.org\/doi\/10\.1145\/(.+)$/,
                    );

                    if (eprintMatch) {
                        paperId_extracted = eprintMatch[1];
                        urlType = "eprint";
                    } else if (springerMatch) {
                        paperId_extracted = springerMatch[1];
                        urlType = "springer";
                    } else if (acmMatch) {
                        paperId_extracted = acmMatch[1];
                        urlType = "acm";
                    } else {
                        if (!skipConfirm) {
                            showMessage(
                                "Unsupported URL format for metadata refresh",
                                "error",
                            );
                        }
                        return false;
                    }

                    // Try direct fetch first (works if CORS is disabled or local server)
                    try {
                        const response = await fetch(paperUrl, {
                            mode: "cors",
                            headers: {
                                Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                                "User-Agent":
                                    "Mozilla/5.0 (compatible; Paper Manager)",
                            },
                        });
                        if (response.ok) {
                            const html = await response.text();

                            // Parse the HTML directly
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(
                                html,
                                "text/html",
                            );

                            // Extract metadata from the HTML
                            const metadata = parseHtmlMetadata(
                                doc,
                                paperId_extracted,
                                urlType,
                            );

                            // Update paper with new metadata
                            const paperIndex = papers.findIndex(
                                (p) => p.id == paperId,
                            );
                            if (paperIndex !== -1) {
                                papers[paperIndex] = {
                                    ...papers[paperIndex],
                                    title: metadata.title,
                                    authors: metadata.authors,
                                    abstract: metadata.abstract,
                                    date: metadata.date,
                                    contactEmails:
                                        metadata.contactEmails ||
                                        papers[paperIndex].contactEmails ||
                                        [],
                                };

                                savePapers();
                                performSearch(); // Maintain current search state
                                if (
                                    document.getElementById("graph-display")
                                        .style.display !== "none"
                                ) {
                                    renderGraph();
                                }

                                // Refresh the modal
                                viewPaper(paperId);

                                showMessage(
                                    `Metadata refreshed successfully! ${metadata.contactEmails && metadata.contactEmails.length > 0 ? `Found ${metadata.contactEmails.length} contact email${metadata.contactEmails.length > 1 ? "s" : ""}` : ""}`,
                                    "success",
                                );
                                return true;
                            }
                        }
                    } catch (fetchError) {
                        console.log(
                            "Direct fetch failed (CORS blocked):",
                            fetchError.message,
                        );
                    }

                    // Fallback: Show manual refresh instructions
                    const manualRefreshModal = document.createElement("div");
                    manualRefreshModal.className = "modal";
                    manualRefreshModal.style.display = "block";
                    manualRefreshModal.innerHTML = `
                                    <div class="modal-content">
                                        <div class="modal-header">
                                            <h2>Manual Metadata Refresh</h2>
                                            <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
                                        </div>
                                        <div style="padding: 20px;">
                                            <p>Browser security blocks automatic fetching. Please:</p>
                                            <ol>
                                                <li>Open the paper URL: <a href="${escapeHtml(paperUrl)}" target="_blank" style="color: #667eea;">${escapeHtml(paperUrl)}</a></li>
                                                <li>Copy the entire page content (Ctrl+A, Ctrl+C)</li>
                                                <li>Paste it in the text area below</li>
                                            </ol>
                                            <div class="input-group">
                                                <label for="refresh-content">Page Content</label>
                                                <textarea id="refresh-content" rows="10" placeholder="Paste the full page content here..."></textarea>
                                            </div>
                                        </div>
                                        <div class="modal-actions">
                                            <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Cancel</button>
                                            <button class="btn btn-success" onclick="processManualRefresh('${paperId}')">Refresh Metadata</button>
                                        </div>
                                    </div>
                                `;

                    // Only show manual refresh modal if not called from auto-add
                    if (!skipConfirm) {
                        document.body.appendChild(manualRefreshModal);

                        manualRefreshModal.addEventListener("click", (e) => {
                            if (e.target === manualRefreshModal) {
                                manualRefreshModal.remove();
                            }
                        });
                    }
                    return false;
                } catch (error) {
                    console.log("Refresh error:", error);
                    if (!skipConfirm) {
                        showMessage(error.message, "error");
                    }
                    return false;
                }
            }

            // Process manual metadata refresh
            function processManualRefresh(paperId) {
                const content = document
                    .getElementById("refresh-content")
                    .value.trim();
                if (!content) {
                    showMessage(
                        "Please paste the ePrint page content",
                        "error",
                    );
                    return;
                }

                try {
                    const paper = papers.find((p) => p.id == paperId);
                    if (!paper) return;

                    // Detect URL type and parse accordingly
                    let paperId_extracted = "";
                    let urlType = "";
                    let metadata = {};

                    const eprintMatch = paper.url.match(
                        /eprint\.iacr\.org\/(\d{4}\/\d+)$/,
                    );
                    const springerMatch = paper.url.match(
                        /link\.springer\.com\/chapter\/10\.1007\/(.+)$/,
                    );
                    const acmMatch = paper.url.match(
                        /dl\.acm\.org\/doi\/10\.1145\/(.+)$/,
                    );

                    if (eprintMatch) {
                        paperId_extracted = eprintMatch[1];
                        urlType = "eprint";
                        metadata = parseEprintContent(
                            content,
                            paperId_extracted,
                        );
                    } else if (springerMatch) {
                        paperId_extracted = springerMatch[1];
                        urlType = "springer";
                        metadata = parseSpringerContent(
                            content,
                            paperId_extracted,
                        );
                    } else if (acmMatch) {
                        paperId_extracted = acmMatch[1];
                        urlType = "acm";
                        metadata = parseAcmContent(content, paperId_extracted);
                    } else {
                        metadata = parseEprintContent(content, "Unknown");
                    }

                    // Update paper with new metadata
                    const paperIndex = papers.findIndex((p) => p.id == paperId);
                    if (paperIndex !== -1) {
                        papers[paperIndex] = {
                            ...papers[paperIndex],
                            title: metadata.title,
                            authors: metadata.authors,
                            abstract: metadata.abstract,
                            date: metadata.date,
                            contactEmails:
                                metadata.contactEmails ||
                                papers[paperIndex].contactEmails ||
                                [],
                        };

                        savePapers();
                        performSearch(); // Maintain current search state
                        if (
                            document.getElementById("graph-display").style
                                .display !== "none"
                        ) {
                            renderGraph();
                        }

                        // Close manual refresh modal
                        document.querySelector(".modal").remove();

                        // Refresh the paper modal
                        viewPaper(paperId);

                        showMessage(
                            `Metadata refreshed successfully! ${metadata.contactEmails && metadata.contactEmails.length > 0 ? `Found ${metadata.contactEmails.length} contact email${metadata.contactEmails.length > 1 ? "s" : ""}` : ""}`,
                            "success",
                        );
                    }
                } catch (error) {
                    showMessage(
                        "Error parsing content: " + error.message,
                        "error",
                    );
                }
            }

            // Make function globally available
            window.processManualRefresh = processManualRefresh;

            // Add real-time preview update for scratchpad and keyboard shortcuts
            document.addEventListener("DOMContentLoaded", function () {
                const scratchpadTextarea = document.getElementById(
                    "scratchpad-textarea",
                );
                if (scratchpadTextarea) {
                    scratchpadTextarea.addEventListener("input", function () {
                        if (
                            document
                                .getElementById("scratchpad-preview")
                                .classList.contains("active")
                        ) {
                            updateScratchpadPreview();
                        }
                    });
                }

                // Add keyboard shortcuts for scratchpad
                document.addEventListener("keydown", function (e) {
                    if (
                        document.getElementById("scratchpad-modal").style
                            .display === "block"
                    ) {
                        // Escape to close
                        if (e.key === "Escape") {
                            closeScratchpadModal();
                        }
                        // Ctrl+S to save
                        if (e.ctrlKey && e.key === "s") {
                            e.preventDefault();
                            saveScratchpad();
                        }
                        // Ctrl+E to switch to edit tab
                        if (e.ctrlKey && e.key === "e") {
                            e.preventDefault();
                            switchScratchpadTab("edit");
                        }
                        // Ctrl+P to switch to preview tab
                        if (e.ctrlKey && e.key === "p") {
                            e.preventDefault();
                            switchScratchpadTab("preview");
                        }
                    }
                });

                // Close scratchpad modal when clicking outside
                const scratchpadModal =
                    document.getElementById("scratchpad-modal");
                if (scratchpadModal) {
                    scratchpadModal.addEventListener("click", function (e) {
                        if (e.target === scratchpadModal) {
                            closeScratchpadModal();
                        }
                    });
                }
            });

            // Initialize app on load with proper async handling
            window.addEventListener("load", async () => {
                try {
                    await init();
                } catch (error) {
                    console.error("Failed to initialize app:", error);
                    showMessage(
                        "Failed to initialize the application. Please refresh the page.",
                        "error",
                    );
                }
            });
            window.addEventListener("resize", () => {
                setTimeout(renderGraph, 100);
            });

            // Paper Selection Functions
            function toggleSelectionMode() {
                paperSelectionMode = !paperSelectionMode;
                selectedPapers.clear();

                const controlsElement = document.getElementById(
                    "paper-selection-controls",
                );
                const selectButton = document.querySelector(
                    "button[onclick='toggleSelectionMode()']",
                );

                if (paperSelectionMode) {
                    if (controlsElement)
                        controlsElement.classList.add("active");
                    if (selectButton)
                        selectButton.innerHTML =
                            "<span>☑️</span> Exit Selection";
                } else {
                    if (controlsElement)
                        controlsElement.classList.remove("active");
                    if (selectButton)
                        selectButton.innerHTML =
                            "<span>☑️</span> Select Papers";
                }

                updateSelectedCount();
                renderPapers(
                    currentlyFilteredPapers.length > 0
                        ? currentlyFilteredPapers
                        : null,
                );
            }

            function togglePaperSelection(paperId) {
                if (!paperId) {
                    return;
                }



                if (selectedPapers.has(paperId)) {
                    selectedPapers.delete(paperId);

                } else {
                    selectedPapers.add(paperId);

                }



                updateSelectedCount();
                updateBulkActionButton();

                // Update visual state without full re-render
                updatePaperSelectionVisuals(paperId);
            }

            function updateSelectedCount() {
                const countElement = document.getElementById("selected-count");
                if (countElement) {
                    countElement.textContent = selectedPapers.size;
                }
            }

            function updateBulkActionButton() {
                const button = document.getElementById("execute-bulk-action");
                const select = document.getElementById("bulk-action-select");



                if (button && select) {
                    button.disabled =
                        selectedPapers.size === 0 || select.value === "";
                }
            }

            function executeBulkAction() {
                const actionSelect =
                    document.getElementById("bulk-action-select");
                const action = actionSelect.value;

                if (!action || selectedPapers.size === 0) {
                    return;
                }

                const selectedPaperIds = Array.from(selectedPapers);
                const selectedPaperObjects = papers.filter((p) =>
                    selectedPaperIds.includes(p.id),
                );

                switch (action) {
                    case "favorite":
                        selectedPaperObjects.forEach((paper) => {
                            paper.favorite = true;
                        });
                        savePapers();
                        showMessage(
                            `Marked ${selectedPaperObjects.length} papers as favorite`,
                            "success",
                        );
                        break;
                    case "unfavorite":
                        selectedPaperObjects.forEach((paper) => {
                            paper.favorite = false;
                        });
                        savePapers();
                        showMessage(
                            `Removed ${selectedPaperObjects.length} papers from favorites`,
                            "success",
                        );
                        break;
                    case "add-labels":
                        showBulkLabelDialog(selectedPaperIds);
                        return;
                    case "remove-labels":
                        showBulkRemoveLabelDialog(selectedPaperIds);
                        return;
                    case "set-status-referenced":
                        selectedPaperObjects.forEach((paper) => {
                            paper.readingStatus = "referenced";
                        });
                        savePapers();
                        showMessage(
                            `Set ${selectedPaperObjects.length} papers to status: Referenced`,
                            "success",
                        );
                        break;
                    case "set-status-to-read":
                        selectedPaperObjects.forEach((paper) => {
                            paper.readingStatus = "to-read";
                        });
                        savePapers();
                        showMessage(
                            `Set ${selectedPaperObjects.length} papers to status: To Read`,
                            "success",
                        );
                        break;
                    case "set-status-skimmed":
                        selectedPaperObjects.forEach((paper) => {
                            paper.readingStatus = "skimmed";
                        });
                        savePapers();
                        showMessage(
                            `Set ${selectedPaperObjects.length} papers to status: Skimmed`,
                            "success",
                        );
                        break;
                    case "set-status-reading":
                        selectedPaperObjects.forEach((paper) => {
                            paper.readingStatus = "reading";
                        });
                        savePapers();
                        showMessage(
                            `Set ${selectedPaperObjects.length} papers to status: Reading`,
                            "success",
                        );
                        break;
                    case "set-status-read":
                        selectedPaperObjects.forEach((paper) => {
                            paper.readingStatus = "read";
                        });
                        savePapers();
                        showMessage(
                            `Set ${selectedPaperObjects.length} papers to status: Read`,
                            "success",
                        );
                        break;
                    case "move-to-folder":
                        showBulkMoveDialog(selectedPaperIds);
                        return;
                }

                // Reset selection after action (except for dialogs)
                actionSelect.value = "";
                updateBulkActionButton();
                performSearch(); // Maintain current search state
            }

            function selectAllVisiblePapers() {
                // Get currently visible papers (either filtered or all visible)
                const visiblePapers =
                    currentlyFilteredPapers.length > 0
                        ? currentlyFilteredPapers
                        : getCurrentlyFilteredPapers();
                visiblePapers.forEach((paper) => {
                    selectedPapers.add(paper.id);
                });
                updateSelectedCount();
                updateBulkActionButton();
                performSearch(); // Maintain current search state
            }

            function deselectAllPapers() {
                selectedPapers.clear();
                updateSelectedCount();
                updateBulkActionButton();
                performSearch(); // Maintain current search state
            }

            function updatePaperSelectionVisuals(paperId) {


                const paperElement = document.querySelector(
                    `[data-paper-id="${paperId}"]`,
                );
                const checkbox = paperElement?.querySelector(".paper-checkbox");



                if (paperElement && checkbox) {
                    if (selectedPapers.has(paperId)) {
                        paperElement.classList.add("selected");
                        checkbox.checked = true;

                    } else {
                        paperElement.classList.remove("selected");
                        checkbox.checked = false;

                    }

                }
            }

            function showBulkLabelDialog(paperIds) {
                // Create backdrop
                const backdrop = document.createElement("div");
                backdrop.style.position = "fixed";
                backdrop.style.top = "0";
                backdrop.style.left = "0";
                backdrop.style.width = "100%";
                backdrop.style.height = "100%";
                backdrop.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
                backdrop.style.zIndex = "999";
                backdrop.id = "bulk-label-backdrop";
                backdrop.onclick = (event) => {
                    if (event.target === backdrop) {
                        backdrop.remove();
                    }
                };

                const modal = document.createElement("div");
                modal.className = "modal-content";
                modal.style.position = "fixed";
                modal.style.top = "50%";
                modal.style.left = "50%";
                modal.style.transform = "translate(-50%, -50%)";
                modal.style.zIndex = "1000";
                modal.style.backgroundColor = "white";
                modal.style.border = "1px solid #ccc";
                modal.style.borderRadius = "8px";
                modal.style.padding = "20px";
                modal.style.minWidth = "400px";
                modal.style.maxWidth = "600px";

                modal.innerHTML = `
                    <div class="modal-header">
                        <h3>Add Labels to Selected Papers</h3>
                        <span class="close" onclick="closeBulkLabelDialog()">&times;</span>
                    </div>
                    <div style="margin: 20px 0;">
                        <p>Add labels to ${paperIds.length} selected papers:</p>
                        <p style="font-size: 12px; color: #666; margin: 8px 0;">Click on labels to select them. Selected labels will be highlighted in blue.</p>
                        <div id="bulk-label-sets"></div>
                        <button class="btn" onclick="addNewLabelSet('bulk')">Add Label Set</button>
                    </div>
                    <div class="modal-actions">
                        <button class="btn btn-success" onclick="applyBulkLabels('${paperIds.join(",")}')">Apply Labels</button>
                        <button class="btn btn-secondary" onclick="closeBulkLabelDialog()">Cancel</button>
                    </div>
                `;

                backdrop.className = "modal-backdrop";
                backdrop.appendChild(modal);

                // Prevent modal content clicks from closing the dialog
                modal.onclick = (event) => {
                    event.stopPropagation();
                };

                document.body.appendChild(backdrop);

                // Add initial label set
                console.log(
                    "[BULK LABELS] Creating bulk label dialog, adding initial label set",
                );
                setTimeout(() => {
                    console.log(
                        "[BULK LABELS] Adding new label set for bulk mode",
                    );
                    addNewLabelSet("bulk");
                }, 50);
            }

            function closeBulkLabelDialog() {
                const backdrop = document.getElementById("bulk-label-backdrop");
                if (backdrop) {
                    backdrop.remove();
                }
            }

            function applyBulkLabels(paperIdsString) {
                console.log("[BULK LABELS] Starting bulk label application");
                console.log("[BULK LABELS] Paper IDs string:", paperIdsString);

                const paperIds = paperIdsString.split(",");
                console.log("[BULK LABELS] Paper IDs array:", paperIds);

                const labelSets = getLabelSets("bulk");
                console.log("[BULK LABELS] Label sets retrieved:", labelSets);

                if (labelSets.length === 0) {
                    console.log("[BULK LABELS] No label sets found");
                    showMessage("Please add at least one label", "error");
                    return;
                }

                paperIds.forEach((paperId) => {
                    const paper = papers.find((p) => p.id == paperId);
                    if (paper) {
                        // Store original paper for change tracking
                        const originalPaper = { ...paper };
                        if (!paper.labelSets) {
                            paper.labelSets = [];
                        }

                        labelSets.forEach((newLabelSet) => {
                            if (paper.labelSets.length === 0) {
                                paper.labelSets.push(newLabelSet);
                            } else {
                                // Add to first existing label set
                                const firstLabelSet = paper.labelSets[0];
                                newLabelSet.labels.forEach((label) => {
                                    if (!firstLabelSet.labels.includes(label)) {
                                        firstLabelSet.labels.push(label);
                                    }
                                });

                                // Merge annotations
                                if (newLabelSet.annotations) {
                                    if (!firstLabelSet.annotations) {
                                        firstLabelSet.annotations = {};
                                    }
                                    Object.assign(
                                        firstLabelSet.annotations,
                                        newLabelSet.annotations,
                                    );
                                }
                            }
                        });

                        // Track change
                        trackChange('modify', paper, originalPaper);
                    }
                });

                console.log("[BULK LABELS] Saving papers...");
                savePapers();
                console.log("[BULK LABELS] Papers saved successfully");

                showMessage(
                    `Added labels to ${paperIds.length} papers`,
                    "success",
                );

                console.log(
                    "[BULK LABELS] Closing dialog and refreshing interface",
                );
                closeBulkLabelDialog();
                performSearch(); // Maintain current search state
                renderPapers(); // Update displayed papers with new labels
                console.log("[BULK LABELS] Bulk label operation completed");
            }

            function showBulkRemoveLabelDialog(paperIds) {
                console.log("[BULK REMOVE] showBulkRemoveLabelDialog called with:", paperIds);
                // Create backdrop
                const backdrop = document.createElement("div");
                backdrop.style.position = "fixed";
                backdrop.style.top = "0";
                backdrop.style.left = "0";
                backdrop.style.width = "100%";
                backdrop.style.height = "100%";
                backdrop.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
                backdrop.style.zIndex = "999";
                backdrop.id = "bulk-remove-label-backdrop";
                backdrop.onclick = (event) => {
                    if (event.target === backdrop) {
                        backdrop.remove();
                    }
                };

                const modal = document.createElement("div");
                modal.className = "modal-content";
                modal.style.position = "fixed";
                modal.style.top = "50%";
                modal.style.left = "50%";
                modal.style.transform = "translate(-50%, -50%)";
                modal.style.zIndex = "1000";
                modal.style.backgroundColor = "white";
                modal.style.border = "1px solid #ccc";
                modal.style.borderRadius = "8px";
                modal.style.padding = "20px";
                modal.style.minWidth = "400px";
                modal.style.maxWidth = "600px";

                modal.innerHTML = `
                    <div class="modal-header">
                        <h3>Remove Labels from Selected Papers</h3>
                        <span class="close" onclick="closeBulkRemoveLabelDialog()">&times;</span>
                    </div>
                    <div style="margin: 20px 0;">
                        <p>Remove labels from ${paperIds.length} selected papers:</p>
                        <p style="font-size: 12px; color: #666; margin: 8px 0;">Click on labels to select them. Selected labels will be highlighted in blue.</p>
                        <div id="bulk-remove-label-sets"></div>
                        <button class="btn" onclick="addNewLabelSet('bulk-remove')">Add Label Set</button>
                    </div>
                    <div class="modal-actions">
                        <button class="btn btn-danger" onclick="applyBulkRemoveLabels('${paperIds.join(",")}')">Remove Labels</button>
                        <button class="btn btn-secondary" onclick="closeBulkRemoveLabelDialog()">Cancel</button>
                    </div>
                `;

                backdrop.className = "modal-backdrop";
                backdrop.appendChild(modal);

                // Prevent modal content clicks from closing the dialog
                modal.onclick = (event) => {
                    event.stopPropagation();
                };

                document.body.appendChild(backdrop);

                // Add initial label set
                console.log(
                    "[BULK REMOVE] Creating bulk remove label dialog, adding initial label set",
                );
                setTimeout(() => {
                    console.log(
                        "[BULK REMOVE] Adding new label set for bulk-remove mode",
                    );
                    addNewLabelSet("bulk-remove");
                }, 50);
            }

            function closeBulkRemoveLabelDialog() {
                const backdrop = document.getElementById("bulk-remove-label-backdrop");
                if (backdrop) {
                    backdrop.remove();
                }
            }

            function applyBulkRemoveLabels(paperIdsString) {
                console.log("[BULK REMOVE LABELS] Starting bulk label removal");
                console.log("[BULK REMOVE LABELS] Paper IDs string:", paperIdsString);

                const paperIds = paperIdsString.split(",");
                console.log("[BULK REMOVE LABELS] Paper IDs array:", paperIds);

                const labelSets = getLabelSets("bulk-remove");
                console.log("[BULK REMOVE LABELS] Label sets retrieved:", labelSets);

                if (labelSets.length === 0) {
                    console.log("[BULK REMOVE LABELS] No label sets found");
                    showMessage("Please add at least one label to remove", "error");
                    return;
                }

                paperIds.forEach((paperId) => {
                    const paper = papers.find((p) => p.id == paperId);
                    if (paper && paper.labelSets) {
                        // Store original paper for change tracking
                        const originalPaper = { ...paper };
                        labelSets.forEach((removeSet) => {
                            paper.labelSets.forEach((paperLabelSet) => {
                                // Remove labels from this label set
                                removeSet.labels.forEach((labelToRemove) => {
                                    const index = paperLabelSet.labels.indexOf(labelToRemove);
                                    if (index > -1) {
                                        paperLabelSet.labels.splice(index, 1);
                                    }
                                });

                                // Remove annotations if they exist
                                if (removeSet.annotations && paperLabelSet.annotations) {
                                    Object.keys(removeSet.annotations).forEach((key) => {
                                        delete paperLabelSet.annotations[key];
                                    });
                                }
                            });

                            // Remove empty label sets
                            paper.labelSets = paper.labelSets.filter(labelSet => labelSet.labels.length > 0);
                        });

                        // Track change
                        trackChange('modify', paper, originalPaper);
                    }
                });

                console.log("[BULK REMOVE LABELS] Saving papers...");
                savePapers();
                console.log("[BULK REMOVE LABELS] Papers saved successfully");

                showMessage(
                    `Removed labels from ${paperIds.length} papers`,
                    "success",
                );

                console.log(
                    "[BULK REMOVE LABELS] Closing dialog and refreshing interface",
                );
                closeBulkRemoveLabelDialog();
                performSearch(); // Maintain current search state
                renderPapers(); // Update displayed papers with new labels
                console.log("[BULK REMOVE LABELS] Bulk remove label operation completed");
            }

            function showBulkMoveDialog(paperIds) {
                const modal = document.createElement("div");
                modal.className = "modal-content";
                modal.style.position = "fixed";
                modal.style.top = "50%";
                modal.style.left = "50%";
                modal.style.transform = "translate(-50%, -50%)";
                modal.style.zIndex = "1000";
                modal.style.backgroundColor = "white";
                modal.style.border = "1px solid #ccc";
                modal.style.borderRadius = "8px";
                modal.style.padding = "20px";
                modal.style.minWidth = "400px";

                const folderOptions = folders
                    .map(
                        (folder) =>
                            `<option value="${folder.id}">${folder.name}</option>`,
                    )
                    .join("");

                modal.innerHTML = `
                    <div class="modal-header">
                        <h3>Move Selected Papers to Folder</h3>
                        <span class="close" onclick="this.closest('.modal-content').remove()">&times;</span>
                    </div>
                    <div style="margin: 20px 0;">
                        <p>Move ${paperIds.length} selected papers to:</p>
                        <select id="bulk-move-folder" style="width: 100%; padding: 8px; margin: 10px 0;">
                            <option value="">Root</option>
                            ${folderOptions}
                        </select>
                    </div>
                    <div class="modal-actions">
                        <button class="btn btn-success" onclick="applyBulkMove('${paperIds.join(",")}')">Move Papers</button>
                        <button class="btn btn-secondary" onclick="this.closest('.modal-content').remove()">Cancel</button>
                    </div>
                `;

                document.body.appendChild(modal);
            }

            function applyBulkMove(paperIdsString) {
                const paperIds = paperIdsString.split(",");
                const targetFolder =
                    document.getElementById("bulk-move-folder").value;

                paperIds.forEach((paperId) => {
                    const paper = papers.find((p) => p.id == paperId);
                    if (paper) {
                        paper.folder = targetFolder;
                    }
                });

                savePapers();
                const folderName = targetFolder
                    ? folders.find((f) => f.id === targetFolder)?.name ||
                      "Unknown"
                    : "Root";
                showMessage(
                    `Moved ${paperIds.length} papers to ${folderName}`,
                    "success",
                );
                document.querySelector(".modal-content").remove();
                performSearch(); // Maintain current search state
            }

            // Update bulk action button when dropdown changes
            document.addEventListener("DOMContentLoaded", function () {
                const actionSelect =
                    document.getElementById("bulk-action-select");
                if (actionSelect) {
                    actionSelect.addEventListener(
                        "change",
                        updateBulkActionButton,
                    );
                }
            });

            function openBatchAddModal() {
                document.getElementById("batchAddModal").style.display =
                    "block";
                populateFolderSelects();
                // Reset modal state
                document.getElementById("batchUrlsTextarea").value = "";
                document.getElementById("batchProgress").style.display = "none";
                document.getElementById("batchResults").innerHTML = "";
                document.getElementById("batchProcessBtn").disabled = false;
                document.getElementById("batchProcessBtn").textContent =
                    "Process URLs";
            }

            function closeBatchAddModal() {
                document.getElementById("batchAddModal").style.display = "none";
            }

            async function processBatchAdd() {
                const textarea = document.getElementById("batchUrlsTextarea");
                const folderSelect = document.getElementById("batchFolder");
                const progressDiv = document.getElementById("batchProgress");
                const progressBar = document.getElementById("batchProgressBar");
                const progressText =
                    document.getElementById("batchProgressText");
                const resultsDiv = document.getElementById("batchResults");
                const processBtn = document.getElementById("batchProcessBtn");

                const urls = textarea.value
                    .trim()
                    .split("\n")
                    .filter((url) => url.trim());

                if (urls.length === 0) {
                    showMessage("Please enter at least one URL", "error");
                    return;
                }

                // Validate URLs
                const validUrls = [];
                const invalidUrls = [];

                urls.forEach((url) => {
                    const trimmedUrl = url.trim();
                    try {
                        new URL(trimmedUrl);
                        validUrls.push(trimmedUrl);
                    } catch (e) {
                        invalidUrls.push(trimmedUrl);
                    }
                });

                if (invalidUrls.length > 0) {
                    showMessage(
                        `Found ${invalidUrls.length} invalid URLs. Please check your input.`,
                        "error",
                    );
                    return;
                }

                // Show progress
                progressDiv.style.display = "block";
                processBtn.disabled = true;
                processBtn.textContent = "Processing...";
                resultsDiv.innerHTML = "";

                const selectedFolder = folderSelect.value;
                let successCount = 0;
                let errorCount = 0;
                let duplicateCount = 0;

                for (let i = 0; i < validUrls.length; i++) {
                    const url = validUrls[i];
                    const progress = ((i + 1) / validUrls.length) * 100;

                    progressBar.style.width = progress + "%";
                    progressText.textContent = `Processing ${i + 1} of ${validUrls.length}: ${url}`;

                    try {
                        // Check if paper already exists
                        const existingPaper = papers.find((p) => p.url === url);
                        if (existingPaper) {
                            duplicateCount++;
                            addBatchResult(
                                url,
                                "warning",
                                "Paper already exists",
                            );
                            continue;
                        }

                        // Fetch metadata
                        const metadata = await fetchPaperMetadataForBatch(url);

                        if (metadata) {
                            // Create paper object
                            const paper = {
                                id:
                                    Date.now() +
                                    "_" +
                                    Math.random().toString(36).substr(2, 9),
                                title: metadata.title || "Untitled",
                                authors: metadata.authors || "Unknown",
                                year: metadata.year || new Date().getFullYear(),
                                url: url,
                                abstract: metadata.abstract || "",
                                labels: [],
                                labelSets: [],
                                previousWorks: [],
                                folder: selectedFolder || "",
                                dateAdded: new Date().toISOString(),
                                isFavorite: false,
                                readingStatus: "referenced",
                                contactEmails: metadata.contactEmails || "",
                                scratchpad: "",
                            };

                            papers.push(paper);

                            // Track change
                            trackChange('add', paper);

                            successCount++;
                            addBatchResult(
                                url,
                                "success",
                                `Added: ${paper.title}`,
                            );
                        } else {
                            errorCount++;
                            addBatchResult(
                                url,
                                "error",
                                "Failed to fetch metadata",
                            );
                        }
                    } catch (error) {
                        errorCount++;
                        addBatchResult(url, "error", `Error: ${error.message}`);
                    }

                    // Small delay to prevent overwhelming the servers
                    if (i < validUrls.length - 1) {
                        await new Promise((resolve) =>
                            setTimeout(resolve, 100),
                        );
                    }
                }

                // Save papers and update UI
                savePapers();
                performSearch(); // Maintain current search state

                // Update progress
                progressBar.style.width = "100%";
                progressText.textContent = `Complete! Added: ${successCount}, Errors: ${errorCount}, Duplicates: ${duplicateCount}`;
                processBtn.disabled = false;
                processBtn.textContent = "Process URLs";

                showMessage(
                    `Batch add complete. Added ${successCount} papers, ${errorCount} errors, ${duplicateCount} duplicates.`,
                    successCount > 0 ? "success" : "info",
                );
            }

            function addBatchResult(url, type, message) {
                const resultsDiv = document.getElementById("batchResults");
                const resultItem = document.createElement("div");
                resultItem.className = `batch-result-item batch-result-${type}`;
                resultItem.innerHTML = `<strong>${url}:</strong> ${message}`;
                resultsDiv.appendChild(resultItem);
                resultsDiv.scrollTop = resultsDiv.scrollHeight;
            }

            async function fetchPaperMetadataForBatch(url) {
                try {
                    // Detect URL type and validate format
                    let paperId = "";
                    let urlType = "";

                    const eprintMatch = url.match(
                        /eprint\.iacr\.org\/(\d{4}\/\d+)$/,
                    );
                    const springerMatch = url.match(
                        /link\.springer\.com\/chapter\/10\.1007\/(.+)$/,
                    );
                    const acmMatch = url.match(
                        /dl\.acm\.org\/doi\/10\.1145\/(.+)$/,
                    );
                    const ieeeMatch = url.match(
                        /ieeexplore\.ieee\.org\/document\/(\d+)/,
                    );

                    if (eprintMatch) {
                        paperId = eprintMatch[1];
                        urlType = "eprint";
                    } else if (springerMatch) {
                        paperId = springerMatch[1];
                        urlType = "springer";
                    } else if (acmMatch) {
                        paperId = acmMatch[1];
                        urlType = "acm";
                    } else if (ieeeMatch) {
                        paperId = ieeeMatch[1];
                        urlType = "ieee";
                    } else {
                        throw new Error("Unsupported URL format");
                    }

                    // Try direct fetch first (works if CORS is disabled)
                    try {
                        const response = await fetch(url, {
                            mode: "cors",
                            headers: {
                                Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                                "User-Agent":
                                    "Mozilla/5.0 (compatible; Paper Manager)",
                            },
                        });
                        if (response.ok) {
                            const html = await response.text();

                            // Parse the HTML directly
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(
                                html,
                                "text/html",
                            );

                            // Extract metadata from the HTML
                            const metadata = parseHtmlMetadata(
                                doc,
                                paperId,
                                urlType,
                            );

                            return {
                                title: metadata.title,
                                authors: metadata.authors,
                                abstract: metadata.abstract,
                                year: metadata.date
                                    ? new Date(metadata.date).getFullYear()
                                    : new Date().getFullYear(),
                                contactEmails: metadata.contactEmails,
                            };
                        }
                    } catch (corsError) {
                        console.log(
                            "Direct fetch failed, trying proxy methods...",
                        );
                    }

                    // If direct fetch fails, try alternative proxy methods
                    const proxyUrls = [
                        `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
                        `https://cors-anywhere.herokuapp.com/${url}`,
                        `https://corsproxy.io/?${encodeURIComponent(url)}`,
                    ];

                    for (const proxyUrl of proxyUrls) {
                        try {
                            const response = await fetch(proxyUrl);
                            if (response.ok) {
                                const data = await response.json();
                                const html = data.contents || data;

                                const parser = new DOMParser();
                                const doc = parser.parseFromString(
                                    html,
                                    "text/html",
                                );

                                const metadata = parseHtmlMetadata(
                                    doc,
                                    paperId,
                                    urlType,
                                );

                                return {
                                    title: metadata.title,
                                    authors: metadata.authors,
                                    abstract: metadata.abstract,
                                    year: metadata.date
                                        ? new Date(metadata.date).getFullYear()
                                        : new Date().getFullYear(),
                                    contactEmails: metadata.contactEmails,
                                };
                            }
                        } catch (proxyError) {
                            console.log(
                                `Proxy ${proxyUrl} failed:`,
                                proxyError,
                            );
                            continue;
                        }
                    }

                    throw new Error(
                        "All fetch methods failed. Please ensure CORS Unblock is enabled.",
                    );
                } catch (error) {
                    console.error("Error fetching metadata for", url, error);
                    return null;
                }
            }

            // Recovery function - can be called from browser console
            window.recoverDatabase = function () {
                console.log("=== DATABASE RECOVERY TOOL ===");

                // Check all localStorage keys
                const allKeys = Object.keys(localStorage);
                console.log("All localStorage keys:", allKeys);

                // Look for potential backup keys
                const cryptoKeys = allKeys.filter(
                    (key) =>
                        key.toLowerCase().includes("crypto") ||
                        key.toLowerCase().includes("paper") ||
                        key.toLowerCase().includes("backup"),
                );

                if (cryptoKeys.length > 0) {
                    console.log("Found potential database keys:", cryptoKeys);

                    cryptoKeys.forEach((key) => {
                        const data = localStorage.getItem(key);
                        console.log(
                            `Key: ${key}, Length: ${data ? data.length : 0}`,
                        );

                        if (data && data.length > 100) {
                            try {
                                const parsed = JSON.parse(data);
                                if (
                                    Array.isArray(parsed) &&
                                    parsed.length > 0 &&
                                    parsed[0].title
                                ) {
                                    console.log(
                                        `✅ Key "${key}" contains ${parsed.length} papers`,
                                    );
                                    console.log(
                                        `First paper: ${parsed[0].title}`,
                                    );
                                    console.log(
                                        `To restore this data, run: restoreFromKey("${key}")`,
                                    );
                                }
                            } catch (e) {
                                console.log(
                                    `❌ Key "${key}" contains invalid JSON`,
                                );
                            }
                        }
                    });
                } else {
                    console.log("❌ No potential database keys found");
                }

                // Check if current data is recoverable
                const currentData = localStorage.getItem("cryptoPapers");
                if (currentData && currentData.length > 0) {
                    console.log(
                        "Current cryptoPapers key has data, attempting to parse...",
                    );
                    try {
                        const parsed = JSON.parse(currentData);
                        console.log(
                            `Current data contains ${parsed.length} papers`,
                        );
                    } catch (e) {
                        console.log("Current data is corrupted:", e.message);
                        console.log(
                            "Raw data preview:",
                            currentData.substring(0, 200),
                        );
                    }
                }
            };

            // Restore function - can be called from browser console
            window.restoreFromKey = function (keyName) {
                const data = localStorage.getItem(keyName);
                if (!data) {
                    console.log(`❌ Key "${keyName}" not found`);
                    return;
                }

                try {
                    const parsed = JSON.parse(data);
                    if (Array.isArray(parsed)) {
                        localStorage.setItem("cryptoPapers", data);
                        console.log(
                            `✅ Restored ${parsed.length} papers from key "${keyName}"`,
                        );
                        console.log("Reloading page...");
                        location.reload();
                    } else {
                        console.log(
                            `❌ Key "${keyName}" doesn't contain an array`,
                        );
                    }
                } catch (e) {
                    console.log(
                        `❌ Failed to parse data from key "${keyName}":`,
                        e.message,
                    );
                }
            };

            console.log(
                "Recovery tools loaded. Run recoverDatabase() in console to diagnose issues.",
            );

            // Add database size monitoring for IndexedDB
            window.checkDatabaseSize = function () {
                const jsonData = JSON.stringify(papers);
                const sizeInBytes = new Blob([jsonData]).size;
                const sizeInMB = (sizeInBytes / (1024 * 1024)).toFixed(2);
                console.log(
                    `Database size: ${papers.length} papers, ${sizeInMB} MB`,
                );
                console.log(`JSON length: ${jsonData.length} characters`);

                // IndexedDB can handle much larger databases (typically 100s of MB to several GB)
                const warningLimit = 100; // MB
                if (sizeInMB > warningLimit) {
                    console.warn(
                        `⚠️ Very large database (${sizeInMB}MB > ${warningLimit}MB). Consider archiving old papers.`,
                    );
                    console.log(
                        "Consider running: optimizeDatabase() to reduce size",
                    );
                } else {
                    console.log(
                        `✅ Database size: ${sizeInMB}MB (IndexedDB can handle much larger databases)`,
                    );
                }

                // Check IndexedDB usage if available
                if (navigator.storage && navigator.storage.estimate) {
                    navigator.storage.estimate().then((estimate) => {
                        const usedMB = (estimate.usage / (1024 * 1024)).toFixed(
                            2,
                        );
                        const quotaMB = (
                            estimate.quota /
                            (1024 * 1024)
                        ).toFixed(2);
                        console.log(
                            `Storage used: ${usedMB}MB / ${quotaMB}MB available`,
                        );
                    });
                }
            };

            // Add database optimization function
            window.optimizeDatabase = function () {
                console.log("=== DATABASE OPTIMIZATION ===");
                const originalCount = papers.length;

                // Remove duplicates by URL
                const seenUrls = new Set();
                papers = papers.filter((paper) => {
                    if (seenUrls.has(paper.url)) {
                        console.log(`Removing duplicate: ${paper.title}`);
                        return false;
                    }
                    seenUrls.add(paper.url);
                    return true;
                });

                // Truncate long abstracts and scratchpads
                papers.forEach((paper) => {
                    if (paper.abstract && paper.abstract.length > 1000) {
                        paper.abstract =
                            paper.abstract.substring(0, 1000) + "...";
                    }
                    if (paper.scratchpad && paper.scratchpad.length > 500) {
                        paper.scratchpad =
                            paper.scratchpad.substring(0, 500) + "...";
                    }
                });

                const removedCount = originalCount - papers.length;
                console.log(
                    `Optimization complete: removed ${removedCount} duplicates, truncated long text fields`,
                );
                updatePaperCount();
                console.log("Run savePapers() to save optimized database");
                console.log("Run checkDatabaseSize() to verify new size");
            };

            // Add IndexedDB export/import functions
            window.exportDatabaseToFile = async function () {
                try {
                    const data = {
                        papers: papers,
                        folders: folders,
                        exportDate: new Date().toISOString(),
                        version: "2.0_IndexedDB",
                    };

                    const jsonData = JSON.stringify(data, null, 2);
                    const blob = new Blob([jsonData], {
                        type: "application/json",
                    });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `crypto_papers_export_${new Date().toISOString().split("T")[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    console.log(
                        `Exported ${papers.length} papers and ${folders.length} folders to file`,
                    );
                } catch (error) {
                    console.error("Export failed:", error);
                }
            };

            window.clearIndexedDB = async function () {
                if (
                    confirm(
                        "Are you sure you want to clear the entire database? This cannot be undone!",
                    )
                ) {
                    try {
                        const transaction = db.transaction(
                            [PAPERS_STORE, FOLDERS_STORE],
                            "readwrite",
                        );
                        await Promise.all([
                            new Promise((resolve, reject) => {
                                const clearPapers = transaction
                                    .objectStore(PAPERS_STORE)
                                    .clear();
                                clearPapers.onsuccess = () => resolve();
                                clearPapers.onerror = () =>
                                    reject(clearPapers.error);
                            }),
                            new Promise((resolve, reject) => {
                                const clearFolders = transaction
                                    .objectStore(FOLDERS_STORE)
                                    .clear();
                                clearFolders.onsuccess = () => resolve();
                                clearFolders.onerror = () =>
                                    reject(clearFolders.error);
                            }),
                        ]);

                        papers = [];
                        folders = [];
                        currentlyFilteredPapers = [];
                        renderPapers([]);
                        renderFolders();
                        console.log("Database cleared successfully");
                        showMessage("Database cleared", "success");
                    } catch (error) {
                        console.error("Error clearing database:", error);
                        showMessage("Error clearing database", "error");
                    }
                }
            };

            // Emergency recovery function
            window.emergencyRecover = function () {
                console.log("=== EMERGENCY RECOVERY ===");
                const keys = [
                    "cryptoPapers",
                    "cryptoPapers_backup",
                    "cryptoPapers_compressed",
                ];

                for (const key of keys) {
                    const data = localStorage.getItem(key);
                    if (data) {
                        try {
                            const parsed = JSON.parse(data);
                            if (Array.isArray(parsed) && parsed.length > 0) {
                                console.log(
                                    `Found ${parsed.length} papers in ${key}`,
                                );
                                console.log(
                                    `To restore: localStorage.setItem('cryptoPapers', localStorage.getItem('${key}')); location.reload();`,
                                );

                                if (
                                    confirm(
                                        `Found ${parsed.length} papers in ${key}. Restore them now?`,
                                    )
                                ) {
                                    localStorage.setItem("cryptoPapers", data);
                                    location.reload();
                                    return;
                                }
                            }
                        } catch (e) {
                            console.log(`${key} contains invalid data`);
                        }
                    }
                }

                console.log("No recoverable data found in localStorage");
            };

            // Add IndexedDB status check function
            window.checkIndexedDBStatus = async function () {
                console.log("=== INDEXEDDB STATUS CHECK ===");

                if (!db) {
                    console.log("❌ IndexedDB not initialized");
                    return;
                }

                try {
                    const transaction = db.transaction(
                        [PAPERS_STORE],
                        "readonly",
                    );
                    const store = transaction.objectStore(PAPERS_STORE);

                    const count = await new Promise((resolve, reject) => {
                        const countRequest = store.count();
                        countRequest.onsuccess = () =>
                            resolve(countRequest.result);
                        countRequest.onerror = () => reject(countRequest.error);
                    });

                    console.log(`✅ IndexedDB contains ${count} papers`);
                    console.log(
                        `📊 In-memory papers array: ${papers.length} papers`,
                    );

                    if (count === papers.length) {
                        console.log("✅ IndexedDB and memory are in sync");
                    } else {
                        console.log(
                            `⚠️ MISMATCH: IndexedDB has ${count}, memory has ${papers.length}`,
                        );
                        if (papers.length > count) {
                            console.log(
                                "💡 Run savePapers() to sync memory to IndexedDB",
                            );
                        }
                    }

                    // Check localStorage status
                    const localData = localStorage.getItem("cryptoPapers");
                    if (localData) {
                        const localPapers = JSON.parse(localData);
                        console.log(
                            `📦 localStorage still contains ${localPapers.length} papers`,
                        );
                        console.log(
                            "💡 You can clear localStorage if IndexedDB is working: localStorage.removeItem('cryptoPapers')",
                        );
                    } else {
                        console.log(
                            "✅ localStorage cleared - using IndexedDB only",
                        );
                    }
                } catch (error) {
                    console.error("❌ Error checking IndexedDB:", error);
                }
            };

            console.log(
                "Database tools loaded: checkDatabaseSize(), optimizeDatabase(), exportDatabaseToFile(), clearIndexedDB(), emergencyRecover(), checkIndexedDBStatus(), checkStorageStatus()",
            );

            // Storage recovery and diagnostic functions
            // Storage status check function
            async function checkStorageStatus() {
                console.log("=== STORAGE STATUS CHECK ===");

                // Check storage persistence
                if ("storage" in navigator && "persist" in navigator.storage) {
                    try {
                        const persistent = await navigator.storage.persist();
                        console.log(
                            `Storage persistence: ${persistent ? "GRANTED" : "DENIED"}`,
                        );

                        const estimate = await navigator.storage.estimate();
                        console.log(
                            `Storage usage: ${(estimate.usage / 1024 / 1024).toFixed(2)} MB of ${(estimate.quota / 1024 / 1024).toFixed(2)} MB`,
                        );
                    } catch (error) {
                        console.error("Storage API error:", error);
                    }
                }

                // Check IndexedDB status
                try {
                    if (db) {
                        const transaction = db.transaction(
                            [PAPERS_STORE, FOLDERS_STORE],
                            "readonly",
                        );
                        const papersStore =
                            transaction.objectStore(PAPERS_STORE);
                        const foldersStore =
                            transaction.objectStore(FOLDERS_STORE);

                        const papersCount = await new Promise((resolve) => {
                            const countRequest = papersStore.count();
                            countRequest.onsuccess = () =>
                                resolve(countRequest.result);
                            countRequest.onerror = () => resolve(0);
                        });

                        const foldersCount = await new Promise((resolve) => {
                            const countRequest = foldersStore.count();
                            countRequest.onsuccess = () =>
                                resolve(countRequest.result);
                            countRequest.onerror = () => resolve(0);
                        });

                        console.log(
                            `IndexedDB: ${papersCount} papers, ${foldersCount} folders`,
                        );
                        console.log(
                            `Memory: ${papers.length} papers, ${folders.length} folders`,
                        );

                        if (
                            papersCount !== papers.length ||
                            foldersCount !== folders.length
                        ) {
                            console.warn(
                                "MISMATCH between IndexedDB and memory!",
                            );
                            return false;
                        }
                    } else {
                        console.error("IndexedDB not initialized");
                        return false;
                    }
                } catch (error) {
                    console.error("IndexedDB check failed:", error);
                    return false;
                }

                console.log("✅ Storage status OK");
                return true;
            }

            function openStorageDiagnostic() {
                const diagnosticUrl = new URL(
                    "./storage_diagnostic.html",
                    window.location.href,
                );
                window.open(diagnosticUrl.toString(), "_blank");
                showMessage(
                    "Opened storage diagnostic tool in new tab",
                    "info",
                );
            }

            async function forceDataReload() {
                try {
                    showMessage(
                        "Force reloading data from all storage sources...",
                        "info",
                    );
                    console.log(
                        "[FORCE RELOAD] Starting comprehensive data reload...",
                    );

                    // Clear current data
                    papers = [];

                    // Force reload from storage
                    await loadPapers();

                    // Update UI
                    performSearch();
                    renderPapers();
                    if (
                        document.getElementById("graph-display").style
                            .display !== "none"
                    ) {
                        renderGraph();
                    }

                    showMessage(
                        `Data reloaded successfully: ${papers.length} papers found`,
                        "success",
                    );
                    console.log(
                        `[FORCE RELOAD] ✅ Successfully reloaded ${papers.length} papers`,
                    );
                } catch (error) {
                    console.error(
                        "[FORCE RELOAD] ❌ Error during forced reload:",
                        error,
                    );
                    showMessage(
                        `Error during data reload: ${error.message}`,
                        "error",
                    );
                }
            }

            // Make function globally available for module script
            window.forceDataReload = forceDataReload;

            // Make other essential functions globally available
            window.openStorageDiagnostic = openStorageDiagnostic;
            window.checkStorageStatus = checkStorageStatus;
            window.savePapers = savePapers;
            window.switchTab = switchTab;
            window.setViewMode = setViewMode;
            window.addNewFolder = addNewFolder;
            window.renameFolder = renameFolder;
            window.deleteFolder = deleteFolder;
            window.loadPapers = loadPapers;
            window.performSearch = performSearch;
            window.renderPapers = renderPapers;
            window.renderLabels = renderLabels;
            window.toggleLabel = toggleLabel;
            window.toggleGraph = toggleGraph;
            window.renderGraph = renderGraph;
            window.showMessage = showMessage;
            window.clearFilters = clearFilters;
            window.viewPaper = viewPaper;
            window.closePaperModal = closePaperModal;
            window.enableEditing = enableEditing;
            window.cancelEditing = cancelEditing;
            window.saveEditedPaper = saveEditedPaper;
            window.deletePaper = deletePaper;
            window.openScratchpad = openScratchpad;
            window.closeScratchpadModal = closeScratchpadModal;
            window.switchScratchpadTab = switchScratchpadTab;
            window.saveScratchpad = saveScratchpad;
            window.changeSortOrder = changeSortOrder;
            window.cycleReadingStatus = cycleReadingStatus;
            window.toggleFavorite = toggleFavorite;
            window.toggleFavoriteFilter = toggleFavoriteFilter;
            window.editContactEmails = editContactEmails;
            window.emailAuthors = emailAuthors;
            window.refreshAllMetadata = refreshAllMetadata;
            window.refreshMetadata = refreshMetadata;
            window.toggleSelectionMode = toggleSelectionMode;
            window.togglePaperSelection = togglePaperSelection;
            window.selectAllVisiblePapers = selectAllVisiblePapers;
            window.deselectAllPapers = deselectAllPapers;
            window.executeBulkAction = executeBulkAction;
            window.openBatchAddModal = openBatchAddModal;
            window.closeBatchAddModal = closeBatchAddModal;
            window.processBatchAdd = processBatchAdd;
            window.fetchPaperMetadata = fetchPaperMetadata;
            window.parseManualContent = parseManualContent;
            window.savePaper = savePaper;
            window.showCorsHelp = showCorsHelp;
            window.showManualParser = showManualParser;
            window.addNewLabelSet = addNewLabelSet;
            window.addPreviousWorkByUrl = addPreviousWorkByUrl;
            window.showSearchHelp = showSearchHelp;
            window.validateAndDebounceSearch = validateAndDebounceSearch;
            window.filterByReadingStatus = filterByReadingStatus;
            window.toggleLabelFilter = toggleLabelFilter;
            window.openPaperLink = openPaperLink;
            window.updateReadingStatusStats = updateReadingStatusStats;
            window.showBulkLabelDialog = showBulkLabelDialog;
            window.applyBulkLabels = applyBulkLabels;
            window.closeBulkLabelDialog = closeBulkLabelDialog;
            window.showBulkRemoveLabelDialog = showBulkRemoveLabelDialog;
            window.applyBulkRemoveLabels = applyBulkRemoveLabels;
            window.closeBulkRemoveLabelDialog = closeBulkRemoveLabelDialog;
            window.showBulkMoveDialog = showBulkMoveDialog;
            window.applyBulkMove = applyBulkMove;
            window.getLabelSets = getLabelSets;
            window.setLabelSets = setLabelSets;
            window.removeLabelSet = removeLabelSet;
            window.searchPreviousWorks = searchPreviousWorks;
            window.searchEditPreviousWorks = searchEditPreviousWorks;
            window.updateSelectedPreviousWorksDisplay = updateSelectedPreviousWorksDisplay;
            window.refreshGraph = refreshGraph;
            window.showConnectedComponent = showConnectedComponent;
            window.showGraphHelp = showGraphHelp;
            window.saveExtensionPaper = saveExtensionPaper;
            window.syncExtensionPapers = syncExtensionPapers;
            window.updateExtensionSyncBadge = updateExtensionSyncBadge;
            window.showSyncHelp = showSyncHelp;
            window.checkUnknownDates = checkUnknownDates;
            window.checkDateIntegrity = checkDateIntegrity;

            // Data repair functions for corrupted dates
            function checkDateIntegrity() {
                console.log("=== DATE INTEGRITY CHECK ===");

                // Check for dates after August 15, 2025 (likely corrupted during restart)
                const corruptionThreshold = "2025-08-15";

                let corruptedCount = 0;
                let suspiciousCount = 0;
                let validCount = 0;
                let unknownCount = 0;

                papers.forEach((paper, index) => {
                    const paperDate = paper.date;

                    if (
                        !paperDate ||
                        paperDate === "Unknown" ||
                        paperDate === "Unknown date" ||
                        paperDate === ""
                    ) {
                        console.log(
                            `[${index}] Missing/Unknown date: "${paper.title}"`,
                        );
                        unknownCount++;
                    } else if (paperDate > corruptionThreshold) {
                        console.log(
                            `[${index}] Corrupted date (${paperDate}): "${paper.title}"`,
                        );
                        suspiciousCount++;
                    } else {
                        validCount++;
                    }
                });

                console.log(`✅ Valid dates: ${validCount}`);
                console.log(
                    `⚠️ Corrupted dates (after ${corruptionThreshold}): ${suspiciousCount}`,
                );
                console.log(`❓ Unknown dates: ${unknownCount}`);

                if (suspiciousCount > 0) {
                    console.log(
                        "\n💡 Run repairCorruptedDates() to fix corrupted dates",
                    );
                }

                return {
                    valid: validCount,
                    suspicious: suspiciousCount,
                    unknown: unknownCount,
                };
            }

            async function repairCorruptedDates() {
                console.log("=== STARTING DATE REPAIR ===");

                // Fix dates after August 15, 2025 (corruption threshold)
                const corruptionThreshold = "2025-08-15";

                let repairedCount = 0;
                let unreparableCount = 0;

                // Try to repair from URL patterns and addedDate
                papers.forEach((paper, index) => {
                    const originalDate = paper.date;
                    let repairedDate = null;

                    // Skip papers that have valid dates (before corruption threshold)
                    if (
                        originalDate &&
                        originalDate !== "Unknown" &&
                        originalDate !== "Unknown date" &&
                        originalDate !== "" &&
                        originalDate <= corruptionThreshold
                    ) {
                        return;
                    }

                    console.log(
                        `[${index}] Attempting repair for corrupted date (${originalDate}): "${paper.title}"`,
                    );

                    // Method 1: Extract year from URL (eprint papers)
                    if (paper.url && paper.url.includes("eprint.iacr.org")) {
                        const yearMatch = paper.url.match(/\/(\d{4})\//);
                        if (yearMatch) {
                            repairedDate = `${yearMatch[1]}-01-01`;
                            console.log(
                                `[${index}] Repaired from URL year: "${paper.title}" -> ${repairedDate}`,
                            );
                        }
                    }

                    // Method 2: Use addedDate as fallback (but only if it's before corruption)
                    if (!repairedDate && paper.addedDate) {
                        const addedDateStr = paper.addedDate.split("T")[0];
                        if (
                            addedDateStr &&
                            addedDateStr <= corruptionThreshold
                        ) {
                            repairedDate = addedDateStr;
                            console.log(
                                `[${index}] Used addedDate as fallback: "${paper.title}" -> ${repairedDate}`,
                            );
                        }
                    }

                    // Method 3: Extract year from title patterns (e.g., "Paper 2023", "Study (2022)")
                    if (!repairedDate && paper.title) {
                        const titleYearMatch =
                            paper.title.match(/\b(19|20)\d{2}\b/);
                        if (titleYearMatch) {
                            const year = titleYearMatch[0];
                            if (parseInt(year) <= 2025) {
                                // Only use reasonable years
                                repairedDate = `${year}-01-01`;
                                console.log(
                                    `[${index}] Repaired from title year: "${paper.title}" -> ${repairedDate}`,
                                );
                            }
                        }
                    }

                    if (repairedDate) {
                        paper.date = repairedDate;
                        repairedCount++;
                    } else {
                        paper.date = "Unknown date";
                        unreparableCount++;
                        console.log(
                            `[${index}] Could not repair: "${paper.title}" -> Unknown date`,
                        );
                    }
                });

                if (repairedCount > 0 || unreparableCount > 0) {
                    console.log(`\n✅ Repaired ${repairedCount} papers`);
                    console.log(
                        `⚠️ ${unreparableCount} papers set to "Unknown date"`,
                    );

                    // Save the repairs
                    await savePapers();
                    await syncToIndexedDB();

                    // Update UI
                    performSearch();
                    renderPapers();



                    showMessage(
                        `Date repair complete! ${repairedCount} papers repaired, ${unreparableCount} marked as "Unknown date"`,
                        "success",
                    );

                    console.log("=== DATE REPAIR COMPLETE ===");
                } else {
                    showMessage("No corrupted dates found to repair.", "info");
                }

                return {
                    repaired: repairedCount,
                    unreparable: unreparableCount,
                };
            }

            // Extension paper storage functions
            function checkUnknownDates() {
                console.log("=== CHECKING PAPERS WITH UNKNOWN DATES ===");
                let unknownCount = 0;
                papers.forEach((paper, index) => {
                    if (!paper.date || paper.date === "" || paper.date === "Unknown" || paper.date === "Unknown date") {
                        unknownCount++;
                        if (unknownCount <= 10) { // Show first 10 examples
                            console.log(`${unknownCount}. "${paper.title}" - date: "${paper.date}" (${typeof paper.date})`);
                        }
                    }
                });
                console.log(`Total papers with unknown dates: ${unknownCount} out of ${papers.length}`);
                console.log("=== END CHECK ===");
                return unknownCount;
            }

            function saveExtensionPaper(paper) {
                try {
                    let extensionPapers = [];
                    const stored = localStorage.getItem(
                        "cryptoExtensionPapers",
                    );
                    if (stored) {
                        extensionPapers = JSON.parse(stored);
                    }

                    // Check for duplicates
                    const exists = extensionPapers.some(
                        (p) => p.url === paper.url || p.id === paper.id,
                    );
                    if (!exists) {
                        extensionPapers.push({
                            ...paper,
                            extensionSavedAt: new Date().toISOString(),
                        });
                        localStorage.setItem(
                            "cryptoExtensionPapers",
                            JSON.stringify(extensionPapers),
                        );
                        console.log(
                            `[EXTENSION STORAGE] ✅ Instantly saved: "${paper.title}"`,
                        );
                        updateExtensionSyncBadge();
                        showMessage(
                            "Paper saved instantly! ✨ Click 'Sync DB' to permanently store.",
                            "success",
                            true  // Allow stacking with duplicate messages
                        );
                    }
                } catch (error) {
                    console.error("[EXTENSION STORAGE] Failed to save:", error);
                    // Fallback to regular save
                    savePapers();
                }
            }

            function updateExtensionSyncBadge() {
                try {
                    const stored = localStorage.getItem(
                        "cryptoExtensionPapers",
                    );
                    const count = stored ? JSON.parse(stored).length : 0;

                    const badge = document.getElementById(
                        "extension-count-badge",
                    );
                    const syncBtn = document.getElementById("sync-db-btn");

                    if (badge && syncBtn) {
                        if (count > 0) {
                            badge.textContent = count;
                            badge.style.display = "flex";
                            syncBtn.style.animation = "pulse 2s infinite";
                            syncBtn.title = `Sync ${count} extension papers to database`;
                        } else {
                            badge.style.display = "none";
                            syncBtn.style.animation = "none";
                            syncBtn.title =
                                "Sync papers added via browser extension to database";
                        }
                    }
                } catch (error) {
                    console.error(
                        "[EXTENSION BADGE] Error updating badge:",
                        error,
                    );
                }
            }

            async function syncExtensionPapers() {
                try {
                    showMessage(
                        "Syncing extension papers to database...",
                        "info",
                    );

                    const stored = localStorage.getItem(
                        "cryptoExtensionPapers",
                    );
                    if (!stored) {
                        showMessage("No extension papers to sync", "info");
                        return;
                    }

                    const extensionPapers = JSON.parse(stored);
                    if (extensionPapers.length === 0) {
                        showMessage("No extension papers to sync", "info");
                        return;
                    }

                    console.log(
                        `[EXTENSION SYNC] Starting sync of ${extensionPapers.length} papers`,
                    );

                    let syncedCount = 0;
                    let skippedCount = 0;

                    // Add extension papers to main papers array if not already there
                    for (const extensionPaper of extensionPapers) {
                        const exists = papers.some(
                            (p) =>
                                p.url === extensionPaper.url ||
                                p.id === extensionPaper.id,
                        );

                        if (!exists) {
                            // Remove extension-specific metadata
                            delete extensionPaper.extensionSavedAt;
                            papers.push(extensionPaper);
                            syncedCount++;
                            console.log(
                                `[EXTENSION SYNC] ✅ Added: "${extensionPaper.title}"`,
                            );
                        } else {
                            skippedCount++;
                            console.log(
                                `[EXTENSION SYNC] ⏭️ Skipped duplicate: "${extensionPaper.title}"`,
                            );
                        }
                    }

                    // Save to IndexedDB
                    console.log("[EXTENSION SYNC] Saving to IndexedDB...");
                    await syncToIndexedDB();
                    console.log("[EXTENSION SYNC] ✅ Saved to IndexedDB");

                    // Update localStorage cache
                    saveToLocalStorage();

                    // Clear extension storage
                    localStorage.removeItem("cryptoExtensionPapers");
                    console.log(
                        "[EXTENSION SYNC] ✅ Cleared extension storage",
                    );

                    // Update UI
                    performSearch();
                    renderPapers();
                    updateExtensionSyncBadge();

                    showMessage(
                        `✅ Sync complete! ${syncedCount} papers added to database${skippedCount > 0 ? `, ${skippedCount} duplicates skipped` : ""}`,
                        "success",
                    );

                    console.log(
                        `[EXTENSION SYNC] 🎉 Completed: ${syncedCount} synced, ${skippedCount} skipped`,
                    );
                } catch (error) {
                    console.error("[EXTENSION SYNC] ❌ Sync failed:", error);
                    showMessage(`Sync failed: ${error.message}`, "error");
                }
            }

            function showSyncHelp() {
                const helpContent = `
                    <div style="padding: 20px; max-width: 500px;">
                        <h3 style="margin-bottom: 16px;">🔄 Database Sync</h3>

                        <p style="margin-bottom: 16px;">
                            <strong>Why do I need to sync?</strong><br>
                            When you add papers via the browser extension, they're saved instantly to fast storage for immediate confirmation.
                            This ensures papers are never lost even if you close the window immediately.
                        </p>

                        <p style="margin-bottom: 16px;">
                            <strong>What does "Sync DB" do?</strong><br>
                            • Transfers extension papers to the main database<br>
                            • Clears temporary storage to free up space<br>
                            • Ensures papers are permanently saved<br>
                            • Updates all statistics and views
                        </p>

                        <p style="margin-bottom: 16px;">
                            <strong>When should I sync?</strong><br>
                            • When you see a red number badge on the "Sync DB" button<br>
                            • Before exporting your database<br>
                            • Periodically to keep storage clean
                        </p>

                        <p style="color: #28a745; font-weight: 500;">
                            ✨ Extension papers are safe even before syncing!
                        </p>
                    </div>
                `;

                // Create modal
                const backdrop = document.createElement("div");
                backdrop.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0, 0, 0, 0.5); z-index: 999; display: flex;
                    align-items: center; justify-content: center;
                `;

                const modal = document.createElement("div");
                modal.style.cssText = `
                    background: white; border-radius: 12px; max-width: 90vw;
                    max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;

                modal.innerHTML = `
                    ${helpContent}
                    <div style="text-align: center; padding: 0 20px 20px;">
                        <button class="btn" onclick="this.closest('[style*=\"position: fixed\"]').remove()">
                            Got it!
                        </button>
                    </div>
                `;

                backdrop.appendChild(modal);
                document.body.appendChild(backdrop);

                backdrop.onclick = (e) => {
                    if (e.target === backdrop) backdrop.remove();
                };
            }

            // Enhanced error logging for initialization
            window.addEventListener("error", function (e) {
                console.error("[GLOBAL ERROR]", e.error);
                if (
                    e.error &&
                    e.error.message &&
                    e.error.message.includes("IndexedDB")
                ) {
                    showMessage(
                        'IndexedDB error detected. Try using "Fix Storage" tool.',
                        "warning",
                    );
                }
            });

            // Add storage consistency check on focus
            window.addEventListener("focus", function () {
                if (papers.length > 0) {
                    validateDataConsistency();
                }
            });

            console.log(
                "Enhanced database tools loaded: checkDatabaseSize(), optimizeDatabase(), exportDatabaseToFile(), clearIndexedDB(), emergencyRecover(), checkIndexedDBStatus(), checkDateIntegrity(), repairCorruptedDates()",
            );
        </script>
    </body>
</html>
